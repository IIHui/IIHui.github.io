<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Go on Keep It Simple</title>
    <link>https://IIHui.github.io/tags/go/</link>
    <description>Recent content in Go on Keep It Simple</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Mon, 28 May 2018 12:13:06 +0000</lastBuildDate>
    
	<atom:link href="https://IIHui.github.io/tags/go/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Go 实现各种内排序算法</title>
      <link>https://IIHui.github.io/post/go-sort/</link>
      <pubDate>Mon, 28 May 2018 12:13:06 +0000</pubDate>
      
      <guid>https://IIHui.github.io/post/go-sort/</guid>
      <description>内排序是指在排序过程中，数据都能够放在内存中处理，排序时不涉及数据的内、外交换。 插入类排序 直接插入排序 func InsertSort(data []int) { var i, j, cur int length := len(data) //获得切片对应数组的长度 for i = 1; i &amp;lt; length; i++ { cur = data[i] for j = i - 1; j &amp;gt;= 0; j-- { if data[j] &amp;gt; cur { data[j+1] = data[j] } else { break } } data[j+1] = cur } } 二分直接插入排序 func BinInsertSort(data []int) { var cur, start, mid, end int length := len(data) for i := 1; i &amp;lt; length; i++ { cur = data[i] start = 0 end = i - 1 for start &amp;lt;= end { mid = start + (end-start)/2 if data[mid] == cur { end = mid break } else if data[mid] &amp;gt; cur { end = mid - 1 } else { start = mid + 1 } }</description>
    </item>
    
    <item>
      <title>Go 标签</title>
      <link>https://IIHui.github.io/post/go-label/</link>
      <pubDate>Mon, 06 Nov 2017 16:11:37 +0000</pubDate>
      
      <guid>https://IIHui.github.io/post/go-label/</guid>
      <description>在for,switch或者select中都可以配合标签形式的标识符使用——某一行第一个以冒号结尾的单词（因为gofmt会自动将后续代码移动至下一行）。 一个实例 package main import &amp;#34;fmt&amp;#34; func main() { LABEL1: for i := 0; i &amp;lt;= 5; i++ { for j := 0; j &amp;lt;= 5; j++ { if j == 4 { continue LABEL1 } fmt.Printf(&amp;#34;i is: %d, and j is: %d\n&amp;#34;, i, j) } } 注意事项 标签的名称是大小写敏感的，为了提升可读性，一般建议标签全部使用大写。 使用逆向的go to语句容易产生意大利苗条似的代码，所以应该避免。逆向是指先使</description>
    </item>
    
    <item>
      <title>Go 中if语句</title>
      <link>https://IIHui.github.io/post/go-if/</link>
      <pubDate>Thu, 02 Nov 2017 19:53:47 +0000</pubDate>
      
      <guid>https://IIHui.github.io/post/go-if/</guid>
      <description>if是用于测试某个条件（布尔型，又被称为逻辑型）的语句，如果该条件成立，则会执行if后由大括号括起来的代码块，否则就忽略该代码块继续执行后续的代码。Go中if语句总共有三种形式，分别是： 不带else的if； 带一个else的if语句； 带else if的if语句； 包含初始化的if语句 不带else的if 测试条件是布尔型的语句，如果该条件成立，则执行大括号中的内容。 if condition { //{ 与condition 须在同一行 //do something</description>
    </item>
    
    <item>
      <title>Go 中映射(字典）</title>
      <link>https://IIHui.github.io/post/go-map/</link>
      <pubDate>Sat, 05 Aug 2017 19:25:17 +0000</pubDate>
      
      <guid>https://IIHui.github.io/post/go-map/</guid>
      <description>映射(或称为字典)是一种数据结构，用于存储一系列无序的键值对，它是基于键来存储值。映射的键可以是任何值，只要这个值可以使用==运算符做比较即可。切片、函数以及包含切片的结构类型这些类型由于具有引用语义， 不能作为映射的键。 创建和初始化 使用make函数 //创建一个映射，键的类型是 string，值的类型是 int dict1 := make(map[string]int) dict2 := make(map[string]int,5) //长度为5 使用字面量 // 创建一个映射，键和值的类型都是 string，使用两个键值对初始</description>
    </item>
    
    <item>
      <title>Go 切片</title>
      <link>https://IIHui.github.io/post/go-slice/</link>
      <pubDate>Fri, 04 Aug 2017 15:37:58 +0000</pubDate>
      
      <guid>https://IIHui.github.io/post/go-slice/</guid>
      <description>定义 切片是围绕动态数组的概念来构建的，但是本身并非动态数组或数组指针，它通过内部指针引用底层数组，设定相关属性，将数据读写操作限定到指定区域。切片这个名字来自于——创建一个新的切片就是把底层数组切出一部分。 type slice struct{ array unsafe.Pointer // slice中指向底层数组指定位置的的指针 len int // slice 的长度 cap int //slice 容量，即最大长度，就是slice开始位置到数组的最后位置的长度 } ![c600](http://oqe76o492.bkt.</description>
    </item>
    
    <item>
      <title>Go 数组</title>
      <link>https://IIHui.github.io/post/go-array/</link>
      <pubDate>Thu, 03 Aug 2017 15:11:37 +0000</pubDate>
      
      <guid>https://IIHui.github.io/post/go-array/</guid>
      <description>定义 在Go语言里，数组是一个长度固定的数据类型，用于连续存储多个具有相同的类型的元素。数组存储的类型可以是内置类型，如整型或者字符串，也可以是某种结构类型。 ![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-08-03 下午3.13.38.png) 声明和初始化 声明 声明数组时需要指定内部存储的数据的类型，以及需要存储的元素的数量，这个数量也称为数组的长度。数组长度必须是一</description>
    </item>
    
    <item>
      <title>Go 未命名类型</title>
      <link>https://IIHui.github.io/post/go-undef-type/</link>
      <pubDate>Thu, 03 Aug 2017 11:04:39 +0000</pubDate>
      
      <guid>https://IIHui.github.io/post/go-undef-type/</guid>
      <description>未命名类型 在Go中数组、切片、字典、通道类型与具体元素类型或长度属性相关，故被称为未命名类型。具有相同声明的未命名类型被称为同一类型，在 Go 中未命名类型共有8类。 具有相同基础类型的指针 具有相同元素类型和长度的数组array 具有相同元素类型的切片slice 具有相同键和值类型的字典map 具有相同数据类型以及操作方向的通道channel 具有相同字段序列（字段名、字段类型、标签以及字段顺序）的结构体stru</description>
    </item>
    
    <item>
      <title>Go 接口</title>
      <link>https://IIHui.github.io/post/go-interface/</link>
      <pubDate>Wed, 02 Aug 2017 09:13:45 +0000</pubDate>
      
      <guid>https://IIHui.github.io/post/go-interface/</guid>
      <description>接口定义 接口代表一种调用契约，是多个方法声明的集合。在某些动态语言中接口(interface)也被称为协议(protocol)。准备交互的双方，共同遵守事先的约定规则，使得在无须知道对方身份的情况下进行协作。接口关心的是做什么，而不关心怎么做，谁来做。接口解除了类型依赖，有助于减少用户可视方法，屏蔽内部结构和实现细节。但这并不意味着可以滥用接口，因为实现接口会有运行时开销。接口最常见的使用场景是对</description>
    </item>
    
    <item>
      <title>Go 定义类型</title>
      <link>https://IIHui.github.io/post/go-struct/</link>
      <pubDate>Tue, 01 Aug 2017 09:43:30 +0000</pubDate>
      
      <guid>https://IIHui.github.io/post/go-struct/</guid>
      <description>值的类型给编译器提供两部分信息：①需要分配多少内存给这个值；②这段内存表示什么。Go语言允许用户定义类型，当用户声明一个新类型时，这个声明就给编译器提供一个框架，告知必要的内存大小和表示信息。 结构体 Go语言中声明用户定义的类型有两种方法，①最常用的方法是使用关键字struct，它可以让用户创建一个结构类型；②另一种是使用根据已有类型来定义新的类型。 结构体的定义 结构体类型通过组合一系列固定且唯一的字</description>
    </item>
    
    <item>
      <title>Go 延迟调用</title>
      <link>https://IIHui.github.io/post/go-defer/</link>
      <pubDate>Mon, 31 Jul 2017 08:55:09 +0000</pubDate>
      
      <guid>https://IIHui.github.io/post/go-defer/</guid>
      <description>关键字defer允许我们推迟到函数返回前一刻(或任意位置执行return语句之后)才执行某个语句或函数。 为什么要在返回之后才执行这些语句？因为return语句同样可以包含一些操作，而不是单纯地返回某个值，实际上此时return语句要做三件事：①如果有命名参数，将返回值赋给命名返回值;②执行defer语句或函数;③结束函数的执行。 语句defer向当前函数注册稍后执行的函数调用，这些函数被称为延迟调用</description>
    </item>
    
    <item>
      <title>Go 方法</title>
      <link>https://IIHui.github.io/post/go-method/</link>
      <pubDate>Sun, 30 Jul 2017 21:06:07 +0000</pubDate>
      
      <guid>https://IIHui.github.io/post/go-method/</guid>
      <description>方法 在Go中结构体就像是类的一种简化形式，方法就像类中的方法。方法是与对象实例绑定的特殊函数，方法和函数定义语法区别在于:方法有前置实例接收参数receiver，编译器以此确定方法所属类型。 接收者类型几乎可以是任何类型，不仅仅是结构体类型，甚至可以是函数类型。但是，有两种类型不可以有方法： 接收者不能是一个接口类型， 因为接口是一个抽象定义，但是方法需要具体实现。 接收者的类型不能是本身类型是指针的类型</description>
    </item>
    
    <item>
      <title>Go 包</title>
      <link>https://IIHui.github.io/post/go-package/</link>
      <pubDate>Sat, 29 Jul 2017 10:02:56 +0000</pubDate>
      
      <guid>https://IIHui.github.io/post/go-package/</guid>
      <description>包是结构化的一种方式,所有Go语言的程序都会组织成若干组文件，每组文件被称为一个包。每个文件都属于且仅属于一个包，一个包中可以包含许多以.go为扩展名的源文件。 包中源文件 源文件都使用UTF-8编码，每个源文件都属于包的一部分，在文件头部用package声明所属包。 每一个可独立运行的Go语言程序必定包含一个main包，在这个main包中必定包含一个入口函数main，这个函数没有参数也没有返回值。 入口</description>
    </item>
    
    <item>
      <title>Go 数据</title>
      <link>https://IIHui.github.io/post/go-data/</link>
      <pubDate>Fri, 28 Jul 2017 10:32:19 +0000</pubDate>
      
      <guid>https://IIHui.github.io/post/go-data/</guid>
      <description>数据类型 Go 中数据分为基本类型，数组，引用，字典（映射)，通道，函数，结构体，接口等等。 切片slice可实现类似动态数组的功能y := make([]int, 0, 5); append(y,7)。 将字典map类型内置，可以直接从运行层面获得性能优化。 所谓ok-idiom模式，就是在返回值中用一个名为ok的布尔值来标识操作是否成功，因为很多操作默认返回零值，所以需要额外说明。 m := make(map[string]int) m[&amp;#34;a&amp;#34;]=1 z,ok:=m[&amp;#34;b&amp;#34;] fmt.Println(z,ok) 可以为任意类型定义方法 type X int func (x * X) inc() { *x++ } 字符串</description>
    </item>
    
    <item>
      <title>Go 函数</title>
      <link>https://IIHui.github.io/post/go-func/</link>
      <pubDate>Thu, 27 Jul 2017 21:58:12 +0000</pubDate>
      
      <guid>https://IIHui.github.io/post/go-func/</guid>
      <description>Go中有3种类型的函数，第一种是普通带名字的函数，第二种是匿名函数(或者被称为lambda函数)，第三种是方法（含有接收者的特殊函数）。 特点 在Go中关键字func用于定义函数，相比于其他语言，Go中函数有以下的特点： 函数是一等公民，即可作为参数或者返回值，可以存入变量，与变量的地位是等同的。 函数可定义多个返回值，也可以对返回值命名。 Go 中函数无需前置说明，即可以先使用后定义。 Go中函数不支持同名重载</description>
    </item>
    
    <item>
      <title>Go 表达式</title>
      <link>https://IIHui.github.io/post/go-expression/</link>
      <pubDate>Wed, 26 Jul 2017 20:14:46 +0000</pubDate>
      
      <guid>https://IIHui.github.io/post/go-expression/</guid>
      <description>运算符 在Go中，一元运算符优先级最高，二元则分为5个级别，二元运算符遵循相同优先级从左到右依次计算，二元运算符从高到低的5个等级为： * / % &amp;lt;&amp;lt; &amp;gt;&amp;gt; &amp;amp; &amp;amp;^ + - | ^ == != &amp;lt; &amp;lt;= &amp;gt; &amp;gt;= &amp;amp;&amp;amp; || 二元运算符中除了移位操作外，操作数类型必须相同。如果其中一个是无显式类型声明的常量（该常量声明时，没有给出类型），那么该常量操作数会自动转型。 在Go中，位移右操作数必须是无符号整数，或可以转换的无显式类型常量（用整数字面值来定义常</description>
    </item>
    
    <item>
      <title>Go 枚举</title>
      <link>https://IIHui.github.io/post/go-iota/</link>
      <pubDate>Tue, 25 Jul 2017 09:50:43 +0000</pubDate>
      
      <guid>https://IIHui.github.io/post/go-iota/</guid>
      <description>Go中没有定义枚举变量，但是可以借助iota来生成一组自增常量值来实现枚举，iota是一个比较奇怪的存在，它只能用在const的声明中，是一个从0开始的行数索引器。 注意 首先，iota是一个行数索引器,它是按行递增的。 const ( x1 = iota //x1=0 x2 //x2=1 x3 //x3=2 x4 //x4=3 ) fmt.Println(x1, x2, x3, x4) //0,1,2,3 const ( _ = iota //iota 代表0 KB = 1 &amp;lt;&amp;lt; (10 * iota) //iota 代表1 MB //iota 代表2 GB ) fmt.Println(KB, MB, GB) //1024 1048576 1073741824 如果中断iota自增，则必须显式恢复，且后续自增按行序递增，而不是C++语言中的e</description>
    </item>
    
    <item>
      <title>Go 常量</title>
      <link>https://IIHui.github.io/post/go-const/</link>
      <pubDate>Tue, 25 Jul 2017 09:45:49 +0000</pubDate>
      
      <guid>https://IIHui.github.io/post/go-const/</guid>
      <description>常量是一种表达式，其可以保证在编译阶段计算出表达式的值，并不需要等到运行时，从而使编译器得以知晓其值。所有常量本质上都属于基本类型：布尔型，字符串或数字。 特别说明 Go中常量可以是任意基本类型，也包括具名的基本类型(例如time.Duration)。但是许多常量并不从属某一具体类型。编译器将这些从属类型待定的常量表示成某些值，这些值比基本类型的数字精度更高，且算术精度高于原生的机器精度，可以认为它们</description>
    </item>
    
    <item>
      <title>Go 变量定义</title>
      <link>https://IIHui.github.io/post/go-var/</link>
      <pubDate>Mon, 24 Jul 2017 14:11:26 +0000</pubDate>
      
      <guid>https://IIHui.github.io/post/go-var/</guid>
      <description>Go中每一个文件都以package声明开头，表明文件属于哪一个包。package声明后面是import声明，然后是不区分顺序的包级别的类型，变量、常量和函数的声明。包级别的实体名字不仅对于包含其声明的源文件可见，而且对于同一包里面的所有的源文件可见。 变量命名 以字母（这里指的是广义字母，只要能够被unicode编码即可）或下划线开始，由多个字母，数字下划线组合而成。 在Go中变量的标识符是区分大小写。</description>
    </item>
    
    <item>
      <title>Go 基本类型</title>
      <link>https://IIHui.github.io/post/go-type/</link>
      <pubDate>Mon, 24 Jul 2017 10:34:44 +0000</pubDate>
      
      <guid>https://IIHui.github.io/post/go-type/</guid>
      <description>Go语言中定义了清晰完备的预定义基本类型（共21类），使得开发跨平台应用时无须过多考虑符号和长度差异，具体如下表： ![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-12-21 下午2.36.532.jpg) 整型数据 十进制整数，使用0-9的数字表示且不以0开头。 八进制整数，以0开头，0-7的数字表示。 十六进制整数，以0X或者是0x开头0-9|A-F|a-f组成。 a,b,c:=100,0144,0x64 fmt.Println(a,b,c) //100 100</description>
    </item>
    
  </channel>
</rss>