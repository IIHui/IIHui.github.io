<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>C&#43;&#43; on Keep It Simple</title>
    <link>https://IIHui.github.io/tags/c&#43;&#43;/</link>
    <description>Recent content in C&#43;&#43; on Keep It Simple</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Sat, 05 May 2018 17:24:44 +0000</lastBuildDate>
    
	<atom:link href="https://IIHui.github.io/tags/c++/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>C&#43;&#43; 常见知识点</title>
      <link>https://IIHui.github.io/post/cpp-base/</link>
      <pubDate>Sat, 05 May 2018 17:24:44 +0000</pubDate>
      
      <guid>https://IIHui.github.io/post/cpp-base/</guid>
      <description>static的作用 对普通函数和全局变量而言static具有隐藏作用：将其修饰的全局变量和函数的作用域限定在本文件中。不加static修饰的函数和全局变量具有全局可见性。 普通局部变量而言 未初始化的static普通局部变量，编译器会将其初始化为0，因为BSS段(未初始化数据段）中所有的字节都默认为0x00。 使用static修饰的普通局部变量的生存期为整个源程序，即初始化一次便具有记忆性。但是，作用域只</description>
    </item>
    
    <item>
      <title>C&#43;&#43;智能指针</title>
      <link>https://IIHui.github.io/post/cpp-smart-pointer/</link>
      <pubDate>Sun, 13 Aug 2017 16:01:53 +0000</pubDate>
      
      <guid>https://IIHui.github.io/post/cpp-smart-pointer/</guid>
      <description>智能指针是一个类，它对普通指针进行封装，使智能指针类对象具有普通指针类型一样的操作。具体而言，复制对象时，副本和原对象都指向同一存储区域，如果通过一个副本改变其所指的值，则通过另一对象访问的值也会改变。与普通指针所不同的是，智能指针能够对内存进行进行自动管理，避免出现悬垂指针等情况。 普通指针 对于普通指针，当有多个指针指向同一个基础对象时，如果某个指针delete了该基础对象，对这个指针来说已经明确</description>
    </item>
    
    <item>
      <title>memcpy 的实现</title>
      <link>https://IIHui.github.io/post/cpp-memcpy/</link>
      <pubDate>Thu, 01 Jun 2017 11:44:24 +0000</pubDate>
      
      <guid>https://IIHui.github.io/post/cpp-memcpy/</guid>
      <description>地址重叠 void *memcpy(void *dst, const void *src, size_t n); //If copying takes place between objects that overlap, the behavior is undefined. 注意注释，对于地址重叠的情况，该函数的行为是未定义的。事实上所说的陷阱也在于此，自己动手实现memcpy时就需要考虑地址重叠的情况。 另外，标准库也提供了地址重叠时的内存拷贝函数：memmove，那么为什么还要考虑重写memcpy函数呢? 因为memmove函数的实现效率问题，该函数把源字符串拷贝到临时buffer里，然后再从临时buffer里写到目的地</description>
    </item>
    
  </channel>
</rss>