<search>
    
     <entry>
        <title>Hugo Next 主题</title>
        <url>https://iihui.github.io/post/hugo-next/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>hugo</tag><tag>next</tag>
        </tags>
        <content type="html">  从兰陵子处下载了Next主题，修改了主题下面的config.toml配置文件(配置文件的路径如下图所示)。但发现有很多地方还是需要修改才能满足自己的需求，因为对前端了解较少，故以此为记。
 代码高亮支持 插入Golang、Swift和OC代码段时发现并不能正常高亮，查资料发现是Next主题默认不支持这几种语言的语法高亮，因此需要在head.html的&amp;lt;/head&amp;gt;前添加如下代码：
&amp;lt;!--add by cxh --&amp;gt; &amp;lt;link href=&amp;#34;https://cdn.bootcss.com/highlight.js/9.12.0/styles/monokai-sublime.min.css&amp;#34; rel=&amp;#34;stylesheet&amp;#34;&amp;gt; &amp;lt;script src=&amp;#34;https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script src=&amp;#34;https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/go.min.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script src=&amp;#34;https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/swift.min.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script src=&amp;#34;https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/yaml.min.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script&amp;gt;hljs.initHighlightingOnLoad();&amp;lt;/script&amp;gt; 添加底部声明 默认情况下底部的创作共享以及微信打赏码是没有的，为了显示，首先必须修改widget下的weixin.html：
&amp;lt;div class=&amp;#34;post-nav&amp;#34;&amp;gt; &amp;lt;div style=&amp;#34;border: 1px dashed #e0e0e0; padding: 10px 10px 10px 10px; background-color: #fffeee; background-repeat: no-repeat; background-attachment: scroll; background-position: 1% 50%; -moz-background-size: auto auto; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;&amp;#34;&amp;gt; &amp;lt;div style=&amp;#34;float:left;margin-top:0px;&amp;#34;&amp;gt; &amp;lt;img src=&amp;#34;https://i.loli.net/2018/12/16/5c15cbd7f2b61.jpg&amp;#34; width=&amp;#34;128px&amp;#34; height=&amp;#34;128px&amp;#34;/&amp;gt; &amp;lt;div style=&amp;#34;text-align:center;&amp;#34;&amp;gt;谢谢支持!&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div&amp;gt; &amp;lt;p style=&amp;#34;margin-top:10px;&amp;#34;&amp;gt; 标题：{{ .Title }} &amp;lt;br /&amp;gt;作者：阿呆&amp;lt;a target=&amp;#34;_blank&amp;#34; href=&amp;#34;/&amp;#34;&amp;gt;{{ .Site.Author.name }}&amp;lt;/a&amp;gt; &amp;lt;!--&amp;lt;br /&amp;gt;关注：andy_SHui --&amp;gt; &amp;lt;br /&amp;gt;地址：{{ .Permalink }} &amp;lt;br /&amp;gt;声明：自由转载-非商用-保持署名（创作共享3.0许可证） &amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div class=&amp;#34;clear&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; 然后在single.html中添加 {{ partial &amp;quot;widgets/weixin.html&amp;quot; .}}，如下图所示：
经过上面的两步骤，就可以得到如下效果：
删除文章列表之间的横线 Next主题默认首页文章列表之间有条横线，看着觉得挺别扭的，找了一下资料，发现可以在/static/css/main.css文件中将.posts-expand .post-eof中的height设为0，就可以将其隐藏：
.posts-expand .post-eof { display: block; margin: 50px auto 10px; width: 100%; height: 0px; background: #ccc; text-align: center; } 修改文章的信息 默认文章的信息展示如下图所示： 但是我想改成下面这样：
首先在zh.yaml中做如下修改：
- id: Time translation: 创建 - id: TimeUpdated translation: 更新 - id: View translation: 字数 - id: ReadMore translation: 阅读全文 - id: ViewTime translation: 时长 - id: ReadingTime translation: &amp;#34;{{ .ReadingTime }} 分钟&amp;#34; - id: NumberOfText translation: &amp;#34;{{ .WordCount }}字&amp;#34; 然后在readtime.html中做如下修改：
&amp;lt;span&amp;gt; &amp;amp;nbsp; | &amp;amp;nbsp; &amp;lt;span class=&amp;#34;post-meta-item-icon&amp;#34;&amp;gt; &amp;lt;i class=&amp;#34;fa fa-file-word-o&amp;#34;&amp;gt;&amp;lt;/i&amp;gt; &amp;lt;/span&amp;gt; &amp;lt;span class=&amp;#34;post-meta-item-text&amp;#34;&amp;gt;{{ i18n &amp;#34;View&amp;#34; }}{{ i18n &amp;#34;Colon&amp;#34;}}&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;#34;leancloud-visitors-count&amp;#34;&amp;gt;{{ i18n &amp;#34;ReadingCount&amp;#34; .}}&amp;lt;/span&amp;gt; &amp;amp;nbsp; | &amp;amp;nbsp; &amp;lt;span class=&amp;#34;post-meta-item-icon&amp;#34;&amp;gt; &amp;lt;i class=&amp;#34;fa fa-coffee&amp;#34;&amp;gt;&amp;lt;/i&amp;gt; &amp;lt;/span&amp;gt; &amp;lt;span class=&amp;#34;post-meta-item-text&amp;#34;&amp;gt;{{ i18n &amp;#34;ViewTime&amp;#34; }}{{ i18n &amp;#34;Colon&amp;#34;}}&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;#34;leancloud-visitors-count&amp;#34;&amp;gt;{{ i18n &amp;#34;ReadingTime&amp;#34; .}}&amp;lt;/span&amp;gt; &amp;lt;/span&amp;gt; 修改左侧菜单栏的顺序 调整[[Menu.Main]]下的权重值weight就可以修改左侧菜单栏的顺序：
[[Menu.Main]] Name = &amp;#34;首页&amp;#34; Pre = &amp;#34;home&amp;#34; URL = &amp;#34;/&amp;#34; Weight = 1 [[Menu.Main]] Name = &amp;#34;标签&amp;#34; Pre = &amp;#34;tag&amp;#34; URL = &amp;#34;/tags/&amp;#34; Weight = 2 [[Menu.Main]] Name = &amp;#34;归档&amp;#34; Pre = &amp;#34;archive&amp;#34; URL = &amp;#34;/post/&amp;#34; Weight = 3 [[Menu.Main]] Name = &amp;#34;美食&amp;#34; Pre = &amp;#34;fire&amp;#34; #tint URL = &amp;#34;/categories/美食/&amp;#34; Weight = 4 [[Menu.Main]] Name = &amp;#34;后期&amp;#34; Pre = &amp;#34;edit&amp;#34; URL = &amp;#34;/categories/后期/&amp;#34; Weight = 5 [[Menu.Main]] Name = &amp;#34;旅行&amp;#34; Pre = &amp;#34;leaf&amp;#34; URL = &amp;#34;/categories/旅行/&amp;#34; Weight = 6 [[Menu.Main]] Name = &amp;#34;关于&amp;#34; Pre = &amp;#34;user&amp;#34; URL = &amp;#34;/about/&amp;#34; Weight = 7 文章展示目录 Hugo展示目录需要在文章开头添加toc = true：
--- title: Hugo next 主题问题 date: 2020-02-07 11:27:41 tags: [hugo,tool] categories: [code] toc: true --- 首页展示文章数目设置 首页展示的文章数目可以在themes/next/config.toml中设置Paginate字段：
首页摘要字数设置 首页摘要的字数设置必须在同themes同级的config.toml中设置：
summaryLength = 100 #放在同themes同级的config.toml上才有效 文章置顶设置 想要把文章置顶，需要在文章头部设置weight,如下所示：
--- title: 陈小厨作品集 date: 2020-02-03 13:28:05 tags: [美食] categories: [美食] weight: 1 toc: true --- 效果如下图：
设置从H1开始显示文章目录 不知道从什么时候开始Hugo从h2生成toc，为了设置从h1开始生成toc，需要设置全局的config.toml(即跟themes同级的config.toml)，如下所示：
[markup] [markup.tableOfContents] endLevel = 4 startLevel = 1  使用KaTex渲染公式 因为Markdown中的下划线和latex公式里的下划线冲突，导致Hugo中latex公式里的下标总是渲染不出来，如下图所示，看着很不舒服：
使用Katex来渲染公式可以达到正常的效果：
首先进到主题目录下的layouts/partials目录，新建一个名为katex.html文件：
katex.html文件的内容如下所示：
&amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;#34;en&amp;#34;&amp;gt; &amp;lt;!--CSS File --&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;#34;UTF-8&amp;#34;&amp;gt; &amp;lt;link rel=&amp;#34;stylesheet&amp;#34; href=&amp;#34;https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.css&amp;#34; integrity=&amp;#34;sha384-D&#43;9gmBxUQogRLqvARvNLmA9hS2x//eK1FhVb9PiU86gmcrBrJAQT8okdJ4LMp2uv&amp;#34; crossorigin=&amp;#34;anonymous&amp;#34;&amp;gt; &amp;lt;!--JS Fle --&amp;gt; &amp;lt;script defer src=&amp;#34;https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.js&amp;#34; integrity=&amp;#34;sha384-483A6DwYfKeDa0Q52fJmxFXkcPCFfnXMoXblOkJ4JcA8zATN6Tm78UNL72AKk&#43;0O&amp;#34; crossorigin=&amp;#34;anonymous&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; 然后在layouts/partials目录下的header.html下添加如下代码：
{{ if .Params.katex}}{{ partial &amp;#34;katex.html&amp;#34; . }}{{ end }} 最后在需要渲染公式的文章头部，添加katex: true：
--- title: 线性表 date: 2018-04-25T20:52:42&#43;08:00 tags: [算法] categories: [算法] toc: true katex: true --- 参考资料
</content>
    </entry>
    
     <entry>
        <title>Mach-O 文件</title>
        <url>https://iihui.github.io/post/ios-macho/</url>
        <categories>
          <category>iOS</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html">  Mach-O为Mach Object文件格式的缩写，它是一种用于可执行文件、目标代码、动态库的文件格式。
 文件类型 常见的MachO文件有下面这些，可以通过file&#43;文件路径来查看文件的类型信息：
 目标文件.o 库文件.a | .dylib | xxx.framework/xxx 可执行文件 符号表文件.dysm  通用二进制 通用二进制文件是一种能够同时兼容多种架构的二进制文件，常用的架构有arm64,arm64e,armv7,armv7s，除了能够兼容多种架构，还有以下特点：
  能够为不同的架构提供最理想的性能。
  因为要存储多种架构的代码，通用二进制程序包要比单一架构的二进制程序包大。
  因为多种架构只是代码不同，但资源相同，通用二进制的资源只有一份，所以并不会比单一架构的程序包大小多一倍。
  运行时也只执行对应架构的代码，不会占用多余的内存。
  lipo lipo可以用来合并真机包和模拟器包：
lipo -create [真机编译路径/xxx.framework/xxx] [模拟器编译路径/xxx.framework/xxx] -output [合并后输出的文件路径] 也可以用来从通用二进制文件中拆分出不同架构：
//从通用二进制文件拆分出不同的架构 lipo [通用二进制文件路径] -thin [要拆的架构] -output [拆出的二进制输出的路径] MachO的文件结构 MachO文件分为Header、Load、commands、Data三部分，如下图所示：
切换cocoapods版本 sudo gem uninstall cocoapods sudo gem uninstall cocoapods-art sudo gem install cocoapods -v 1.5.3 sudo gem install cocoapods-art -v 1.0.3 参考资料
</content>
    </entry>
    
     <entry>
        <title>创建私有库</title>
        <url>https://iihui.github.io/post/ios-private-pods/</url>
        <categories>
          <category>ios</category>
        </categories>
        <tags>
          <tag>ios</tag><tag>pod</tag>
        </tags>
        <content type="html"> 创建远程私有索引库 首先在github上创建一个私有库，用来存放私有狂减的详细描述信息
创建本地的私有索引库 查看本地已存在的索引库 pod repo 添加远程库到本地 pod repo add MyProjectSpec https://git.oschina.net/funky_hs/myprojectspec.git 添加之后，可以再使用pod repo查看本地已存在的索引库。
创建基础组件仓库 创建本地测试工程 pod lib create LC10_01_WCDB.Swift  参考资料
参考资料
</content>
    </entry>
    
     <entry>
        <title>pod 问题</title>
        <url>https://iihui.github.io/post/ios-pods-question/</url>
        <categories>
          <category>iOS</category><category>pod</category>
        </categories>
        <tags>
          <tag>iOS</tag><tag>pod</tag>
        </tags>
        <content type="html"> </content>
    </entry>
    
     <entry>
        <title>验证码绑定界面</title>
        <url>https://iihui.github.io/post/ios-login/</url>
        <categories>
          <category>iOS</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html">  验证码绑定，包括个人账户，和虚拟账户。之前写的验证码绑定界面扩展性太差，这次决定尝试使用tableView实现验证码绑定界面，主要是为了增加可扩展性，便于当需要增加新的验证信息时，可以不大动原界面。这篇文章是对应的ViewController的代码和最终的界面。
 VC代码 import UIKit enum SMSLoginType { case Personal case Virtual } class NewSMSViewController: UIViewController, UITableViewDelegate, UITableViewDataSource { @IBOutlet weak var personalAccountBtn: UIButton! @IBOutlet weak var personalAccountUnderline: UILabel! @IBOutlet weak var virtualAccountBtn: UIButton! @IBOutlet weak var virtualAccountUnderline: UILabel! @IBOutlet weak var tableView: UITableView! private let defaultColor = UIColor(hex: &amp;#34;#4B5169&amp;#34;) private let hiddenColor = UIColor(hex: &amp;#34;#9294A6&amp;#34;) private var imageAndText: [(image: String, tip: String)] = [(&amp;#34;virtualid&amp;#34;, &amp;#34;请输入虚拟账号ID&amp;#34;), (&amp;#34;no&amp;#34;, &amp;#34;请输入一事通ID或员工编号&amp;#34;), (&amp;#34;idcard_small&amp;#34;, &amp;#34;请输入身份证后六位&amp;#34;)] private var _loginType: SMSLoginType = .Personal private var loginType: SMSLoginType { get { return _loginType } set { switch newValue { case .Personal: self.personalAccountUnderline.isHidden = false self.virtualAccountUnderline.isHidden = true self.personalAccountBtn.setTitleColor(self.defaultColor, for: .normal) self.virtualAccountBtn.setTitleColor(self.hiddenColor, for: .normal) case .Virtual: self.personalAccountUnderline.isHidden = true self.virtualAccountUnderline.isHidden = false self.personalAccountBtn.setTitleColor(self.hiddenColor, for: .normal) self.virtualAccountBtn.setTitleColor(self.defaultColor, for: .normal) } _loginType = newValue self.tableView.reloadData() } } override func viewDidLoad() { super.viewDidLoad() self.tableView.delegate = self self.tableView.dataSource = self self.tableView.tableFooterView = UIView() self.tableView.separatorColor = UIColor.gray self.tableView.separatorInset = UIEdgeInsets(top: 0, left: -10, bottom: 0, right: 0) } @IBAction func back(_ sender: Any) { self.navigationController?.popViewController(animated: true) } @IBAction func showPersonalAccountUI(_ sender: Any) { self.loginType = .Personal } @IBAction func showVirtualAccountUI(_ sender: Any) { self.loginType = .Virtual } func numberOfSections(in tableView: UITableView) -&amp;gt; Int { return 3 } func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -&amp;gt; CGFloat { return 48 } func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&amp;gt; Int { switch section { case 0: switch _loginType { case .Personal: return 2 case .Virtual: return 3 } default: return 1 } } func tableView(_ tableView: UITableView, willDisplay cell: UITableViewCell, forRowAt indexPath: IndexPath) { cell.selectionStyle = .none } func tableView(_ tableView: UITableView, heightForHeaderInSection section: Int) -&amp;gt; CGFloat { if section == 2 { return 60 } return 0 } func tableView(_ tableView: UITableView, heightForFooterInSection section: Int) -&amp;gt; CGFloat { switch section { case 0, 1: return 0.5 default: return 0 } } func tableView(_ tableView: UITableView, viewForFooterInSection section: Int) -&amp;gt; UIView? { let headerView = UIView() headerView.backgroundColor = UIColor.gray return headerView } func tableView(_ tableView: UITableView, viewForHeaderInSection section: Int) -&amp;gt; UIView? { let footerView = UIView() footerView.backgroundColor = UIColor.clear return footerView } func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&amp;gt; UITableViewCell { switch indexPath.section { case 0: let cell = tableView.dequeueReusableCell(withIdentifier: &amp;#34;SMSNormalCell&amp;#34;, for: indexPath) if let norCell = cell as? SMSNormalCell { var index = indexPath.row switch loginType { case .Personal: index = index &#43; 1 default: break } norCell.iconImageView.image = UIImage(named: imageAndText[index].image) norCell.textField.placeholder = imageAndText[index].tip norCell.textField.clearButtonMode = .whileEditing } return cell case 1: let cell = tableView.dequeueReusableCell(withIdentifier: &amp;#34;SMSCodeCell&amp;#34;, for: indexPath) if let codeCell = cell as? SMSCodeCell { codeCell.iconImageView.image = UIImage(named: &amp;#34;authcode&amp;#34;) codeCell.textField.placeholder = &amp;#34;请输入手机验证码&amp;#34; codeCell.textField.clearButtonMode = .whileEditing codeCell.codeBtn.layer.cornerRadius = 18.0 codeCell.codeBtn.layer.borderColor = UIColor.black.cgColor codeCell.codeBtn.layer.borderWidth = 1.0 } cell.separatorInset = UIEdgeInsets(top: 0, left: 0, bottom: 12, right: 0) return cell default: let cell = tableView.dequeueReusableCell(withIdentifier: &amp;#34;SMSBindCell&amp;#34;, for: indexPath) return cell } } } 绑定界面 </content>
    </entry>
    
     <entry>
        <title>AutoLayout</title>
        <url>https://iihui.github.io/post/ios-autolayout/</url>
        <categories>
          <category>iOS</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html">  苹果公司推出的AutoLayout是一个基于约束，动态计算视图大小和位置的库。它以布局引擎系统Layout Engine为核心，采用了Cassowary布局算法，在简化布局思路的同时，还保证了布局的高效性。布局算法Cassowary能够有效解析线性等式系统和线性不等式系统，用来表示用户界面中那些相等关系和不等关系，通过设定约束来表示一个视图相对于另一个视图的位置。
 原理 在Layout Engine中，每当约束发生变化，会重新计算布局，获取到布局后会调用superview.setNeedLayout()，然后触发Deffered Layout Pass做容错处理，然后Layout Engine会从上到下调用layoutSubviews()来确定各子视图的位置，算出来后将子视图的frame从Layout Engine中拷贝出来，然后进行绘制、渲染。
几个更新方法的区别   setNeedsLayout 告知页面需要更新，但是不会立刻开始更新，也就是先做一个标记。
  layoutIfNeeded 如果有需要刷新的标记，立即调用layoutSubViews进行布局；如果没有标记，不会调用layoutSubbViews。如果希望立即刷新frame，要先调用setNeedsLayout，把标记为需要布局，然后马上调用layoutIfNeeded实现布局。
  layoutSubviews 对subviews进行布局，不能主动调用，需要的时候在子类中重写，系统会在合适的时候调用。
  setNeedsUpdateConstraints 告知需要更新约束，但是不会立刻开始，也就是先做一个标记，调用updateConstraintsIfNeeded会查看该标记。
  updateConstraintsIfNeeded 告知立刻更新约束，如果有需要刷新约束的标记，则立即更新，否则不更新约束。
  updateConstraints 系统更新约束？？？。
  系统调layoutSubviews时机   使用init初始化不会触发layoutSubviews，但是使用initWithFrame进行初始化且rect不为zero时会调用layoutSubviews。
  调用addSubview的时候会触发系统调用layoutSubviews。
  当view的frame发生改变时触发layoutSubviews调用。
  滚动一个UIScrollView会触发layoutSubviews调用。
  旋转屏幕会触发父UIView上的layoutSubviews事件。
  改变一个UIView大小的时候也会调用父UIView上的layoutSubviews事件。
  固有内容大小 Intrinsic content size 就是固有内容大小，对应的是intrinsicContentSize计算属性。实际上，可以通过继承可以重写UIView的固有内容大小，达到定制的目的：
class TestView: UIView { override var intrinsicContentSize: CGSize { return CGSize(width: 300, height: 800) } } UITableView高度计算 自动计算 当布局满足self-satisfied（设置约束时，只有一个不确定时，例如高度）时，系统会自动计算高度，缺点时慢，因为没有缓存高度，每次都要计算一次。
//首先在viewDidLoad中cell预估高度,设一个接近cell高度的值 self.tableView.estimatedRowHeight = 100; //然后在设置返回automaticDimension override func tableView(_ tableView:UITableView, heightForRawAt: indexPath IndexPath) -&amp;gt; CGFloat { return UITableView.automaticDimension }  摘抄自这里
</content>
    </entry>
    
     <entry>
        <title>不常见的关键字</title>
        <url>https://iihui.github.io/post/ios-keywords/</url>
        <categories>
          <category>iOS</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html">  使用Swift写代码时，经常会遇到一些不常见的关键词或者常用关键词的特殊使用场景，因为比较少使用，通常这些不常见的关键词或者特殊场景很容易忘记，这篇文章用于记录这些情况。
 便利构造函数 convenience用于构造函数中，称之为便利构造函数。通常在对一些系统控件扩展分类的时候用convenience关键字，比如：
extension UIColor { convenience init(hex: String) { var cString: String = hex.trimmingCharacters(in: .whitespacesAndNewlines).uppercased() if (cString.hasPrefix(&amp;#34;#&amp;#34;)) { cString.remove(at: cString.startIndex) } assert(cString.count == 6, &amp;#34;无效的hex值&amp;#34;) var rgbValue: UInt64 = 0 Scanner(string: cString).scanHexInt64(&amp;amp;rgbValue) self.init( red: CGFloat((rgbValue &amp;amp; 0xFF0000) &amp;gt;&amp;gt; 16) / 255.0, green: CGFloat((rgbValue &amp;amp; 0x00FF00) &amp;gt;&amp;gt; 8) / 255.0, blue: CGFloat(rgbValue &amp;amp; 0x0000FF) / 255.0, alpha: CGFloat(1.0) ) } } 原因是Swift为了保证安全，有个严格的初始化方法——Swift中不加修饰的init方法需要在方法中保证所有的非Optional的实例变量被赋值初始化。此时，如果想写一个自定义的构造函数，要把所有的非Optional的实例变量被赋值初始化，就变得很麻烦。此时便利构造函数就发挥作用了，它通常用在对系统的类进行构造函数的扩充时使用。
  必须调用在convenience中修饰的构造函数中，必须调用本类的构造函数，不能调用父类的构造函数。
  其本身不负责属性的创建和初始化工作。
  不能被重写。
  </content>
    </entry>
    
     <entry>
        <title>Keyboard Maestro 使用</title>
        <url>https://iihui.github.io/post/tool-keyboard-maestro/</url>
        <categories>
          <category>tool</category>
        </categories>
        <tags>
          <tag>tool</tag>
        </tags>
        <content type="html">  Keyboard Maestro是一款神奇的软件，在我心里它和Alfred同样重要，是装机必备软件。使用它可以省去安装很多软件，这篇文章记录在平常工作中使用它的一些特性或技巧，以供后续查阅。
 快捷输入 粘贴 键盘 打开应用 开启和关闭wifi 窗口 左半屏 右半屏 最大化 全屏 去格式粘贴 复制当前行 焦点 切换到屏幕一 切换到屏幕二  </content>
    </entry>
    
     <entry>
        <title>git 使用</title>
        <url>https://iihui.github.io/post/tool-git-usage/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>git</tag>
        </tags>
        <content type="html"> 清理文件 本地.git文件太大，可以使用git gc命令清理不必要的文件并优化本地存储库，其中gc是garbage collection的缩写:
git gc [--aggressive] [--auto] [--quiet] [--prune=&amp;lt;date&amp;gt; | --no-prune] [--force] [--keep-largest-pack] 更多参数讲解
大小写敏感 默认情况下git追踪的项目对文件名大小写是不敏感的，但是git提供了命令可以使得当前项目或者所有项目都能区分文件名的大小写。
当前项目 打开终端，利用cd命令，将目录切换到git仓库下，输入如下命令使其对文件名大小写敏感：
git config core.ignorecase false 所有项目 如果想要所有项目都对文件名大小写敏感，就需要进行全局设置。执行如下命令，改变git的全局设置即可：
git config --global core.ignorecase false </content>
    </entry>
    
     <entry>
        <title>pcm No such file or directory</title>
        <url>https://iihui.github.io/post/ios-pcm-warnning/</url>
        <categories>
          <category>iOS</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html">  在封装静态framework时，在本机上没有报任何警告，在其他机器上却报warning: ***/Library/Developer/Xcode/DerivedData/ModuleCache.noindex/2MSIKR0H4Y5WQ/Foundation-A3SOD99KJ0S9.pcm: No such file or directory警告。这篇文章就是解决这个警告问题，主要是改变工程的build setting有三个地方需要修改，暂且归为三步。
 第一步 首先在Build Settings中将Enable Bitcode设置为No，如下图所示：
第二步 然后在Build Settings中将Debug Information Format下的Debug设置为DWARF，如下图所示： 第三步 最后将Precompile Prefix Header设置为NO，如下图所示：  下面是国密封装设置
</content>
    </entry>
    
     <entry>
        <title>强制浅色模式</title>
        <url>https://iihui.github.io/post/ios-light-style/</url>
        <categories>
          <category>iOS</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html">  iOS 13之后，一旦使用了系统的组件，如果用户开启了深色模式，则这些组件的颜色会随着发生变化，而此时某些使用了自定义颜色的组件对应的颜色不会改变，如此将会非常难看。一个简单的方式是强制App为浅色模式，使得系统开启了深色模式后，App还是之前的浅色模式。
 强制浅色模式，只要在info.plist中将User Interface Style设置为Light即可，如下图所示：
 </content>
    </entry>
    
     <entry>
        <title>iOS tips</title>
        <url>https://iihui.github.io/post/ios-tips/</url>
        <categories>
          <category>iOS</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html"> 类与结构体 共同点   定义属性用于存储值
  定义方法用于提供方法
  定义下标操作使得可以通过下标语法来访问实例所包含的值
  定义构造器用于生成初始值
  通过扩展协议来增加默认实现的功能
  实现协议来提供某种标准功能
  类多一点   允许一个类继承另一个类的特镇
  类型转换允许在运行时检查和解释一个类实例的类型
  析构器允许一个类实例释放任何其被分配的资源
  引用计数允许对一个类的多次引用
  区别   struct是值类型，class是引用类型。
  struct有一个自动生成的成员逐一构造器，用于初始化新结构体实例中成员的属性，而class没有。
  struct中修改self或其属性的方法必须将该实例方法标注为 mutating，而class并不需要。
  struct不可以继承，class可以继承。
  struct赋值是值拷贝，拷贝的是内容；class是引用拷贝，拷贝的是指针。
  struct是自动线程安全的；而class不是。
  struct存储在stack中，class存储在heap中，struct更快。
  元组 Swift支持把多个值组合成一个复合值，称为元组。元组内的值可以是任意类型，因此各个值的类型可以都不相同，例如：
let size = (width: 10, height: 10) print(&amp;#34;\(size.0)&amp;#34;) print(&amp;#34;\(size.width)&amp;#34;) //也可以不对元素命名 let size = (10, 10) 在函数需要返回多个值时，元组非常有用，但它并不适合复杂的数据表达（此时建立mode会更好）。在使用元组时尽量使用命名，要不然过段时间可能忘记元组中各个元素的含义，并且尽量只在临时需要时使用。
元组在交换两个值的时候非常有用，如下的代码便可以交换两个变量的值：
(a,b) = (b,a) 协议合成 假如一个函数希望某个参数同时满足ProtocolA和ProtocolB，可以采用ProtocolA &amp;amp; ProtocolB这样的格式进行组合，称为协议合成（protocol composition）。
func testComposition(protocols: ProtocolA &amp;amp; ProtocolB) { //code } 可选协议 Swift的protocol本身不允许可选项，要求所有方法都是必须实现的。但是，由于Swift和OC可以混编，为了方便和OC打交道，Swift支持在protocol中使用optional关键字作为前缀来定义可选要求，且协议可选要求都必须带上objc属性。
@objc protocol CounterDataSource { @objc optional func incrementForCount(count: Int) -&amp;gt; Int @objc optional var fixedIncrement: Int { get } } 但是标记@objc特性的协议只能被继承NSObject类类或者@objc类遵循，其他类以及结构体和枚举均不能遵循这种协议，这对于Swift protocol是一个很大的限制。
由于protocol支持可扩展，那么可以声明一个protocol之后再用extension的方式给出部分方法默认的实现，这样这些方法在实际的类中就是可选实现了。
protocol CounterDataSource { func incrementForCount(count: Int) -&amp;gt; Int var fixedIncrement: Int { get } } extension CounterDataSource { func incrementForCount(count: Int) -&amp;gt; Int { if count == 0 { return 0 } else if count &amp;lt; 0 { return 1 } else { return -1 } } } class Counter: CounterDataSource { var fixedIncrement: Int = 0 } 协议扩展 先来看下面这段代码：
protocol A2 { func method1() } extension A2 { func method1() { return print(&amp;#34;hi&amp;#34;) } func method2() { return print(&amp;#34;hi&amp;#34;) } } struct B2: A2 { func method1() { return print(&amp;#34;hello&amp;#34;) } func method2() { return print(&amp;#34;hello&amp;#34;) } } let b2 = B2() b2.method1() b2.method2() 打印的结果如下：
hello hello 结果看起来在医疗意料之中，但如果稍作修改：
let a2 = b2 as A2 a2.method1() a2.method2() 此时的结果是：
hello hi 对于method1，因为它在protocol中被定义了，因此对于一个被声明为遵循协议的类型实例来说，可以确定实例必须实现了method1，可以放心大胆地用动态派发的方式使用最终的实现（不论它是在协议扩展中进行了定义，还是在协议扩展中默认实现）。但是，对于method2来说，只是在接口扩展中进行了定义，没有任何规定它必须在最终的类型中被实现。在使用时，因为a2只有一个符合A2接口的实例，编译器对method2唯一能确定的是知识在接口扩展中有一个默认实现，因此在调用时，无法确定安全，也就不会去进行动态派发，而是转而编译期间就确定的默认实现。
随机数 我们常常可能使用下面这种方式来获取随机数，比如生产100以内的随机数：
let randomNum: Int = arc4random() % 100 此时编译器会提示error，这是因为arc4random()返回UInt32，而randomNum是Int，所以需要做类型转换。如果不假思索，就可能直接写出下面的代码：
let randomNum: Int = Int(arc4random()) % 100 这是因为Int在32位机器上（iPhone5及以下）相当于Int32，而在64位机器上相当于Int64，表现上与OC中的NSInteger一致，而arc4random()始终返回UInt32，所以在32位机器上可能会越界崩溃了，所以应当先取余之后再类型转换：
let randomNum: Int = Int(arc4random() % 100) 可变参数函数 如果想要一个可变参数的函数只需要在声明参数时在类型后面加上 ... 就可以了：
func sum(input: Int...) -&amp;gt; Int { return input.reduce(0, combine: &#43;) } print(sum(1,2,3,4,5)) 区间运算符 Swift提供了几种简单的能够表达一个区间的值的区间运算符，包括全闭区间，半开半闭区间，单侧区间，如下所示：
let data = [1, 2, 3, 4, 5] //闭区间运算符，表示截取下标0～2的数组元素 data[0...2] //半开区间运算符，表示截取下标0～1的数组元素 data[0..&amp;lt;2] //单侧区间运算符，表示截取开始到下标2的数组元素 data[...2] //单侧区间运算符，表示截取从下标2到结束的数组元素 data[2...] 还可以通过...和..&amp;lt;来连接两个字符串：
//判断是否包含大写字母，并打印 let str = &amp;#34;Hello&amp;#34; let test = &amp;#34;A&amp;#34;...&amp;#34;Z&amp;#34; for c in str { if test.contains(String(c)) { print(&amp;#34;\(c)是大写字母&amp;#34;) } } &#43;&#43;和&amp;ndash; 不管是前置还是后置，Swift均不支持&#43;&#43;和--这种运算符。
闭包 闭包是自包含的函数代码块，可以在代码中被传递和使用。Swift中的闭包与C和OC中的代码块blocks比较相似。Swift的闭包表达式拥有更简洁的风格，并鼓励在常见的场景中进行语法优化，主要优化有如下几个方面：
  利用上下文推断参数和返回值类型
  隐式返回单表达式闭包，即单表达式闭包可以省略return关键字
  参数名称缩写
  尾随闭包语法
  闭包表达式语法有如下的一般形式：
{ (parameters) -&amp;gt; returnType in statements } 尾随闭包 当函数最后的一个参数是闭包时，可以使用尾随闭包来增强函数的可读性。在使用尾随闭包时，可以不用写出它的参数标签：
func test(closure: () -&amp;gt; Void) { ... } //不使用尾随闭包 test(closure: { ... }) //使用尾随闭包 test() { ... } 逃逸闭包 当一个闭包作为参数传递到一个函数中，但是这个闭包在函数返回之后还可以被使用，称该闭包从函数中逃逸。
var completions: [() -&amp;gt; Void] = [] func testClosure(completion: () -&amp;gt; Void) { completions.append(completion) } 此时编译器会报错，提示你这是一个逃逸闭包，我们可以在参数名之前标注 @escaping，用来指明这个闭包是允许“逃逸”出这个函数的：
var completions: [() -&amp;gt; Void] = [] func testEscapingClosure(completion: @escaping () -&amp;gt; Void) { completions.append(completion) } 将一个闭包标记为@escaping意味着必须在闭包中显式地引用self，而非逃逸闭包则不需要。这个self提醒可能会一不小心就捕获了self，要注意循环引用。
自动闭包 自动闭包是一种自动创建的闭包，用于包装传递给函数作为参数的表达式。这种闭包不接受任何参数，让你能够省略闭包的花括号，用一个普通的表达式来替代显式的闭包。并且自动闭包可以能够延迟求值，因为直到调用到这个闭包，代码段才会被执行。
//未使用自动闭包，需要显示用花括号说明这个参数是一个闭包 func test(closure: () -&amp;gt; Bool) { } test(closure: { 1 &amp;lt; 2 } ) //使用自动闭包，只需要传递表达式 func test(closure: @autoclosure () -&amp;gt; String) { } test(customer: 1 &amp;lt; 2) 递归枚举 可能有这样一个场景，定义一个Food的枚举，包含了一些食物，同时还支持基于这些食物可以两两混合成新食物：
enum Food { case beef case potato case mix(Food, Food) } 此时编译器会提示Recursive enum &#39;Food&#39; is not marked &#39;indirect&#39;，原因是因为枚举成员中出现了递归调用。因此，需要在枚举成员前加上indirect来表示成员可递归。
//标记整个枚举是递归枚举 indirect enum Food { case beef case potato case mix(Food, Food) } //仅标记存在递归的枚举成员 enum Food { case beef case potato indirect case mix(Food, Food) } 更推荐第二种写法，因为使用递归枚举时，编译器会插入一个间接层。仅标记枚举成员，能够减少不必要的消耗。
属性 存储属性 一个存储属性就是存储在特定类或结构体实例里的一个常量或变量。存储属性可以是变量存储属性（用关键字var定义），也可以是常量存储属性（用关键字 let定义）。
struct Person { var name: String var height: CGFloat } 还可以通过Lazy来标示该属性位延迟存储属性，类似于OC常说的懒加载：
lazy var fileName: String = &amp;#34;data.txt&amp;#34; 如果一个被标志为lazy的属性在没有初始化时就同时被多个线程访问，则无法保证该属性只会初始化一次，即它是非线性安全的。
计算属性 除存储属性外，类，结构体和枚举定义计算属性。计算属性不直接存储值，而是提供一个getter和一个可选setter，来间接获取和设置其它属性和变量的值。
struct Rect { var origin = CGPoint.zero var size = CGSize.zero var center: CGPoint { get { let centerX = origin.x &#43; (size.width / 2) let centerY = origin.y &#43; (size.height / 2) return Point(x: centerX, y: centerY) } set { origin.x = newValue.x - (size.width / 2) origin.y = newValue.y - (size.height / 2) } } } 如果只希望可读而不可写时，setter方法不提供即可，可以简写为：
var center: CGPoint { let centerX = origin.x &#43; (size.width / 2) let centerY = origin.y &#43; (size.height / 2) return Point(x: centerX, y: centerY) } 观察器 Swift提供了非常方便的观察属性变化的方法，每次属性被设置值的时候都会调用属性观察器，即使新值和当前值相同的时候也不例外：
var origin: CGPoint { willSet { print(&amp;#34;\(newValue)&amp;#34;) } didSet { print(&amp;#34;\(oldValue)&amp;#34;) } } 调用时序 let b = B() b.number = 0 //输出 //get //willSet //set //didSet 首先出现get是因为实现didSet，didSet中用到oldValue，而这个值需要在整个set动作之前进行获取并存储待用，否则将无法确保正确性。如果我们不实现didSet的话，这次get操作也将不存在。？？？
is和as is is在功能上相当于OC的isKindOfClass，可以检查一个对象是否属于某类型或其子类型。is和原来的区别主要在于两点，首先它不仅可以用于class类型上，也可以用在struct或enum类型进行判断。
class ClassA { } class ClassB: ClassA { } let obj: AnyObject = ClassB() if (obj is ClassA) { print(&amp;#34;属于 ClassA&amp;#34;) } if (obj is ClassB) { print(&amp;#34;属于 ClassB&amp;#34;) } as 某类型的一个常量或变量可能在幕后实际上属于一个子类。当确定是这种情况时，可以尝试向下转到它的子类型，用类型转换操作符（as？ 或as！）
class Media {} class Movie: Media {} class Song: Media {} for item in medias { if let movie = item as? Movie { print(&amp;#34;It&amp;#39;s Movie&amp;#34;) } else if let song = item as? Song { print(&amp;#34;It&amp;#39;s Song&amp;#34;) } } 扩展下标 Swift支持通过Extension为已有类型添加新下标，例如：
extension Int { subscript(digitIndex: Int) -&amp;gt; Int { var decimalBase = 1 for _ in 0..&amp;lt;digitIndex { decimalBase *= 10 } return (self / decimalBase) % 10 } } 746381295[0] //返回5 746381295[1] //返回9 746381295[2] //返回2 746381295[8] //返回7 mutating 结构体和枚举类型中修改self或其属性的方法必须将该实例方法标注为mutating，否则无法在方法里改变自己的变量：
struct MyCar { var color = UIColor.blue mutating func changeColor() { color = UIColor.red } } 由于Swift的protocol不仅可以被class类型实现，也适用于struct和enum，因此在写给别人用的接口时需要多考虑是否适用mutating来修饰方法。
KVO 在Swift中也可以使用KVO，但仅限于NSObject的子类。因为，KVO是基于KVC以及动态派发技术实现的，而这些都是运行时的概念。Swift为了效率，默认禁用了动态派发，因此想要Swift来实现KVO，需要将观测对象标记为@objc dynamic
lazy 关键词lazy可以用来标示属性的延迟加载，它还可以配合像map或filter这类接受闭包并进行运行的方法一起，让整个行为变为延迟进行，在某些情况下这么做也对性能会有不小的帮助。
例如，直接使用map时：
let data = 1...3 let result = data.map { (i: Int) -&amp;gt; Int in print(&amp;#34;正在处理 \(i)&amp;#34;) return i * 2 } print(&amp;#34;准备访问结果&amp;#34;) for i in result { print(&amp;#34;操作后结果为 \(i)&amp;#34;) } print(&amp;#34;操作完毕&amp;#34;) 这段代码的输出为：
//正在处理1 //正在处理2 //正在处理3 //准备访问结果 //操作后结果为2 //操作后结果为4 //操作后结果为6 //操作完毕 而如果先进行一次lazy操作的话，就能得到延时运行版本的容器：
let data = 1...3 let result = data.lazy.map { (i: Int) -&amp;gt; Int in print(&amp;#34;正在处理 \(i)&amp;#34;) return i * 2 } print(&amp;#34;准备访问结果&amp;#34;) for i in result { print(&amp;#34;操作后结果为 \(i)&amp;#34;) } print(&amp;#34;操作完毕&amp;#34;) 此时的运行结果为：
//准备访问结果 //正在处理1 //操作后结果为2 //正在处理2 //操作后结果为4 //正在处理3 //操作后结果为6 //操作完毕 Log与编译符号 在调试或者记日志的时候，有时需要将当前文件的名字和那些必要的信息作为参数一起打印出来，Swift中有几个很有用的编译符号，用来处理类似这样的需求，它们分别是：
  #file 包含这个符号的文件的路径，类型为string。
  #line 符号出现除的行号，类型为Int。
  #column 符号出现的列，类型为Int。
  #function 包含这个符号的方法名字，类型为String。
  Optional Map 我们常常会对数组使用map方法，这个方法能对数组中的所有元素应用某个规则，然后返回一个新的数组。
例如希望将数组中的所有数字乘2:
let nums = [1, 2, 3] let result = nums.map{ $0 * 2 } print(&amp;#34;\(result)&amp;#34;) //输出：[2,4,6] 但如果改成对某个Int？乘2呢？期望如果这个Int？有值的话，就取出值进行乘2的操作；如果是nil的话就直接将nil赋给结果。
let num: Int? = 3 //letnum:Int?=nil var result: Int? if let num = num { result = num } print(&amp;#34;\(String(describing: result))&amp;#34;) //num=3时，打印Optional(6) //num=nil时，打印nil 如果使用Optional Map，刚才的例子就可以改为：
let num: Int? = 3 //letnum:Int?=nil let result = num.map { $0 * 2 } print(&amp;#34;\(String(describing: result))&amp;#34;) //num=3时，打印Optional(6) //num=nil时，打印nil map与flatmap 都会对数组中的每一个元素调用一次闭包函数，并返回该元素所映射的值，最终返回一个新数组。但flatmap更进一步，多做了一些事情：
 返回的结果中会去除nil，并且会解包Optional类型。 会将$N$维数组变成$1$维数组返回。   摘抄自这里
</content>
    </entry>
    
     <entry>
        <title>AES 实现</title>
        <url>https://iihui.github.io/post/ios-aes/</url>
        <categories>
          <category>iOS</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html">  高级加密标准(AES,Advanced Encryption Standard)是最常见的对称加密算法（对称加密是指加密和解密使用相同的密钥）。密钥是AES算法实现加密和解密的根本，对称加密算法之所以对称，是因为这类算法对明文的加密和解密需要同一个密钥。AES支持128，192，256位3种长度的密钥，其中AES256安全性最高，AES128性能最好。
 加密流程 算法实现 import CommonCrypto import Foundation //AES-128加密参考自https://stackoverflow.com/questions/37680361/aes-encryption-in-swift class AES { private let key: Data private let iv: Data init?(key: String, iv: String) { guard key.count == kCCKeySizeAES128 || key.count == kCCKeySizeAES256, let keyData = key.data(using: .utf8) else { DPrint(&amp;#34;密钥长度不对&amp;#34;) return nil } guard iv.count == kCCBlockSizeAES128, let ivData = iv.data(using: .utf8) else { DPrint(&amp;#34;初始化向量出错&amp;#34;) return nil } self.key = keyData self.iv = ivData } func encrypt(string: String) -&amp;gt; Data? { return self.crypt(data: string.data(using: .utf8), option: CCOperation(kCCEncrypt)) } func decrypt(data: Data?) -&amp;gt; String? { guard let decryptedData = crypt(data: data, option: CCOperation(kCCDecrypt)) else { return nil } return String(bytes: decryptedData, encoding: .utf8) } func crypt(data: Data?, option: CCOperation) -&amp;gt; Data? { guard let data = data else { return nil } let cryptLength = [UInt8](repeating: 0, count: data.count &#43; kCCBlockSizeAES128).count var cryptData = Data(count: cryptLength) let keyLength = [UInt8](repeating: 0, count: kCCBlockSizeAES128).count let options = CCOptions(kCCOptionPKCS7Padding) //kCCOptionPKCS7Padding var bytesLength = Int(0) let status = cryptData.withUnsafeMutableBytes { cryptBytes in data.withUnsafeBytes { dataBytes in iv.withUnsafeBytes { ivBytes in key.withUnsafeBytes { keyBytes in CCCrypt(option, CCAlgorithm(kCCAlgorithmAES), options, keyBytes, keyLength, ivBytes, dataBytes, data.count, cryptBytes, cryptLength, &amp;amp;bytesLength) } } } } guard UInt32(status) == UInt32(kCCSuccess) else { DPrint(&amp;#34;加密出错，错误状态为：\(status)&amp;#34;) return nil } cryptData.removeSubrange(bytesLength ..&amp;lt; cryptData.count) return cryptData } } func DPrint&amp;lt;T&amp;gt;(_ message: T, file: String = #file, method: String = #function, line: Int = #line) { #if DEBUG print(&amp;#34;\((file as NSString).lastPathComponent)[\(line)], \(method): \(message)&amp;#34;) #endif } 参考资料 参考资料
</content>
    </entry>
    
     <entry>
        <title>CLion 添加Google test</title>
        <url>https://iihui.github.io/post/clion-test/</url>
        <categories>
          <category>Code</category>
        </categories>
        <tags>
          <tag>CLion</tag>
        </tags>
        <content type="html">  首先在github下载最新的googletest，解压之后重命名为googletest。然后将其放入到CLion工程目录下，接着修改工程的CMakeList.txt文件。最后，修改main函数，编写单元测试用例。
 下载 在github下载最新的googletest，解压之后命名为googletest，然后将其放在工程目录下：
修改CMkeLists 接着修改CMakeLists.txt文件，使其将googletest纳入到工程中，以供使用：
cmake_minimum_required(VERSION 3.15) project(test) set(CMAKE_CXX_STANDARD 14) set(googleTestDir ./googletest) #Add the google test subdirectoryadd_subdirectory(${googleTestDir}) #include googletest/include dirinclude_directories(${googleTestDir}/googletest/include) #include the googlemock/include dirinclude_directories(${googleTestDir}/googlemock/include) set(SOURCE_FILE main.cpp) add_executable(test ${SOURCE_FILE}) #Link with GoogleTesttarget_link_libraries(test gtest gtest_main) #Link with GoogleMocktarget_link_libraries(test gmock gmock_main) 修改main.cpp CLion重新加载CMakeLists.txt文件未报错之后，开始按下面修改main.cpp文件：
#include &amp;lt;iostream&amp;gt;#include &amp;#34;gtest/gtest.h&amp;#34;int main(int argc, char** argv) { testing::InitGoogleTest(&amp;amp;argc, argv); return RUN_ALL_TESTS(); } 单元测试 最后按照googletest的语法规则编写测试用例，如下所示：
#include &amp;lt;iostream&amp;gt;#include &amp;#34;gtest/gtest.h&amp;#34; int add(int a, int b){ return a&#43;b; } TEST(test1, add){ EXPECT_EQ(3, add(1,2)); EXPECT_EQ(0, add(-1,1)); } int main(int argc, char** argv) { testing::InitGoogleTest(&amp;amp;argc, argv); return RUN_ALL_TESTS(); }  参考资料 参考资料
</content>
    </entry>
    
     <entry>
        <title>iOS开发使用Safari调试WebView</title>
        <url>https://iihui.github.io/post/ios-debug-safari/</url>
        <categories>
          <category>iOS</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html">  在Mac上调试iOS WebView既需要在Mac上的Safari浏览器上开启开发者选项，也需要在iOS设备上开启Web检查功能。
 开启Mac的开发者菜单 首先需要开启Mac上Safari浏览器的显示开发者菜单选项。即先进入到Safari浏览器中的设置，然后点击最右边的高级，再勾选在菜单栏中显示开发菜单，如下图所示：
开启iOS上Safari上的Web检查 然后开启iOS设备中Safari里的网页检查器，设置路径为：设置--&amp;gt;Safari-&amp;gt;高级-&amp;gt;网页检查器：
开始调试 将手机连接到Mac上，打开WebView页面，然后在Mac上的Safari浏览器中的开发者菜单中找到对应的iOS设备：
 参考资料
</content>
    </entry>
    
     <entry>
        <title>Swift 中 where 关键字</title>
        <url>https://iihui.github.io/post/ios-where/</url>
        <categories>
          <category>ios</category>
        </categories>
        <tags>
          <tag>swift</tag><tag>ios</tag>
        </tags>
        <content type="html">  Swift中的where关键字主要用于限定条件，既可在switch语句中使用，也可以用在for in中，还可以在扩展中限定应该遵循某种协议。
 switch中使用 在switch语句中使用，where一般是配合if let来用于限定某些条件，例如：
let names = [&amp;#34;dog&amp;#34;, &amp;#34;cat&amp;#34;, &amp;#34;fish&amp;#34;, &amp;#34;bigDog&amp;#34;, &amp;#34;bigCat&amp;#34;, &amp;#34;bigFish&amp;#34;] names.forEach { switch $0 { case let name where name.hasPrefix(&amp;#34;big&amp;#34;): print(&amp;#34;wow this is a \(name)&amp;#34;) default: break } } for in中使用 在for in使用，也用于添加限定条件，用于过滤，例如：
let names = [&amp;#34;dog&amp;#34;, &amp;#34;cat&amp;#34;, &amp;#34;fish&amp;#34;, &amp;#34;bigDog&amp;#34;, &amp;#34;bigCat&amp;#34;, &amp;#34;bigFish&amp;#34;] for name in names where name == &amp;#34;dog&amp;#34; { print(&amp;#34;\(name)&amp;#34;) } 接口扩展中使用 在扩展中使用where，目的也是进行限定，即希望扩展的默认实现只在某些限定的条件下才可以用:
extension ContiguousArray where Element: BidirectionalCollection { public func joined() -&amp;gt; FlattenBidirectionalCollection&amp;lt;ContiguousArray&amp;lt;Element&amp;gt;&amp;gt; } extension ContiguousArray where Element: Sequence { public func joined&amp;lt;Separator&amp;gt;(separator: Separator) -&amp;gt; JoinedSequence&amp;lt;ContiguousArray&amp;lt;Element&amp;gt;&amp;gt; where Separator: Sequence, Separator.Element == Element.Element } extension Array where Element: Comparable { public var isSorted: Bool { var preIndex = startIndex var curIndex = startIndex &#43; 1 while curIndex != endIndex { if self[preIndex] &amp;gt; self[curIndex] { return false } preIndex = curIndex curIndex &#43; 1 } return true } }  参考资料
</content>
    </entry>
    
     <entry>
        <title>Swift 方法交换中的addMethod</title>
        <url>https://iihui.github.io/post/ios-addmethod/</url>
        <categories>
          <category>Swift</category><category>iOS</category>
        </categories>
        <tags>
          <tag>Swift</tag><tag>iOS</tag>
        </tags>
        <content type="html">  Swizzle是OC的黑魔法之一，可以在运行时对两个方法的实现进行交换，也就是用户可以用自己的方法替换原来的方法实现，做一些其它事情。Swift也可以使用运行时的方法交换，如果要了解Swift的方法交换，首先应该了解class_addMethod这个方法的作用。
 class_addMethod 为了了解class_addMethod方法的作用，首先看下面的这段代码，在下面的代码中直接交换了originalSelector和swizzledSelector
extension NSObject { static func swizzlingForClass(_ forClass: AnyClass, originalSelector: Selector, swizzledSelector: Selector) { guard let originalMethod = class_getInstanceMethod(forClass, originalSelector), let swizzledMethod = class_getInstanceMethod(forClass, swizzledSelector) else { return } method_exchangeImplementations(originalMethod, swizzledMethod) } } 存在的问题 假设父类名为method的方法，子类未重写这个method方法，子类的中想要用来交换的方法为swizzledMethod。如果按照上面的方法交换时，因为父类有该方法，而子类未重写该方法，所以调用class_getInstanceMethod得到的是父类的method方法，所以它与子类的swizzledMethod方法进行交换需要分两种情形来讨论：
  如果在子类实例中调用method方法时，因为已经与自己的swizzledMethod方法交换，所以实际上调用的自己swizzledMethod，所以能够正常运行。
  如果在父类的实例中调用method方法，因为已经与子类的swizzledMethod方法交换，所以调用的是子类的swizzledMethod方法。也就是说此时是父类调用子类的方法，所以会崩溃。
  根据上面的讨论，首先应该判断子类是否重写了method方法，如果实重写了父类的该方法则直接进行交换。如果没有重写父类的该方法，则应该先在父类中新建一个同名的方法。为了新建一个同名的方法，首先应当了解class_addMethod这个函数。
完善的方案 根据上面的分析，先来看一下class_addMethod的函数原型，如下所示：
@available(iOS 2.0, *) public func class_addMethod(_ cls: AnyClass?, _ name: Selector, _ imp: IMP, _ types: UnsafePointer&amp;lt;Int8&amp;gt;?) -&amp;gt; Bool 这个方法的作用是在一个类中添加一个新方法(名字&#43;实现）,class_addMethod函数中参数的含义为下：
  cls表示需要添加方法的类
  name表示要添加的方法的selector（方法名，这里的方法名是一个结构体）
  imp 表示要添加的方法的实现的指针IMP（定义在这里)）
  types用来描述方法参数的字符串数组
  如果cls中含有name则添加失败，返回false。这个方法会重写cls父类中与name同名的方法，但是不会替换cls中已经存在的与cls同名的方法。但是，如果想要替换cls中与name同名的方法，应该调用method_setImplementation。
  因此，可以使用class_addMethod方法的返回值来确定当前类中是否存在能够交换的方法，如果存在(添加失败)则直接交换。
let didAddMethod: Bool = class_addMethod(object, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod)) 上面的代码中如果didAddMethod返回为false，则说明可以直接进行方法交换，如果返回值为true，则说明在子类中添加originalSelector成功，并且originalSelector指向了子类的swizzledMethod的实现。但是swizzledSelector的实现还是它原来的实现，接下来就要将swizzledSelector指向originalMethod的实现。因此，完整的代码应该如下所示：
static func exchangeSelector(object:AnyClass,originalSelector: Selector, swizzledSelector: Selector) { guard let originalMethod = class_getInstanceMethod(object, originalSelector) else { return } guard let swizzledMethod = class_getInstanceMethod(object, swizzledSelector) else { return } let didAddMethod: Bool = class_addMethod(object, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod)) if didAddMethod { class_replaceMethod(object, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod)) } else { method_exchangeImplementations(originalMethod, swizzledMethod) } } 构建工具类 因为当前App埋点的时候很多地方需要使用到方法交换，因此决定写一个专门的工具类来实现Swift的方法交换，如下所示：
class MethodSwizzlingTools { static func exchangeSelector(object: AnyClass, originalSelector: Selector, swizzledSelector: Selector) { //对于class_getInstanceMethod方法，若类没有实现对应的方法，但父类实现了，则这个函数会返回父类的方法 guard let originalMethod = class_getInstanceMethod(object, originalSelector) else { return } guard let swizzledMethod = class_getInstanceMethod(object, swizzledSelector) else { return } //参考https://juejin.im/post/5cb6df44e51d456e6f45c6f1 let didAddMethod: Bool = class_addMethod(object, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod)) if didAddMethod { class_replaceMethod(object, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod)) } else { method_exchangeImplementations(originalMethod, swizzledMethod) } } //交换两个不同类的方法，这两个类应该满足父子关系 static func exchangeSelector(originalClass: AnyClass, originalSelector: Selector, swizzledClass: AnyClass, swizzledSelector: Selector) { guard let originalMethod = class_getInstanceMethod(originalClass, originalSelector), let swizzledMethod = class_getInstanceMethod(swizzledClass, swizzledSelector) else { return } let didAddMethod: Bool = class_addMethod(originalClass, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod)) if didAddMethod { class_replaceMethod(swizzledClass, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod)) } else { method_exchangeImplementations(originalMethod, swizzledMethod) } } }  参考资料 参考资料
</content>
    </entry>
    
     <entry>
        <title>Any,AnyObject,AnyClass</title>
        <url>https://iihui.github.io/post/ios-any/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>swift</tag><tag>iOS</tag>
        </tags>
        <content type="html">  最近在看Swift中的方法交换，遇到Any、AnyObject与AnyClass次数挺多的，所以在网上找了一些文章看了一下，以此为记。
 AnyObject AnyObject类似于OC中的id类型，表示任意的class类型。但在Swift中由于String、Array等都变成结构体了，AnyObject的适用范围就变窄了。
实际上AnyObject是一个成员为空的协议@objc public protocol AnyObject {}。它注释的第一行:The protocol to which all classes implicitly conform表明所有的类都隐式遵守了这个协议。
Any Any也是一个协议，根据其注释The protocol to which all types implicitly conform.表明所有的类型都遵守该协议，包括基本数据类型，enum, struct, func等等。
AnyClass AnyClass表示任意类的元类型。根据AnyClass的定义typealias AnyClass = AnyObject .Type可知它为AnyObject.Type的别名。AnyObject.Type中的.Type就是获取元类型。例如。对于Student类，Student.Type就是获取Student的元类型。
再根据注释The protocol to which all class types implicitly conform，可知道所有的类的类型都隐式遵守这个协议。
重要区别 AnyObject代表任意class类型的对象实例，Any代表任意类型，甚至包括方法类型，所以AnyObject是Any的子集。
 参考资料 参考资料
</content>
    </entry>
    
     <entry>
        <title>UIControl</title>
        <url>https://iihui.github.io/post/ios-uicontrol/</url>
        <categories>
          <category>iOS</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html">  UIControl是UIView的子类，也是UIResponder的子类。是UIButton，UISwitch，UITextField等控件的父类。它本身定义了一些属性和方法，但是不能直接使用。
 方法交换 extension UIControl { class func swizzleMethod() { struct Static { static var token = NSUUID().uuidString } //确保不是子类 if self != UIControl.self { return } //防止手动调用，造成交换多次 DispatchQueue.once(token: Static.token) { MethodSwizzlingTools.exchangeSelector(object: self, originalSelector: #selector(UIControl.sendAction(_:to:for:)), swizzledSelector: #selector(userSendAction(_:to:for:))) } } @objc func userSendAction(_ action: Selector, to target: Any?, for event: UIEvent?) { self.userSendAction(action, to: target, for: event) } </content>
    </entry>
    
     <entry>
        <title>Swift 中的反射</title>
        <url>https://iihui.github.io/post/ios-reflection/</url>
        <categories>
          <category>iOS</category>
        </categories>
        <tags>
          <tag>swift</tag><tag>iOS</tag>
        </tags>
        <content type="html">  在计算机学中，reflection(反射)是指计算机程序在runtime时可以访问、检测和修改它本身状态或行为的一种能力。比较形象的说法就是，反射是程序在运行的时候能够观察并且修改自己的行为。
 @objc Swift是一门静态语言，和OC不同，不能在运行时做很多复杂的操作。Swift虽然不能像OC一样在运行时做很多事，但是还是做一些小动作，比如和Java类似的反射机制等。
@objc，可以用来标记函数和类、协议等等。这个标记表示该方法或者该类可以被用于运行时。例如，在Swift中类似按钮点击的selector都必须用@objc标记，表示该方法是运行时调用（按钮点击是运行时事件，编译器在编译时对没有调用到的非运行时函数会优化掉）。
在Swift 4之后的版本里，类继承 NSObjct不会再默认带@objc 标记，当重写NSObjct编辑器会自动提示带上 @objc。
除了上面用@objc标记这种方法外，还可以通过反射(Reflection)来实现一些诸如运行时获取类型、成员信息，调用任意方法等行为。Reflection主要使用Mirror这个结构体来做一些事情。
Swift反射 Swift的反射机制是基于一个叫Mirror的Stuct来实现的。具体的操作方式为：首先创建一个你想要反射的类的实例，再传给Mirror的构造器来实例化一个Mirror对象，最后使用这个Mirror来获取你想要的东西。
尽管Swift一直都在强调强类型、编译时安全并推荐使用静态调度，但它的标准库仍然提供了一个基于Mirror的Struct来实现的反射机制。简单来说，例如你有一个Class A并创建了一个A的实例对象a，此时你就可以通过Mirror(reflecting: a)来生成一个Mirror对象m，然后遍历m.children就可以获取到a对象的所有属性：
// //main.swift import Foundation protocol Drive { func run() } public class Tire { //轮胎 var brand: String? //品牌 var size: Float = 0 //大小 } public class Vehicle: Drive { var carType: String? var tires: [Tire]? var host: String?//主人 var brand: String?//汽车品牌 func run() { if let h = host { print(&amp;#34;\(h)Drive a \(brand)\(carType)car run&amp;#34;) } else { print(&amp;#34;this car is not selled&amp;#34;) } } } public class Trunk: Vehicle { public var packintBox: String? } public struct TranGroup { //货运集团 var trunks = { return [Trunk]() }() var country: String? var turnover: Float? } //一个中国的货运集团 var tranGroup = TranGroup() tranGroup.country = &amp;#34;天朝&amp;#34; tranGroup.turnover = 2222 let trunk1 = Trunk() trunk1.brand = &amp;#34;MAN&amp;#34; trunk1.host = &amp;#34;Stan&amp;#34; trunk1.packintBox = &amp;#34;Big And Long&amp;#34; tranGroup.trunks.append(trunk1) let mirrorTran = Mirror(reflecting: tranGroup) print(tranGroup) //打印出TranGroup相关信息 print(mirrorTran.subjectType) //打印出TranGroup print(mirrorTran.displayStyle) //Optional(Swift.Mirror.DisplayStyle.Struct)，是个Struct类型 print(mirrorTran.superclassMirror) //nil，因为没有父类 for (key, value) in mirrorTran.children { print(&amp;#34;\(key): \(value)&amp;#34;) } 打印的结果：
TranGroup(trunks: [test.Trunk], country: Optional(&amp;#34;天朝&amp;#34;), turnover: Optional(2222.0)) TranGroup Optional(Swift.Mirror.DisplayStyle.struct) nil Optional(&amp;#34;trunks&amp;#34;) : [test.Trunk] Optional(&amp;#34;country&amp;#34;) : Optional(&amp;#34;天朝&amp;#34;) Optional(&amp;#34;turnover&amp;#34;) : Optional(2222.0) </content>
    </entry>
    
     <entry>
        <title>KVC 键值编码</title>
        <url>https://iihui.github.io/post/ios-kvc/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>iOS</tag><tag>oc</tag>
        </tags>
        <content type="html">  KVC(Key Value Coding)键值编码，指允许通过Key名字来直接访问对象的属性，而不需要调用明确的存取方法。这样，便能在运行时动态地访问和修改对象的属性值。在iOS中，无论是Swift还是OC，KVC都是通过对NSObject的扩展来实现的。所以，继承了NSObject的类型的对象都能使用KVC。
 KVC KVC是一种通过字符串间接访问对象的属性的方法，而不是通过调用存取方法（setter/getter）来获取属性，下面是KVC最为重要的四个方法：
- (nullable id)valueForKey:(NSString *)key; //直接通过Key(NSString属性的名字)来取值 - (void)setValue:(nullable id)value forKey:(NSString *)key; //通过Key(NSString属性的名字)来设值 - (nullable id)valueForKeyPath:(NSString *)keyPath; //通过KeyPath(xx.xx)来取值 - (void)setValue:(nullable id)value forKeyPath:(NSString *)keyPath; //通过KeyPath(xx.xx)来设值 寻找Key机制 在赋值和取之的时候都要先寻找Key，但这两者在寻找Key的方式是有区别的，接下来一一说明它们寻找Key的机制。
设置值 当调用setValue：属性值 forKey：@”name“，来设置值时，底层的执行机制如下：
  程序优先调用set&amp;lt;Key&amp;gt;:属性值方法，代码通过setter方法完成设置。这里的Key是指成员变量名，而不是forKey表示的值。
  如果没有找到setName:方法，KVC机制会检查&#43; (BOOL)accessInstanceVariablesDirectly方法有没有返回YES（默认返回）。如果重写了该方法并返回NO的话，那么接下来执行setValue：forUndefinedKey方法，不过一般开发者不会这么做。所以KVC机制会搜索该类里面有没有名为_&amp;lt;key&amp;gt;的成员变量，无论该变量是在类接口处定义，还是在类实现处定义，也无论用了什么样的访问修饰符，只在存在以_&amp;lt;key&amp;gt;命名的变量，KVC都可以对该成员变量赋值。
  如果该类既没有set&amp;lt;key&amp;gt;方法，也没有_&amp;lt;key&amp;gt;成员变量，KVC机制会搜索_is&amp;lt;Key&amp;gt;的成员变量。
  如果该类既没有set&amp;lt;Key&amp;gt;方法，也没有_&amp;lt;key&amp;gt;和_is&amp;lt;Key&amp;gt;成员变量，KVC机制再会继续搜索是否存在&amp;lt;key&amp;gt;和is&amp;lt;Key&amp;gt;的成员变量，再给它们赋值。
  如果上面列出的方法或者成员变量都不存在，系统将会执行该对象的setValue：forUndefinedKey方法，默认是抛出异常。
  如果想让这个类禁用KVC，只要重写&#43; (BOOL)accessInstanceVariablesDirectly方法，并让它返回NO即可。
@interface Dog : NSObject @end @implementation Dog { NSString* toSetName; NSString* isName; //NSString* name;  NSString* _name; NSString* _isName; } // -(void)setName:(NSString*)name{ // toSetName = name; // } //-(NSString*)getName{ // return toSetName; //} &#43;(BOOL)accessInstanceVariablesDirectly{ return NO; } -(id)valueForUndefinedKey:(NSString *)key{ NSLog(@&amp;#34;出现异常，该key不存在%@&amp;#34;,key); return nil; } -(void)setValue:(id)value forUndefinedKey:(NSString *)key{ NSLog(@&amp;#34;出现异常，该key不存在%@&amp;#34;,key); } @end int main(int argc, const char * argv[]) { @autoreleasepool { // insert code here...  Dog* dog = [Dog new]; [dog setValue:@&amp;#34;newName&amp;#34; forKey:@&amp;#34;name&amp;#34;]; NSString* name = [dog valueForKey:@&amp;#34;toSetName&amp;#34;]; NSLog(@&amp;#34;%@&amp;#34;,name); } return 0; } 上面代码的输出为：
2020-02-15 09:33:48.596397&#43;0800 test[52035:3057928] 出现异常，该key不存在name 2020-02-15 09:33:48.596949&#43;0800 test[52035:3057928] 出现异常，该key不存在toSetName 2020-02-15 09:33:48.596987&#43;0800 test[52035:3057928] (null) 这是因为重写了&#43;(BOOL)accessInstanceVariablesDirectly，并让它返回了NO之后，KVC不再去找name系列成员变量，而是直接调用setValue：forUndefinedKey：。所以如果不想让自定义的类实现KVC，则可以像上面那样做。
如果将下面的注释取消：
-(void)setName:(NSString*)name{ toSetName = name; } -(NSString*)getName{ return toSetName; } 并将NSString* name = [dog valueForKey:@&amp;quot;toSetName&amp;quot;]; 换成 NSString* name = [dog valueForKey:@&amp;quot;name&amp;quot;];就可以得到正确的结果了：
2020-02-15 09:59:52.961889&#43;0800 test[52736:3072979] newName 根据上面的寻找机制，按照如下修改，仍然可以设置name的值：
#import &amp;#34;Dog.h&amp;#34; @implementation Dog { NSString* toSetName; NSString* isName; //NSString* name;  NSString* _name; NSString* _isName; } // -(void)setName:(NSString*)name{ // toSetName = name; // } //-(NSString*)getName{ // return toSetName; //} &#43;(BOOL)accessInstanceVariablesDirectly{ return YES; } -(id)valueForUndefinedKey:(NSString *)key{ NSLog(@&amp;#34;出现异常，该key不存在%@&amp;#34;,key); return nil; } -(void)setValue:(id)value forUndefinedKey:(NSString *)key{ NSLog(@&amp;#34;出现异常，该key不存在%@&amp;#34;,key); } @end #import &amp;lt;Foundation/Foundation.h&amp;gt;#import &amp;#34;Dog.h&amp;#34; int main(int argc, const char * argv[]) { @autoreleasepool { // insert code here...  Dog * dog = [Dog new]; [dog setValue:@&amp;#34;newName&amp;#34; forKey:@&amp;#34;name&amp;#34;]; NSString* name = [dog valueForKey:@&amp;#34;name&amp;#34;]; NSLog(@&amp;#34;%@&amp;#34;,name); } return 0; } 打印的结果如下所示：
2020-02-15 10:09:25.756648&#43;0800 test[52930:3077204] newName 取值 当调用valueForKey：@”name“的代码时，KVC对key的搜索方式不同于setValue：属性值 forKey：@”name“，其搜索方式如下：
  首先按get&amp;lt;Key&amp;gt;,&amp;lt;key&amp;gt;,is&amp;lt;Key&amp;gt;的顺序方法查找getter方法，找到的话会直接调用。如果是BOOL或者Int等值类型， 会将其包装成一个NSNumber对象。
  如果上面的getter没有找到，KVC则会查找countOf&amp;lt;Key&amp;gt;,objectIn&amp;lt;Key&amp;gt;AtIndex或&amp;lt;Key&amp;gt;AtIndexes格式的方法。如果countOf&amp;lt;Key&amp;gt;方法和另外两个方法中的一个被找到，那么就会返回一个可以响应NSArray所有方法的代理集合(它是NSKeyValueArray，为NSArray的子类)，调用这个代理集合的方法，或者说给这个代理集合发送属于NSArray的方法，就会以countOf&amp;lt;Key&amp;gt;,objectIn&amp;lt;Key&amp;gt;AtIndex或&amp;lt;Key&amp;gt;AtIndexes这几个方法组合的形式调用。还有一个可选的get&amp;lt;Key&amp;gt;:range:方法。所以你想重新定义KVC的一些功能，你可以添加这些方法，需要注意的是你的方法名要符合KVC的标准命名方法，包括方法签名。  如果上面的方法没有找到，那么会同时查找countOf&amp;lt;Key&amp;gt;，enumeratorOf&amp;lt;Key&amp;gt;,memberOf&amp;lt;Key&amp;gt;格式的方法。如果这三个方法都找到，那么就返回一个可以响应NSSet所的方法的代理集合，和上面一样，给这个代理集合发NSSet的消息，就会以countOf&amp;lt;Key&amp;gt;，enumeratorOf&amp;lt;Key&amp;gt;,memberOf&amp;lt;Key&amp;gt;组合的形式调用。
  如果还没有找到，再检查类方法&#43;(BOOL)accessInstanceVariablesDirectly,如果返回YES(默认行为)，那么和先前的设值一样，会按_&amp;lt;key&amp;gt;,_is&amp;lt;Key&amp;gt;,&amp;lt;key&amp;gt;,is&amp;lt;Key&amp;gt;的顺序搜索成员变量名，这里不推荐这么做，因为这样直接访问实例变量破坏了封装性，使代码更脆弱。如果重写了类方法&#43; (BOOL)accessInstanceVariablesDirectly返回NO的话，那么会直接调用valueForUndefinedKey:
  还没有找到的话，调用valueForUndefinedKey:
  KeyPath 一个类的成员变量有可能是自定义类或其他的复杂数据类型，可以先用KVC获取该属性，然后再次用KVC来获取这个自定义类的属性，但这样是比较繁琐的。因此，KVC提供了一个解决方案，那就是键路径keyPath。
KeyPath，表示键路径，是一个由点作分隔符的键组成的字符串（点语法），用于表示一个连接在一起的对象序列。其中，后一个键的性质是由前一个键的性质决定的（如同现代面向对象语言取成员）。所以，KVC对于keyPath是搜索机制第一步就是分离key，用小数点.来分割key，然后再像普通key一样按照先前介绍的顺序搜索下去。
有了键路径，就可以不通过相应的方法来直接取相关的性质（属性/方法）。通过键路径，可以指定对象中的一个任意深度的路径，使其指向相关对象的特定属性。
- (nullable id)valueForKeyPath:(NSString *)keyPath; //通过KeyPath来取值 - (void)setValue:(nullable id)value forKeyPath:(NSString *)keyPath; //通过KeyPath来设值 下面是一个例子：
@interface Address : NSObject @end @interface Address() @property (nonatomic,copy)NSString* country; @end @implementation Address @end @interface People : NSObject @end @interface People() @property (nonatomic,copy) NSString* name; @property (nonatomic,strong) Address* address; @property (nonatomic,assign) NSInteger age; @end @implementation People @end int main(int argc, const char * argv[]) { @autoreleasepool { People* people1 = [People new]; Address* addr = [Address new]; addr.country = @&amp;#34;China&amp;#34;; people1.address = addr; NSString* country1 = people1.address.country; NSString * country2 = [people1 valueForKeyPath:@&amp;#34;address.country&amp;#34;]; NSLog(@&amp;#34;country1:%@ country2:%@&amp;#34;,country1,country2); [people1 setValue:@&amp;#34;USA&amp;#34; forKeyPath:@&amp;#34;address.country&amp;#34;]; country1 = people1.address.country; country2 = [people1 valueForKeyPath:@&amp;#34;address.country&amp;#34;]; NSLog(@&amp;#34;country1:%@ country2:%@&amp;#34;,country1,country2); } return 0; } //打印结果 2020-02-15 11:13:48.223700&#43;0800 test[54340:3105892] country1:China country2:China 2020-02-15 11:13:48.224670&#43;0800 test[54340:3105892] country1:USA country2:USA 异常处理 KVC中最常见的异常就是不小心使用了错误的key，或者在设置值的时候不小心传递了nil。如果不小心传递了nil值，KVC会调用setNilValueForKey:方法，这个方法默认是抛出异常，所以一般而言还是重写这个方法：
@implementation People -(void)setNilValueForKey:(NSString *)key{ NSLog(@&amp;#34;不能将%@设成nil&amp;#34;,key); } @end 非对象和自定义对象 不是每一个方法都返回对象，但是valueForKey：总是返回一个id对象。如果原本的变量类型是值类型或者结构体，返回值会封装成NSNumber或者NSValue对象。这两个类会处理从数字，布尔值到指针和结构体的任何类型。然后，如果需要使用的话，需手动转换成原来的类型。尽管valueForKey会自动将值类型封装成对象，但是setValue：forKey：却不行。必须手动将值类型转换成NSNumber或者NSValue类型，才能传递过去。
Address* add2 = [Address new]; add2.country = @&amp;#34;England&amp;#34;; [people1 setValue:add2 forKey:@&amp;#34;address&amp;#34;]; NSString* country1 = people1.address.country; NSString * country2 = [people1 valueForKeyPath:@&amp;#34;address.country&amp;#34;]; NSLog(@&amp;#34;country1:%@ country2:%@&amp;#34;,country1,country2); 缺点   一旦使用KVC，编译器将无法检查出错误，即不会对设置的键、键路径进行错误检查。
  执行效率要低于合成存取器方法和自定义的setter和getter方法。效率低的原因是使用KVC键值编码，它必须先解析字符串，然后在设置或者访问对象的实例变量。
  KVC的使用 KVC在iOS开发中是绝不可少的利器，这种基于运行时的编程方式极大地提高了灵活性，简化了代码，下面来列举iOS开发中KVC的使用场景。
动态的取值和设值 上面很多例子就是使用KVC动态地取值和设值，这是最基本的用途了，每一个iOS developer都应该要掌握。
访问私有成员 对于类中的私有成员，OC是无法直接访问的，但是KVC是可以的，可以参考前面Dog的例子。
Model和字典的相互转换 Model和字典的相互转换，具体参考。充分地运用了KVC和Runtime组合的技巧，只用了短短数行代码就是完成了很多功能。
修改一些控件的内部属性 众所周知很多UI控件都由很多内部UI控件组合而成的，但是Apple没有提供这访问这些控件的API，这样我们就无法正常地访问和修改这些控件的样式。而KVC在大多数情况可下可以解决这个问题，最常用的就是个性化UITextField中的placeHolderText了。下面演示如果修改placeHolder的文字样式。这里的关键点是如何获取要修改的样式的属性名，也就是key或者keyPath：
let count:UnsafeMutablePointer&amp;lt;UInt32&amp;gt; = UnsafeMutablePointer&amp;lt;UInt32&amp;gt;() var properties = class_copyIvarList(UITextField.self, count) while properties.memory.debugDescription != &amp;#34;0x0000000000000000&amp;#34;{ let t = ivar_getName(properties.memory) let n = NSString(CString: t, encoding: NSUTF8StringEncoding) print(n) //打印出所有属性，这里我用了Swift语言  properties = properties.successor() } //上面省略了部分属性 Optional(_disabledBackgroundView) Optional(_systemBackgroundView) Optional(_floatingContentView) Optional(_contentBackdropView) Optional(_fieldEditorBackgroundView) Optional(_fieldEditorEffectView) Optional(_displayLabel) Optional(_placeholderLabel) //这个正是我想要修改的属性。 Optional(_dictationLabel) Optional(_suffixLabel) Optional(_prefixLabel) Optional(_iconView) //下面省略了部分属性 操作集合 Apple对KVC的valueForKey:方法作了一些特殊的实现，比如说NSArray和NSSet这样的容器类就实现了这些方法，所以可以用KVC很方便地操作集合。
高阶消息传递 当对容器类使用KVC时，valueForKey:将会被传递给容器中的每一个对象，而不是容器本身进行操作。结果会被添加进返回的容器中。这样，开发者可以很方便的操作集合来返回另一个集合。
NSArray* arrStr = @[@&amp;#34;english&amp;#34;,@&amp;#34;franch&amp;#34;,@&amp;#34;chinese&amp;#34;]; NSArray* arrCapStr = [arrStr valueForKey:@&amp;#34;capitalizedString&amp;#34;]; for (NSString* str in arrCapStr) { NSLog(@&amp;#34;%@&amp;#34;,str); } NSArray* arrCapStrLength = [arrStr valueForKeyPath:@&amp;#34;capitalizedString.length&amp;#34;]; for (NSNumber* length in arrCapStrLength) { NSLog(@&amp;#34;%ld&amp;#34;,(long)length.integerValue); } //结果 2020-02-15 13:08:35.863142&#43;0800 test[55706:3138103] English 2020-02-15 13:08:35.863904&#43;0800 test[55706:3138103] Franch 2020-02-15 13:08:35.863924&#43;0800 test[55706:3138103] Chinese 2020-02-15 13:08:35.864765&#43;0800 test[55706:3138103] 7 2020-02-15 13:08:35.864805&#43;0800 test[55706:3138103] 6 2020-02-15 13:08:35.864820&#43;0800 test[55706:3138103] 7 方法capitalizedString被传递到NSArray中的每一项。NSArray的每一员都会执行capitalizedString并返回一个包含结果的新的NSArray。
参考资料 参考资料
</content>
    </entry>
    
     <entry>
        <title>工具使用备忘录</title>
        <url>https://iihui.github.io/post/tool-usage/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>vs</tag>
        </tags>
        <content type="html">  使用Mac时候会安装各种工具，例如Visual Studio Code，XCode，itemr2，AppCode等等。在这些工具的使用过程中，经常也会遇到一些问题，查了之后容易忘记，以此为记，以期节省时间。
 Visual Studio Code 列模式 快捷键为shift &#43; option &#43; 单击，即可开启列模式，然后鼠标拖动，即可选择范围：
AppCode 列模式 直接按住option即可进入列选择模式，然后拖动鼠标，即可选择相应的范围，如下图所示:
iterm2 设置为默认终端 因为经常使用iterm2，所以想将其设置为默认的终端，还好iterm2本身支持修改，只要在应用的菜单栏，点击Make Iterm2 to default Term如下图所示：
常用快捷键   CMD&#43;D 纵向将当前窗口分为大小相同的两个窗口
  SHIFT&#43;CMD&#43;D 横行将当前窗口分为大小相同的两个窗口
  </content>
    </entry>
    
     <entry>
        <title>飞书特色功能</title>
        <url>https://iihui.github.io/post/ios-feishu/</url>
        <categories>
          <category>iOS</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html">  飞书把更多的需求优化倾向于团队成员，而不是管理者。所以它以「即时沟通」为中心，将在线文档、云盘、日历等功能全部整合在一起。 例如，可以在IM（即时通讯）界面直接创建文档，共同编辑，也可以在文档中进一步讨论细节问题；或是发起一个日程，在日程中直接创建一个执行群组等等。这是一套围绕工作本身而展开的流动系统，更加符合扁平化管理模式。
@符号 在传统的IM工具里，@一直是个标志性符号，你可以用它来提及某个人，或者让自己的发言指向某个具体对象。但在飞书的文档功能里，@ 符号变成了能够快速插入各种文档元素的启动器，让你可以在输入文字时以最少的操作步骤将文件、表格、视频等元素植入文档。
在飞书文档里，输入@符号就能瞬间调起模块插入功能，无论是提及IM里的同事、插入群名片甚至提及外部合作伙伴，还是插入云空间的文件、表格、投票、视频、地图等网页元素，都能立刻完成，不必在工具栏里寻找和点按。
IM即时消息 群中发消息可以看所有成员查看状态 往群里发消息之后，发送消息的人可以查看群里其他成员查看这条消息的阅读状态，如下图所示：
群中新成员可看旧消息 在已有的工作群拉入新成员时，新成员入群后也能够看到此前的群消息，不需要再将之前的工作安排从头重新截图或者转发一次，减少消息重叠和冗余。
快捷回复不刷屏 对于某条消息是在征求意见的时候，收到消息的人长按这条消息可以回复，没有问题的人可以直接以快捷键「OK」或者 「点赞」回复，有问题的人则可以针对这条消息进行回复，所有的话题都可以串联在一起追溯，避免刷屏。
聚焦消息串 IM在群聊时最大的问题就是无法精准回复，当群里不同成员在讲不同主题的内容时，直接回复常常容易聊串，导致群讨论越聊越乱。在飞书中，「消息串」可以很好地解决这个问题。当你需要回复某个群成员的发言时，只需要直接在其发言上使用回复功能，双方的讨论就会自然形成一个「消息串」，聚焦要点。点击消息，右侧还能自动显示整个消息串中的内容，方便回溯上下文：
回到最后看最新消息 消息列表较长时，下拉时会悬浮显示回到最后按钮： 在线文档 飞书的在线文档可以作为文档中转站，将其第三方的文件导入到云空间。也可以将云文档分发给第三方应用。邀请邀请伙伴进入文档协作之后，各个伙伴可以修改、批注、评论等。
文档中转站 当收到任何需要备份的文件时，都可以将其导入飞书的个人空间随时查看，不用再担心把文件搞丢。同时，文件还可以方便地分享给飞书里的同事开启协作，让外部文件无缝融入工作流。例如在使用微信时，点击「用其它应用打开」- 选择「飞书」- 「发送给自己」，最后点击「保存到云空间」即可。
外部协作 所有文档都可以分享给第三方，用于协作和消息互通。这个功能更新充分释放了飞书文档作为互联网工具的连接属性，即使对方不是飞书用户，依然可以接收和查看文档信息。
文档协作 飞书在线文档和IM进行了深度打通，创作者和评论者可以在文档中随时@参与人，邀请对方加入编辑或评论，甚至直接通过@分配参与者的角色和工作，被@的人会在IM中实时收到文档消息并互动，可以建立沟通闭环。
  可以在文档中@相关人员，请他参与某一细节讨论，或提供协助，或对文档给予关注，他就会在消息中收到提醒，完全不用打开该文档，就可直接在消息提醒页进行沟通/编辑。
  将文档分享到群组时，可以进行权限管理，选择授予群组成员查看/编辑的权限，避免多版本来回修改带来的低效和混乱。
  日历  日历与即时沟通，在线文档深度整合，可以互相查看忙闲状态，从而合理制定日程。
 订阅成员日历 当你不确定需要沟通的领导、同事行程和档期时，只需订阅他们的日历，就能对他们何时有空、档期如何安排一目了然：
从会议邀约创建群聊 发出会议邀约后，也可以一键创建会议群聊，将文档进行共享，以便做好会前准备和会后总结，可以做到专会专群、即用即走，大幅提升开会效率：
会议纪要自动生成 每次开会都要填写一些时间、地点、主题、参会人之类的基础信息，不仅写起来很麻烦，而且这些信息都不是核心内容，时间的投入产出比很低。
飞书打通了日程和文档，巧妙地解决了这个问题。在会议结束后，只需要在日程中选择当前会议的「生成会议纪要」功能，系统就会自动抓取会议的基础信息，不用再人工填写：
转让日程 当日程的组织者因为某种原因不能实施该日程，则可以将该日程转让给其他人：
全局和过滤搜索 飞书消息页的搜索功能比较强大，可以进行全局搜索，也可以进行过滤搜索：
机器人 飞书提供了种类丰富的机器人，主要分为助手型的机器人和外接功能型的机器人。助手型机器人便于分类管理消息；还有一类外接功能型的机器人，可以将外部工具通过接口接入到飞书（详情请查看飞书官方文档）：
 </content>
    </entry>
    
     <entry>
        <title>iOS 可视化埋点</title>
        <url>https://iihui.github.io/post/ios-log-point/</url>
        <categories>
          <category>iOS</category>
        </categories>
        <tags>
          <tag>iOS</tag><tag>oc</tag>
        </tags>
        <content type="html">  埋点方案大体上可以归为3类：代码埋点，可视化埋点，无埋点。代码埋点，由开发人员在触发事件的具体方法里，植入多行代码把需要上传的数据发送至服务端。可视化埋点，根据标识来识别每一个事件，针对指定的事件进行取参埋点。而事件的标识与参数信息都写在配置表中，通过动态下发配置表来实现埋点统计。无埋点，无埋点并不是不需要埋点，更准确的说应该是“全埋点”，前端的任意一个事件都被绑定一个标识，所有的事件都被记录下来。通过定期上传记录文件，配合文件解析，解析出想要的数据，并以此生成可视化报告供专业人员分析，因此实现无埋点统计。
 可视化埋点 可视化埋点并非完全摒弃了代码埋点，而是在代码埋点的上层封装的一套逻辑来代替手工埋点，大体上架构如下图：
要实现可视化埋点也有很多问题需要解决，比如事件唯一标识的确定，业务参数的获取，有逻辑判断的埋点配置项信息等等。
事件唯一标识 唯一标识的组成方式主要是由target &#43; action来确定，即任何一个事件都存在一个target与action。在此引入AOP编程，AOP（Aspect-Oriented-Programming）即面向切面编程的思想，基于Runtime的 Method Swizzling能力，来hook相应的方法，从而在hook方法中进行统一的埋点处理。例如所有的按钮被点击时，都会触发UIApplication的sendActio方法，我们hook这个方法，即可拦截所有按钮的点击事件:
事件的锁定主要是靠事件唯一标识符，而事件的唯一标识是事先写入配置表中，然后根据配置表来解析具体是哪个界面的哪个事件。
埋点数据分为两种类型：固定数据与可变的业务数据，固定数据可以直接写到配置表中，通过唯一标识来获取。对于业务数据，可以这么理解：数据是有持有者的，例如Controller的一个属性值，又如数据在Model的某一个层级。 这样就可以通过KVC(全称是Key Value Coding)的方式来递归获取该属性的值来取到业务数据。
统计术语 UV(Unique Visitor)：独立访客，将每个独立上网电脑（以cookie为依据）视为一位访客，一天之内（00:00-24:00），访问您网站的访客数量。一天之内相同cookie的访问只被计算1次。
PV（Page View）：访问量，即页面浏览量或者点击量，用户每次对网站的访问均被记录1次，用户对同一页面的多次访问，访问量值累计。
统计独立IP：00:00-24:00内相同IP地址只被计算一次，做网站优化的朋友最关心这个。
</content>
    </entry>
    
     <entry>
        <title>H5 性能监控</title>
        <url>https://iihui.github.io/post/ios-h5-monitoring/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html"> UIWebView 和 UIWKWebView 目前iOS中有两个加载网页的类，分别是UIWebView和WKWebView，UIWebView是UIKit框架中的一个类，而WKWebView是WebKit框架中的类。
  从性能上来说WKWebView的性能高、稳定性好、占用内存小，完全优于UIWebView。
  由于WKWebView是iOS 8.0提供的组件，因此系统版本低于iOS 8.0的iPhone/iPad用户就无法正常使用WKWebView组件开发出来的APP。所以目前大部分开发人员还在使用性能、稳定性并不理想的UIWebView进行WebAPP开发。
  H5页面的体验问题 从用户角度，相比Native页面，H5页面的体验问题主要有两点：
H5 加载过程 初始化 当App首次打开时，默认是并不初始化浏览器内核的；只有当创建WebView实例的时候，才会创建WebView的基础框架。所以与浏览器不同，App中打开WebView的第一步并不是建立连接，而是启动浏览器内核。
  首次初始化时间：客户端冷启动后，第一次打开WebView，从开始创建WebView到开始建立网络连接之间的时间。
  二次初始化时间：在打开过WebView后，退出WebView，再重新打开WebView，从开始创建WebView到开始建立网络连接之间的时间。
  Webview总是很慢的原因之一：客户端需要先花费时间初始化WebView完成后，才开始加载。而这段时间，由于WebView还不存在，所有后续的过程是完全阻塞的，可以这样形容WebView初始化过程：
性能数据 性能数据包括白屏时间，白屏时间无论安卓还是iOS在加载网页的时候都会存在的问题，也是目前无法解决的。
页面耗时，页面耗时指的是开始加载这个网页到整个页面load完成即渲染完成的时间；
</content>
    </entry>
    
     <entry>
        <title>Objective-C Runtime</title>
        <url>https://iihui.github.io/post/oc-runtime/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>oc</tag><tag>iOS</tag>
        </tags>
        <content type="html">  Objective-C扩展了C语言，并加入了面向对象特性和Smalltalk式的消息传递机制。而这个扩展的核心是一个用C写的Runtime库，它是OC面向对象和动态机制的基石。OC的Runtime用于创建类对象、进行消息传递和转发。理解OC的Runtime机制可以更好地了解这个语言，适当的时候还能对语言进行扩展，从系统层面解决项目中的一些设计或技术问题。理解Runtime，首先应该了解它的核心——消息传递（Messaging）机制。
 Runtime版本 Runtime有两个版本: modern和legacy版。现用的Objective-C 2.*是Modern 版，只能运行在iOS和macOS 10.5之后的64位程序中。而macOS较老的32位程序仍采用Objective-C 1.*中的Legacy版本。两个版本最大的区别在于：当更改一个类的实例变量布局时，在早期版本中需要重新编译它的子类，而Modern版不需要重新编译子类。
高级编程语言想要成为可执行文件需要先编译为汇编语言，再将汇编语言转换为机器语言（机器语言是计算机能够识别的唯一语言）。但是，OC并不能直接编译为汇编语言，而是要先转写为纯C语言再进行编译和汇编操作，从OC到C的过渡是由runtime库来实现的。因为OC主要进行面向对象开发，而C语言是面向过程开发，这就需要将面向对象的类转变为面向过程的结构体。
消息传递 所有的OC方法调用[receiver selector]在编译时都会转化为对应的C函数objc_msgSend(receiver，selector)的调用。例如一个对象方法调用[obj,foo]，Runtime执行方法调用的过程如下：
  首先，通过obj的isa指针找到它的class
  然后，在obj的class的objc_method_list找foo
  如果class的objc_method_list中没到foo，继续往它的super_class中寻找foo
  若找到foo这个函数，就去执行它的实现IMP，否则报错
  但上述流程存在效率低的问题：通常一个class只有20%的函数经常被调用，可能占总调用次数的80%，所以每次消息传递的时候都遍历一次objc_method_list并不合理。如果把经常被调用的函数缓存下来，就可以大大提高函数的查询效率。objc_cache就是做这样的事情，当找到selector后，它将selector的method_name作为key，method_imp作为value存储起来，当再次收到selector消息时，可以直接在objc_cache里找到，避免去遍历objc_method_list。
objc_msgSend定义 在runtime中，objc_msgSend的定义如下：
OBJC_EXPORT id objc_msgSend(id self, SEL op, ...) 要了解消息传递机制，首先需要了解类objc_class、对象objc_object、方法objc_method这几个结构体。
//对象 struct objc_object { Class isa OBJC_ISA_AVAILABILITY; }; //类 struct objc_class { Class isa OBJC_ISA_AVAILABILITY; #if !__OBJC2__ Class super_class OBJC2_UNAVAILABLE; const char *name OBJC2_UNAVAILABLE; long version OBJC2_UNAVAILABLE; long info OBJC2_UNAVAILABLE; long instance_size OBJC2_UNAVAILABLE; struct objc_ivar_list *ivars OBJC2_UNAVAILABLE; struct objc_method_list **methodLists OBJC2_UNAVAILABLE; struct objc_cache *cache OBJC2_UNAVAILABLE; struct objc_protocol_list *protocols OBJC2_UNAVAILABLE; #endif} OBJC2_UNAVAILABLE; //方法列表 struct objc_method_list { struct objc_method_list *obsolete OBJC2_UNAVAILABLE; int method_count OBJC2_UNAVAILABLE; #ifdef __LP64__ int space OBJC2_UNAVAILABLE; #endif /* variable length structure */ struct objc_method method_list[1] OBJC2_UNAVAILABLE; } OBJC2_UNAVAILABLE; //方法 struct objc_method { SEL method_name OBJC2_UNAVAILABLE; char *method_types OBJC2_UNAVAILABLE; IMP method_imp OBJC2_UNAVAILABLE; } 类对象objc_class 在OC中，类是由Class类型来表示的，它实际上是一个指向objc_class结构体的指针：
typedef struct objc_class *Class; //Class是一个指向objc_class 的指针 其中objc_class结构体在objc/runtime.h中的定义如下：
struct objc_class { Class _Nonnull isa OBJC_ISA_AVAILABILITY; #if !__OBJC2__ Class _Nullable super_class OBJC2_UNAVAILABLE; // 指向父类的指针  const char * _Nonnull name OBJC2_UNAVAILABLE; // 类的名字  long version OBJC2_UNAVAILABLE; // 类的版本信息，默认为 0  long info OBJC2_UNAVAILABLE; // 类的信息，供运行期使用的一些位标识  long instance_size OBJC2_UNAVAILABLE; // 该类的实例变量大小;  struct objc_ivar_list * _Nullable ivars OBJC2_UNAVAILABLE; // 该类的实例变量列表  struct objc_method_list * _Nullable * _Nullable methodLists OBJC2_UNAVAILABLE; // 方法定义的列表  struct objc_cache * _Nonnull cache OBJC2_UNAVAILABLE; // 方法缓存  struct objc_protocol_list * _Nullable protocols OBJC2_UNAVAILABLE; // 遵守的协议列表 #endif} OBJC2_UNAVAILABLE; 类对象就是一个结构体struct objc_class，这个结构体存放的数据称为元数据(metadata)。该结构体的第一个成员变量也是isa指针，这说明了Class本身其实是一个对象，称之为类对象。类对象在编译期产生用于创建实例对象，是单例。
实例对象(object) 在objc/runtime.h中，对象被定义为指向objc_object结构体的指针，objc_object结构体的定义如下：
//runtime对objc_object结构体的定义 struct objc_object { Class isa OBJC_ISA_AVAILABILITY; //objc_object只有一个成员，就是指向O }; //id是一个指向objc_object结构体的指针： typedef struct objc_object *id; //id是指向objc_class指针的指针 类对象中的元数据存储的都是如何创建一个实例的相关信息，那么类对象和类方法应该从哪里创建呢？就是从isa指针指向的结构体创建，类对象的isa指针指向的我们称之为元类(meatclass)，元类中保存了创建类对象以及类方法所需的所有信息，因此整个结构应该如下图所示:
元类(meta class) 通过上图可以看出整个体系构成了一个自闭环，struct objc_object结构体实例的isa指针指向类对象，类对象的isa指针指向了元类，super_class指针指向了父类的类对象，而元类的super_class指针指向了父类的元类，那元类的isa指针又指向了自己(还不理解为什么会指向自己)。
元类(Meta Class)是一个类对象的类。在上面我们提到，所有的类自身也是一个对象，我们可以向这个对象发送消息(即调用类方法)。为了调用类方法，这个类的isa指针必须指向一个包含这些类方法的一个objc_class结构体。这就引出了meta-class的概念，元类中保存了创建类对象以及类方法所需的所有信息。
任何NSObject继承体系下的meta-class都使用NSObject的meta-class作为自己的所属类，而基类的meta-class的isa指针是指向它自己。
方法(method) 首先看一下objc_method的定义：
runtime.h /// An opaque type that represents a method in a class definition.代表类定义中一个方法的不透明类型 typedef struct objc_method *Method; struct objc_method { SEL method_name OBJC2_UNAVAILABLE; //方法名  char *method_types OBJC2_UNAVAILABLE; //方法类型  IMP method_imp OBJC2_UNAVAILABLE; //方法实现 在objc_method的定义中，可以看到SEL和IMP，这说明SEL和IMP都是方法的属性:
  SEL method_name方法名
  char * method_types 方法类型
  IMP method_imp 方法实现
  SEL方法选择器 ojbc_msgSend函数第二个参数类型为SEL，可以理解为用于区分方法的ID，这个ID的数据结构就是SEL：
在objc/runtime.h,SEL被定义为指向objc_selector结构体的指针：
///objc.h /// An opaque type that represents a method selector.代表一个方法的不透明类型 typedef struct objc_selector *SEL; 而selector是SEL的一个实例：
@property SEL selector; selector的解释为：
A method selector is a C string that has been registered (or “mapped“) with the Objective-C runtime. Selectors generated by the compiler are automatically mapped by the runtime when the class is loaded. 也就是说selector就是个映射到方法的C字符串，可以用OC编译器命令@selector()或者Runtime系统的sel_registerName函数来获得一个SEL类型的方法选择器。
selector既然是一个字符串，应该类似className&#43;method的组合，命名的规则有两条：
  同一个类，selector不能重复
  不同的类，selector可以重复
  这也带来个弊端，就是在写C代码的时候，经常会用到函数重载，就是函数名相同，参数不同。但在OC中行不通，因为selector只记了method的name，没有参数，所以没法区分不同的method。
比如下面代码在OC中是会报错的：
- (void)caculate(NSInteger)num; - (void)caculate(CGFloat)num; 所以只能通过命名来区分：
- (void)caculateWithInt(NSInteger)num; - (void)caculateWithFloat(CGFloat)num; IMP IMP是指向一个方法实现的指针，实质上就是指向最终实现程序的内存地址的指针，它的定义为：
/// A pointer to the function of a method implementation. 指向一个方法实现的指针 typedef id (*IMP)(id, SEL, ...); #endif在iOS的runtime中，方法通过selector和IMP两个属性，实现了快速查询方法及其实现，相对提高了性能，又保持了灵活性。
Objective-C在编译时，会依据每一个方法的名字、参数序列，生成一个唯一的整型标识(Int类型的地址)，这个标识就是SEL
Category(objc_catory) 当Catrgory表示一个指向分类的结构体的指针，它的定义如下：
struct category_t { const char *name; classref_t cls; struct method_list_t *instanceMethods; struct method_list_t *classMethods; struct protocol_list_t *protocols; struct property_list_t *instanceProperties; };   name是class_name而不是category_name。
  cls表示要扩展的类对象，编译期间是不会定义的，而是在Runtime阶段通过name对应到相应的类对象。
  instanceMethods表示category中所有给类添加的实例方法的列表。  classMethods表示category中所有添加的类方法的列表。  protocols 表示category实现的所有协议的列表。
  instanceProperties 表示category里所有的Properties，这就是我们可以通过objc_setAssociatedObject和objc_getAssociatedObject增加实例变量的原因，不过这个和一般的实例变量是不一样的。
  从上面的category_t结构体中可以看出，分类中可以添加实例方法，类方法，甚至可以实现协议，添加属性，不可以添加成员变量。
Runtime消息转发 OC在发送消息时会在相关的类对象中搜索方法列表，如果找不到则会沿着继承树向上一直搜索直到树根部（NSObject），如果还是找不到，那么消息转发就是失败了。此时，会执行doesNotRecognizeSelector:方法，报unrecognized selector错。
动态方法转发 首先，OC运行时会调用&#43;resolveInstanceMethod:或者 &#43;resolveClassMethod:，让你有机会提供一个函数实现。如果添加了函数并返回YES，那运行时系统就会重新启动一次消息发送的过程。
实现一个动态方法解析的例子：
- (void)viewDidLoad { [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib.  //执行foo函数  [self performSelector:@selector(foo:)]; } &#43; (BOOL)resolveInstanceMethod:(SEL)sel { if (sel == @selector(foo:)) {//如果是执行foo函数，就动态解析，指定新的IMP  class_addMethod([self class], sel, (IMP)fooMethod, &amp;#34;v@:&amp;#34;); return YES; } return [super resolveInstanceMethod:sel]; } void fooMethod(id obj, SEL _cmd) { NSLog(@&amp;#34;Doing foo&amp;#34;);//新的foo函数 } 可以看到虽然没有实现foo:这个函数，但是通过class_addMethod动态添加fooMethod函数，并执行fooMethod这个函数的IMP。但如果resolve方法返回NO，运行时就会移到下一步：forwardingTargetForSelector。
备用接收者 如果目标对象实现了-forwardingTargetForSelector:，Runtime这时就会调用这个方法，给你把这个消息转发给其他对象的机会。
实现一个备用接收者：
#import &amp;#34;ViewController.h&amp;#34;#import &amp;#34;objc/runtime.h&amp;#34; @interface Person: NSObject @end @implementation Person - (void)foo { NSLog(@&amp;#34;Doing foo&amp;#34;);//Person的foo函数 } @end @interface ViewController () @end @implementation ViewController - (void)viewDidLoad { [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib.  //执行foo函数  [self performSelector:@selector(foo)]; } &#43; (BOOL)resolveInstanceMethod:(SEL)sel { return NO;//返回NO，进入下一步转发 } - (id)forwardingTargetForSelector:(SEL)aSelector { if (aSelector == @selector(foo)) { return [Person new];//返回Person对象，让Person对象接收这个消息  } return [super forwardingTargetForSelector:aSelector]; } @end 完整消息转发 如果在上一步还不能处理未知消息，则唯一能做的就是启用完整的消息转发机制了。
首先它会发送-methodSignatureForSelector:消息获得函数的参数和返回值类型。如果-methodSignatureForSelector:返回nil，则Runtime则会发出-doesNotRecognizeSelector:消息，程序这时也就挂掉了。如果返回了一个函数签名，Runtime就会创建一个NSInvocation对象并发送 -forwardInvocation:消息给目标对象。
#import &amp;#34;ViewController.h&amp;#34;#import &amp;#34;objc/runtime.h&amp;#34; @interface Person: NSObject @end @implementation Person - (void)foo { NSLog(@&amp;#34;Doing foo&amp;#34;);//Person的foo函数 } @end @interface ViewController () @end @implementation ViewController - (void)viewDidLoad { [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib.  //执行foo函数  [self performSelector:@selector(foo)]; } &#43; (BOOL)resolveInstanceMethod:(SEL)sel { return YES;//返回YES，进入下一步转发 } - (id)forwardingTargetForSelector:(SEL)aSelector { return nil;//返回nil，进入下一步转发 } - (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector { if ([NSStringFromSelector(aSelector) isEqualToString:@&amp;#34;foo&amp;#34;]) { return [NSMethodSignature signatureWithObjCTypes:&amp;#34;v@:&amp;#34;];//签名，进入forwardInvocation  } return [super methodSignatureForSelector:aSelector]; } - (void)forwardInvocation:(NSInvocation *)anInvocation { SEL sel = anInvocation.selector; Person *p = [Person new]; if([p respondsToSelector:sel]) { [anInvocation invokeWithTarget:p]; } else { [self doesNotRecognizeSelector:sel]; } } @end instancetype和id的区别 instancetype和id都可以用来表示任意类型，将对象的类型确定往后推迟，用于体现OC语言的动态性，使其声明的对象具有运行时特性。区别是：
  instancetype只能作为返回值类型，但在编译期instancetype会进行类型检测，因此对于所有返回类的实例的类方法或实例方法，建议返回类型instancetype而不是id。
  id类型既可以作为返回类型，也可以作为参数类型，也可以作为变量类型，但id类型在编译期不会进行类型检测。
  selector selector是一个方法的名字。基于动态绑定环境下，method是一个组合体，包含了名字和实现。可以理解@selector()就是取类方法的编号，他的行为基本可以等同C语言中的函数指针，只不过C语言中，可以把函数名直接赋值给一个函数指针，而OC的类不能直接应用函数指针，这样只能做一个@selector语法来取，它的结果是一个SEL类型。而这个类型本质是类方法的编号（函数地址）。
target-action机制 目标是动作消息的接收者。例# 目标是动作消息的接收者。例目标是动作消息的接收者。例如一个控件，或者更为常见的是它的单元，以插座变量的形式保有其动作的目标。动作是控件发送给目标的消息，或者从目标的角度看，他是目标为了响应动作而实现的方法。程序需要某些机制来进行实践和指令的翻译，这个机制就是目标-动作机制。
Runtime的应用 Runtime的应用场景有很多，常见的如下：
  关联对象(Objective-C Associated Objects)，给分类添加属性
  方法魔法(Method Swizzling),添加和替换KVO实现
  实现NSCoding的自动归档和自动解档
  实现字典和模型的自动转换(MJExtension)
  关联对象 在OC中分类是不能自定义属性和变量的，但是可以通过关联对象实现给分类添加属性。Runtime给关联对象添加了以下几个接口：
3个接口 //关联对象 void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy) //获取关联的对象 id objc_getAssociatedObject(id object, const void *key) //移除关联的对象 void objc_removeAssociatedObjects(id object) 参数解释 id object：被关联的对象 const void *key：关联的key，要求唯一 id value：关联的对象 objc_AssociationPolicy policy：内存管理的策略 内存管理策略的定义：
typedef OBJC_ENUM(uintptr_t, objc_AssociationPolicy) { OBJC_ASSOCIATION_ASSIGN = 0, /**&amp;lt; Specifies a weak reference to the associated object. */ OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1, /**&amp;lt; Specifies a strong reference to the associated object. * The association is not made atomically. */ OBJC_ASSOCIATION_COPY_NONATOMIC = 3, /**&amp;lt; Specifies that the associated object is copied. * The association is not made atomically. */ OBJC_ASSOCIATION_RETAIN = 01401, /**&amp;lt; Specifies a strong reference to the associated object. * The association is made atomically. */ OBJC_ASSOCIATION_COPY = 01403 /**&amp;lt; Specifies that the associated object is copied. * The association is made atomically. */ }; 内存分配各个值的含义如下所示： 下面是OC中下实现一个UIView的Category添加自定义属性defaultColor：
#import &amp;#34;ViewController.h&amp;#34;#import &amp;#34;objc/runtime.h&amp;#34; @interface UIView (DefaultColor) @property (nonatomic, strong) UIColor *defaultColor; @end @implementation UIView (DefaultColor) @dynamic defaultColor; static char kDefaultColorKey; - (void)setDefaultColor:(UIColor *)defaultColor { objc_setAssociatedObject(self, &amp;amp;kDefaultColorKey, defaultColor, OBJC_ASSOCIATION_RETAIN_NONATOMIC); } - (id)defaultColor { return objc_getAssociatedObject(self, &amp;amp;kDefaultColorKey); } @end @interface ViewController () @end @implementation ViewController - (void)viewDidLoad { [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib.  UIView *test = [UIView new]; test.defaultColor = [UIColor blackColor]; NSLog(@&amp;#34;%@&amp;#34;, test.defaultColor); } @end 在Swift中是按如下使用方法使用的：
extension NSObject { func setAssociated&amp;lt;T&amp;gt;(value: T, associatedKey: UnsafeRawPointer, policy: objc_AssociationPolicy = objc_AssociationPolicy.OBJC_ASSOCIATION_RETAIN_NONATOMIC) -&amp;gt; Void { objc_setAssociatedObject(self, associatedKey, value, policy) } func getAssociated&amp;lt;T&amp;gt;(associatedKey: UnsafeRawPointer) -&amp;gt; T? { let value = objc_getAssociatedObject(self, associatedKey) as? T return value } } Method Swizzling 方法添加 添加方法的实际上在上面的消息转发机制中已经提到了，其函数定义为：
//class_addMethod(Class _Nullable __unsafe_unretained cls, SEL _Nonnull name, IMP _Nonnull imp, const char * _Nullable types) class_addMethod([self class], sel, (IMP)fooMethod, &amp;#34;v@:&amp;#34;); 其中，参数的解释如下：
 cls表示被添加的类 name添加的方法的名称SEL imp方法的实现，该函数必须至少有两个参数self,_cmd  方法替换 下面OC代码实现替换ViewController的viewDidLoad方法：
@implementation ViewController &#43; (void)load { static dispatch_once_t onceToken; dispatch_once(&amp;amp;onceToken, ^{ Class class = [self class]; SEL originalSelector = @selector(viewDidLoad); SEL swizzledSelector = @selector(jkviewDidLoad); Method originalMethod = class_getInstanceMethod(class,originalSelector); Method swizzledMethod = class_getInstanceMethod(class,swizzledSelector); //judge the method named swizzledMethod is already existed.  BOOL didAddMethod = class_addMethod(class, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod)); // if swizzledMethod is already existed.  if (didAddMethod) { class_replaceMethod(class, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod)); } else { method_exchangeImplementations(originalMethod, swizzledMethod); } }); } - (void)jkviewDidLoad { NSLog(@&amp;#34;替换的方法&amp;#34;); [self jkviewDidLoad]; } - (void)viewDidLoad { NSLog(@&amp;#34;自带的方法&amp;#34;); [super viewDidLoad]; } @end OC的swizzling应该只在&#43;load中完成。在OC的Runtime中，每个类有两个方法都会自动调用。&#43;load是在一个类被初始装载时调用，&#43;initialize是在应用第一次调用该类的类方法或实例方法前调用的。两个方法都是可选的，并且只有在方法被实现的情况下才会被调用。
swizzling应该只在dispatch_once中完成，由于swizzling改变了全局的状态，所以我们需要确保每个预防措施在运行时都是可用的。原子操作就是这样一个用于确保代码只会被执行一次的预防措施，就算是在不同的线程中也能确保代码只执行一次。Grand Central Dispatch的dispatch_once满足了所需要的需求，并且应该被当做使用swizzling的初始化单例方法的标准。
在上图中，通过Swizzling特性，将selectorC的方法实现IMPc与selectorN的方法实现IMPn交换了，当调用selectorC，也就是给对象发送selectorC消息时，所查找到的方法实现就是IMPn而不是IMPc了。
KVO实现 KVO的全称是Key-value observing，译为键值观察。提供了一种当其它对象属性被修改的时候能通知当前对象的机制。再MVC大行其道的Cocoa中，KVO机制很适合实现model和controller类之间的通信。
KVO的实现依赖于OC强大的Runtime，当观察某对象A时，KVO机制动态创建一个对象A当前类的子类，并为这个新的子类重写了被观察属性keyPath的setter方法。setter方法随后负责通知观察对象属性的改变状况。
Apple使用了isa-swizzling来实现KVO。当观察对象A时，KVO机制动态创建一个新的名为：NSKVONotifying_A的新类，该类继承自对象A的本类，且KVO为 NSKVONotifying_A重写观察属性的setter方法，setter方法会负责在调用原setter方法之前和之后，通知所有观察对象属性值的更改情况。
NSKVONotifying_A类剖析：
NSLog(@&amp;#34;self-&amp;gt;isa:%@&amp;#34;,self-&amp;gt;isa); NSLog(@&amp;#34;self class:%@&amp;#34;,[self class]); 在建立KVO监听前，打印结果为：
self-&amp;gt;isa:A self class:A 在建立KVO监听之后，打印结果为：
self-&amp;gt;isa:NSKVONotifying_A self class:A 在这个过程，被观察对象的isa指针从指向原来的A类，被KVO机制修改为指向系统新创建的子类NSKVONotifying_A类，来实现当前类属性值改变的监听；
所以当我们从应用层面上看来，完全没有意识到有新的类出现，这是系统隐瞒了对KVO的底层实现过程，让我们误以为还是原来的类。但是此时如果我们创建一个新的名为NSKVONotifying_A的类，就会发现系统运行到注册KVO的那段代码时程序就崩溃，因为系统在注册监听的时候动态创建了名为NSKVONotifying_A的中间类，并指向这个中间类了。
子类setter方法剖析：
KVO的键值观察通知依赖于NSObject的两个方法willChangeValueForKey:和 didChangeValueForKey:，在存取数值的前后分别调用2个方法：被观察属性发生改变之前，willChangeValueForKey:被调用，通知系统该keyPath的属性值即将变更； 当改变发生后，didChangeValueForKey:被调用，通知系统该keyPath的属性值已经变更；之后，observeValueForKey:ofObject:change:context:也会被调用。且重写观察属性的setter方法这种继承方式的注入是在运行时而不是编译时实现的。
KVO为子类的观察者属性重写调用存取方法的工作原理在代码中相当于：
- (void)setName:(NSString *)newName { [self willChangeValueForKey:@&amp;#34;name&amp;#34;]; //KVO 在调用存取方法之前总调用  [super setValue:newName forKey:@&amp;#34;name&amp;#34;]; //调用父类的存取方法  [self didChangeValueForKey:@&amp;#34;name&amp;#34;]; //KVO 在调用存取方法之后总调用 } 热更新JSPatch JSPatch是一个iOS动态更新框架，只需在项目中引入极小的引擎，就可以使用 JavaScript调用任何OC原生接口，获得脚本语言的优势：为项目动态添加模块，或替换项目原生代码动态修复bug。
关于消息转发，前面已经讲到过了，消息转发分为三级，我们可以在每级实现替换功能，实现消息转发，从而不会造成崩溃。JSPatch不仅能够实现消息转发，还可以实现方法添加、替换等一系列功能。
实现NSCoding的自动归档和自动解档 用Runtime提供的函数遍历Model自身所有属性，并对属性进行encode和decode操作。 核心方法：在Model的基类中重写方法：
- (id)initWithCoder:(NSCoder *)aDecoder { if (self = [super init]) { unsigned int outCount; Ivar * ivars = class_copyIvarList([self class], &amp;amp;outCount); for (int i = 0; i &amp;lt; outCount; i &#43;&#43;) { Ivar ivar = ivars[i]; NSString * key = [NSString stringWithUTF8String:ivar_getName(ivar)]; [self setValue:[aDecoder decodeObjectForKey:key] forKey:key]; } } return self; } - (void)encodeWithCoder:(NSCoder *)aCoder { unsigned int outCount; Ivar * ivars = class_copyIvarList([self class], &amp;amp;outCount); for (int i = 0; i &amp;lt; outCount; i &#43;&#43;) { Ivar ivar = ivars[i]; NSString * key = [NSString stringWithUTF8String:ivar_getName(ivar)]; [aCoder encodeObject:[self valueForKey:key] forKey:key]; } } 实现字典和模型的自动转换(MJExtension) 用runtime提供的函数遍历Model自身所有属性，如果属性在json中有对应的值，则将其赋值。 核心方法：在NSObject的分类中添加方法。
- (instancetype)initWithDict:(NSDictionary *)dict { if (self = [self init]) { //(1)获取类的属性及属性对应的类型  NSMutableArray * keys = [NSMutableArray array]; NSMutableArray * attributes = [NSMutableArray array]; /* * 例子 * name = value3 attribute = T@&amp;#34;NSString&amp;#34;,C,N,V_value3 * name = value4 attribute = T^i,N,V_value4 */ unsigned int outCount; objc_property_t * properties = class_copyPropertyList([self class], &amp;amp;outCount); for (int i = 0; i &amp;lt; outCount; i &#43;&#43;) { objc_property_t property = properties[i]; //通过property_getName函数获得属性的名字  NSString * propertyName = [NSString stringWithCString:property_getName(property) encoding:NSUTF8StringEncoding]; [keys addObject:propertyName]; //通过property_getAttributes函数可以获得属性的名字和@encode编码  NSString * propertyAttribute = [NSString stringWithCString:property_getAttributes(property) encoding:NSUTF8StringEncoding]; [attributes addObject:propertyAttribute]; } //立即释放properties指向的内存  free(properties); //(2)根据类型给属性赋值  for (NSString * key in keys) { if ([dict valueForKey:key] == nil) continue; [self setValue:[dict valueForKey:key] forKey:key]; } } return self; } 参考资料 参考资料 参考资料
</content>
    </entry>
    
     <entry>
        <title>陈小厨作品集</title>
        <url>https://iihui.github.io/post/food-2020/</url>
        <categories>
          <category>美食</category>
        </categories>
        <tags>
          <tag>美食</tag>
        </tags>
        <content type="html">  2020年给自己定了些年度目标，用心下厨是其中一项。我是一个喜欢倒腾吃的人，每次看到自己做的东西既美味又有颜值的时候，总会很开心，但多数时候都忘了记录大致的步骤和拍照留存，2020年想给自己多留点值得回忆的东西，故以此为记。
 二月作品 猪血丸子、腊肉炒辣椒（猪血丸子先整个煮，再用冷水冷却，趁热切片，再放油小火煎，随后放佐料和辣椒中火翻炒）
花仙子桂花汤圆、湾仔码头水晶汤圆（烧开水再放汤圆，再小火慢煮，水开之后加一杯冷水，再开之后再加一杯冷水，然后煮到下面样子的时候捞出来）
萝卜和土豆炖牛腩和排骨（牛腩和排骨先煮，然后捞出来，洗干净，再和土豆萝卜一起放电饭煲里炖，炖差不多一个半小时）
排骨炖土豆（首先将排骨洗净，然后在放锅里煮，煮熟之后捞出来晾干，这一步主要是去浮沫，然后再放油煎一下排骨，煎完之后放土豆炒，之后放水煮即可，）
西兰花炒肉（首先将西兰花焯水，注意千万不要太久，然后炒肉，肉炒得差不多的时候放西兰花，再炒一段时间，炒得时间千万不要过长） 清炒胡萝卜（炒胡萝卜最关键的是切胡萝丝，一定要有耐心，厚度尽量保持一致，炒的时候不要太要太久，葱花最后要起锅的时候放）
炒长豆角丁（肉应该选那种肥瘦相间的，切成肉沫，肉沫应该先单独炒，放一些酸辣椒或者橄榄菜或许更好）
青椒炒肉(先炒肉，炒熟之后，再放姜蒜和小米椒大火炒几秒钟，再放青椒，翻炒一小会，最后和肉一起炒，临近起锅的时候放些生抽味道会更好)
早餐面（面上是卤豆腐，牛腩，腊猪血丸子）
</content>
    </entry>
    
     <entry>
        <title>macOS 安装Homebrew 报错</title>
        <url>https://iihui.github.io/post/qa_install_brew/</url>
        <categories>
          <category>QA</category>
        </categories>
        <tags>
          <tag>QA</tag>
        </tags>
        <content type="html">  重装了macOS Catalina 10.15.2，但使用/usr/bin/ruby -e &amp;quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&amp;quot;安装Homebrew时报curl: (7) Failed to connect to raw.githubusercontent.com port 443: Connection refused错误，网上大多数说要设置代理，但于我而言没有任何效果。翻了一圈资料，猜测是系统的curl有问题，按照这个思路，首先应该使用另一种方式安装Homebrew，然后再利用Homebrew安装curl，最后设置Homebrew安装的curl优先级高于系统的curl。
 安装Homebrew 首先在浏览器中打开https://raw.githubusercontent.com/Homebrew/install/master/install。若不能打开，就是网络问题；如果能打开就如下图所示：
然后将这个网页的内容复制粘贴保存，并命名为brew_install.rb。再再终端中输入curl命令，如果出现curl: try &#39;curl --help&#39; or &#39;curl --manual&#39; for more information则表示curl本身没有问题：
接着在终端跳转到保存brew_install.rb的目录下，输入命令ruby brew_install.rb，以完成安装Homebrew。
安装并启用新curl 当上一步提示安装成功之后，则可以通过Homebrew安装curl，即在终端输入brew install curl，安装成功之后，如果在终端通过sh -c &amp;quot;$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&amp;quot;命令安装oh my zsh 依然会报错curl: (35) Server aborted the SSL handshake 错误，这是因为brew安装的curl的优先级低于系统的。
接着就需要将Homebrew安装的curl的优先级调高，使其高于系统的curl，使用命令 brew link curl --force会提示 按照上面的提示，首先执行echo &#39;export PATH=&amp;quot;/usr/local/opt/curl/bin:$PATH&amp;quot;&#39; &amp;gt;&amp;gt; ~/.zshrc 然后将export LDFLAGS=&amp;quot;-L/usr/local/opt/curl/lib&amp;quot;和export CPPFLAGS=&amp;quot;-I/usr/local/opt/curl/include&amp;quot;放到.zshrc（我用的zsh，如果用户的是其他shell则修改对应的配置文件）中，至此问题解决。
参考资料 参考资料
</content>
    </entry>
    
     <entry>
        <title>Almofire的使用</title>
        <url>https://iihui.github.io/post/ios-alamofire/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html">  如果使用过OC进行开发，那么知道AFNetworking这个网络操作库。Mattt Thompson作为AFNetworking的发起人，又基于Swift语言开发了一个新的网络操作库 Alamofire。Alamofire的优雅之处在于它完完全全是由Swift写成的，并且没有从AFNetworking那里继承任何特性。Alamofire网络库适用于iOS和macOS，它提供了链式request/response方法，JSON的传参和响应序列化，身份认证和其他特性。
 上传 func upLoadStaticsFile(){ do { guard let sessionID = userInfoService.activeUser?.sessionID, let sessionIDSM = userInfoService.activeUse return } let parameters = [&amp;#34;sessionID&amp;#34;: sessionID] let formatter = DateFormatter() formatter.dateFormat = &amp;#34;yyyy-MM-dd HH:mm:ss&amp;#34; let temName = &amp;#34;\(formatter.string(from: Date()))-\(deviceID).txt&amp;#34; let temPath = self.statisticsDir.path.stringByAppendingPathComponent(temName) let path = self.statisticsDir.path.stringByAppendingPathComponent(fileName) try FileManager.default.moveItem(atPath: path, toPath: temPath) //遍历埋点文件夹下的埋点数据文件,以获取 let fileList = try FileManager.default.contentsOfDirectory(atPath: statisticsDir.path) let needUploadFileList = fileList.filter { $0 != self.fileName } for file in needUploadFileList { let path = self.statisticsDir.path.stringByAppendingPathComponent(file) let dataURL = URL(fileURLWithPath: path) let data = try Data(contentsOf: dataURL) self.uploadFile(data: data, parameters: parameters, file: file, path: path) } } catch let error as NSError { log.error(error.localizedDescription) } } private func uploadFile(data: Data, parameters: [String: String], file: String, path: String) { Alamofire.upload(multipartFormData: { multipartFormData in multipartFormData.append(data, withName: &amp;#34;file&amp;#34;, fileName: file, mimeType: &amp;#34;text/plain&amp;#34;) for (key, value) in parameters { if let valueData = value.data(using: .utf8) { multipartFormData.append(valueData, withName: key) } } }, to: addreess, method: .post) { result in switch result { case .success: do { try FileManager.default.removeItem(atPath: path) } catch let error as NSError { log.error(error.localizedDescription) } case let .failure(error): log.error(error.localizedDescription) } } } 下载 func requestScreenImage(url:String,completionHandler:@escaping (_ :Data?) -&amp;gt;Void){ Alamofire.request(url, method: .get).response { response in if response.error == nil{ completionHandler(response.data) }else{ completionHandler(nil) } } } func requestImage(url: String, completionHandler: @escaping (_ image: UIImage?) -&amp;gt; Void) { self.tokenHttpController.requestLoginDataAndToken(type: .base64, success: { (data, token) in let data = data?.extStringByUrlEncode ?? &amp;#34;&amp;#34; let token = token?.extStringByUrlEncode ?? &amp;#34;&amp;#34; let header: HTTPHeaders = [ &amp;#34;data&amp;#34;: data, &amp;#34;token&amp;#34;: token ] Alamofire.request(url, method: .get, headers: header).response { (response) in if let data = response.data { let image = UIImage(data: data) completionHandler(image) }else{ completionHandler(nil) } } }) { completionHandler(nil) } } func requestScreenADConfigInfo(completionHandler:@escaping (JSON) -&amp;gt; Void){ let url = ConfigRequestUrl let op = ConfigRequestAction.getScreenPictureInfo let meta = getDefaultMetaData(op) var data = [String:String]() if let model = ScreenADConfigDBRepository.Instance.getScreenConfigModel(),let jsonStr = model.screenConfigJsonStr{ if let dataJson = jsonStr.data(using: String.Encoding.utf8) { do{ let json = try JSON(data:dataJson) data[&amp;#34;configHash&amp;#34;] = json[&amp;#34;configHash&amp;#34;].stringValue }catch{ data[&amp;#34;configHash&amp;#34;] = &amp;#34;&amp;#34; } } }else{ data[&amp;#34;configHash&amp;#34;] = &amp;#34;&amp;#34; } switch UIDevice.current.userInterfaceIdiom{ case .pad: data[&amp;#34;type&amp;#34;] = &amp;#34;Pad&amp;#34; case .phone: data[&amp;#34;type&amp;#34;] = &amp;#34;Phone&amp;#34; default:break } var bodyData = [String:Any]() bodyData[&amp;#34;meta&amp;#34;] = meta bodyData[&amp;#34;data&amp;#34;] = data Alamofire.request(url, method: .post, parameters: bodyData,encoding: JSONEncoding.default).responseJSON{ response in switch response.result{ case .success(let value): let json = JSON(value) let subJSON = json[&amp;#34;data&amp;#34;] let retCode = subJSON[&amp;#34;retCode&amp;#34;].stringValue //retCode为1表示有更新，0表示没有更新，其它表示出错 switch retCode{ case &amp;#34;1&amp;#34;: completionHandler(subJSON) case &amp;#34;0&amp;#34;: break default: let msg = subJSON[&amp;#34;retMsg&amp;#34;].stringValue DPrint(msg) } case .failure(let error): Dprint(error.localizedDescription) } } } func bindUserDevice(with model: LoginUserModel, and existUsers: ExistUsers, block: @escaping (_ model: UserInfoModel?, _ errorMsg: String?) -&amp;gt; Void) { var dataDic = Dictionary&amp;lt;String, String&amp;gt;() dataDic[&amp;#34;rand&amp;#34;] = UUID().uuidString var metaDic = self.getDefaultMetaDic(forAction: ConfigRequestAction.bindUserDeviceV2) metaDic[&amp;#34;ystID&amp;#34;] = model.ystId metaDic[&amp;#34;sapID&amp;#34;] = model.sapId metaDic[&amp;#34;inuseID&amp;#34;] = model.inUseId let parameters = self.getRequestPostParameters(metaDic: metaDic, dataDic: dataDic) Alamofire.request(ConfigRequestMoUrl, method: .post, parameters: parameters, encoding: JSONEncoding.default, headers: nil).responseJSON { (response) in switch response.result { case .success(let value): let json = JSON(value) if let retCode = json[&amp;#34;data&amp;#34;][&amp;#34;retCode&amp;#34;].string, retCode == &amp;#34;0&amp;#34; { let model = UserInfoModel(from: json[&amp;#34;data&amp;#34;]) block(model, nil) } else { block(nil, json[&amp;#34;data&amp;#34;][&amp;#34;retMsg&amp;#34;].stringValue) } case .failure(_): block(nil, &amp;#34;network is poor&amp;#34;) } } }  参考资料 参考资料 对比
</content>
    </entry>
    
     <entry>
        <title>贵州之行</title>
        <url>https://iihui.github.io/post/travel-guizhou/</url>
        <categories>
          <category>旅行</category>
        </categories>
        <tags>
          <tag>旅行</tag><tag>贵州</tag>
        </tags>
        <content type="html"> 黄果树瀑布景区 娄山关 外伶仃岛 </content>
    </entry>
    
     <entry>
        <title>第三方库放到Cocoapods中</title>
        <url>https://iihui.github.io/post/ios-cocoapods-storage/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html">  项目需要引入百度语音合成SDK，但这个第三方库的.a文件过于庞大，按规定不能直接放到项目中，需要放到Cocoapods仓库中，然后在项目中依赖一下即可。用已有的模板，只要按照要求修改对应文件，然后执行相应命令即可，这一过程可以总结为5步。
 第一步 首先修改.podspec文件。为了修改.podspec文件，首先必须创建第三方库目录。下图为第三方库存放的目录结构，如需新建一个第三方库目录，则选中任意一个拷贝一份:
拷贝完了之后修改下图中长方形内文件或者文件夹(共3处)的名字，然后删除下图椭圆内的文件：
这里我将上图的那个副本重命名为BaiduTest，修改上面的3个地方和和删除文件后如下图所示:
然后修改.podspec文件，这个文件的修改必须使用终端文本编辑器（我使用vim编辑器），否则可能出错，这个文件也有三个地方需要修改。
第一个地方 首先修改s.name,s.version,s.summary,s.description这四个地方，其中s.name保持为上面修改的名字，版本号为0.0.1：
第二个地方 接下来修改s.homepage,只要将最后的名字修改为BaiduTest:
第三个地方 最后修改s.source,将后面两项修改即可，这两项的名字要和s.name和s.version保持一致:
 第二步 第二步修改push.py,目的是将LC10_01_BaiduTest这个目录打包并上传到仓库中，这个文件要修改两处:
第一个地方 将zipCommands后面的名字改为LC10_01_BaiduTest：
第二个地方 将uploadCommand命令后打包的目录和打包后的文件的名字改成LC10_01_BaiduTest：
 第三步 第三步执行push.py，即转到push.py脚本所在目录执行./push.py即可
第四步 修改工程所使用的podfile，添加LC10_01_BaiduTest：
 第五步 第五步是在工程目录下依次执行下面2条命令:
  pod repo-art update CocoaPods-cmb
  pod update
   </content>
    </entry>
    
     <entry>
        <title>引入百度语音合成</title>
        <url>https://iihui.github.io/post/ios-synthesizer/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html">  项目中需要用百度语音合成SDK，因此自己先建了一个工程作为引入测试一下，总结下来为准备&amp;ndash;&amp;gt;导入&amp;ndash;&amp;gt;创建应用&amp;ndash;&amp;gt;测试。
 准备 首先从百度官网下载百度语音合成的SDK,如下图所示首先在左边选择语音合成，然后在右边选择iOS版的离在线融合SDK:
导入 有两部分需要导入，第一部分是导入百度语音合成所需的文件，第二部分是导入百度语音合成依赖的框架，下面分别讲解：
导入文件夹 接着新建一个测试工程，并将下载到的SDK解压，将下面的3个文件夹导入到项目中，3个文件夹的名称如下图所示:
 导入框架 百度语音依赖如下红框里标识的framework，因此需要在TARGETS--&amp;gt;Build Phases-&amp;gt;LikBinary With Libraries中将这些framework导入到项目中：
创建应用 要使用百度语音合成，首先需要创建相关的应用，而创建应用的前提是有百度云帐号。注册好百度云帐号之后登录，在控制台选择百度语音：
然后选择创建百度语音应用：
接着填写相关信息，要注意的是语音包名要与测试工程的Bundle Identifier一致（称为绑定），才可以使用百度语音合成的离在线模式:
 测试代码 import UIKit let APP_ID = &amp;#34;XXXXX&amp;#34; let API_KEY = &amp;#34;XXXXX&amp;#34; let SECRET_KEY = &amp;#34;XXXXX&amp;#34; class ViewController: UIViewController, BDSSpeechSynthesizerDelegate { fileprivate var synthesiser: BDSSpeechSynthesizer = BDSSpeechSynthesizer.sharedInstance() @IBOutlet weak var synthesisButton: UIButton! @IBOutlet weak var textView: UITextView! @IBOutlet weak var offlineSwitch: UISwitch! override func viewDidLoad() { super.viewDidLoad() BDSSpeechSynthesizer.setLogLevel(BDS_PUBLIC_LOG_VERBOSE) self.synthesiser.setSynthesizerDelegate(self) self.textView.delegate = self self.configOffline() } @IBAction func clickedSynthesis(_ sender: UIButton) { if let sentence = self.textView.text { self.synthesiser.speakSentence(sentence, withError: nil) } } @IBAction func offlineSwitchClicked(_ sender: UISwitch) { if sender.isOn { self.configOffline() } else { self.configOnline() } } func configOnline() { self.synthesiser.setApiKey(API_KEY, withSecretKey: SECRET_KEY) var error = self.synthesiser.setSynthParam(4, for: BDS_SYNTHESIZER_PARAM_PITCH) if let err = error { print(err.localizedDescription) } error = self.synthesiser.setSynthParam(5, for: BDS_SYNTHESIZER_PARAM_SPEED) if let err = error { print(err.localizedDescription) } error = self.synthesiser.setSynthParam(9, for: BDS_SYNTHESIZER_PARAM_VOLUME) if let err = error { print(err.localizedDescription) } self.synthesiser.unloadDomainDataFromOfflineEngine() } func configOffline() { let offlineEngineSpeechData = Bundle.main.path(forResource: &amp;#34;Chinese_And_English_Speech_Female&amp;#34;, ofType: &amp;#34;dat&amp;#34;) let offlineChineseAndEnglishTextData = Bundle.main.path(forResource: &amp;#34;Chinese_And_English_Text&amp;#34;, ofType: &amp;#34;dat&amp;#34;) let error = self.synthesiser.loadOfflineEngine(offlineChineseAndEnglishTextData, speechDataPath: offlineEngineSpeechData, licenseFilePath: nil, withAppCode: APP_ID) if let err = error { print(err.localizedDescription) } } func synthesizerNewDataArrived(_ newData: Data!, dataFormat fmt: BDSAudioFormat, characterCount newLength: Int32, sentenceNumber SynthesizeSentence: Int) { } func synthesizerErrorOccurred(_ error: Error!, speaking SpeakSentence: Int, synthesizing SynthesizeSentence: Int) { print(error.localizedDescription) } override func viewDidDisappear(_ animated: Bool) { super.viewDidDisappear(animated) self.synthesiser.speakSentence(&amp;#34;进入后台&amp;#34;, withError: nil) } } extension ViewController: UITextViewDelegate { func textViewDidChange(_ textView: UITextView) { if let text = textView.text { //self.synthesiser?.speakSentence(text,withError:nil) print(text) } } }  参考资料
</content>
    </entry>
    
     <entry>
        <title>H5视频播放</title>
        <url>https://iihui.github.io/post/ios-html-player/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html">  近期APP出现了在iPhone上拍的视频，同步到Android手机后播放不了的问题，第一直觉应该是iPhone上录制视频所使用的编码不兼容Android。经过沟通，了解到播放视频是用H5嵌入的，因为手边没有视频播放源码和可测试的Android设备，为了验证我的猜测，尝试着先改变iPhone录制视频时的编码方式，然后写一段播放视频的H5，用Chrome浏览器进行测试。
 确认编码 首先找到视频输出的编码方式，通过对比iOS 11.3，iOS 12.0以及iOS 12.01发现默认的输出编码格式从avc1变成了hcv1：
对应的代码如下：
if self.captureSession.canAddOutput(self.captureMovieFileOutput) { self.captureSession.addOutput(self.captureMovieFileOutput) if let outPutConnection = self.captureMovieFileOutput.connection(withMediaType:AVMediaTypeVideo){ let out = self.captureMovieFileOutput.outputSettings(for: outPutConnection) } }  改变编码 因此需要显式指定视频的输出编码格式，而不是使用之前的默认编码格式，代码片段如下：
if self.captureSession.canAddOutput(self.captureMovieFileOutput) { self.captureSession.addOutput(self.captureMovieFileOutput) if let outPutConnection = self.captureMovieFileOutput.connection(withMediaType:AVMediaTypeVideo){ if #available(iOS 10.0, *){ let outputSettings = [AVVideoCodecKey:AVVideoCodecH264] self.captureMovieFileOutput.setOutputSettings(outputSettings, for: outPutConnection) //letout=self.captureMovieFileOutput.outputSettings(for:outPutConnection) } } } 播放代码 为了测试改变编码后生成的视频文件能否在Chrome浏览器中播放，需要写出相应的H5播放代码，如下所示：
&amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;#34;utf-8&amp;#34; /&amp;gt; &amp;lt;meta http-equiv=&amp;#34;X-UA-Compatible&amp;#34; content=&amp;#34;IE=edge&amp;#34;&amp;gt; &amp;lt;title&amp;gt;Page Title&amp;lt;/title&amp;gt; &amp;lt;meta name=&amp;#34;viewport&amp;#34; content=&amp;#34;width=device-width, initial-scale=1&amp;#34;&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;video id=&amp;#34;video&amp;#34; src=&amp;#34;video13.mp4&amp;#34; controls = &amp;#34;true&amp;#34; poster=&amp;#34;images.jpg&amp;#34; /*视频封面*/ preload=&amp;#34;auto&amp;#34; webkit-playsinline=&amp;#34;true&amp;#34; /*这个属性是ios 10中设置可以 让视频在小窗内播放，也就是不是全屏播放*/ playsinline=&amp;#34;true&amp;#34; /*IOS微信浏览器支持小窗内播放*/ x-webkit-airplay=&amp;#34;allow&amp;#34; x5-video-player-type=&amp;#34;h5&amp;#34; /*启用H5播放器,是wechat安卓版特性*/ x5-video-player-fullscreen=&amp;#34;true&amp;#34; /*全屏设置， 设置为 true 是防止横屏*/ x5-video-orientation=&amp;#34;portraint&amp;#34; //播放器支付的方向， landscape横屏，portraint竖屏，默认值为竖屏 &amp;lt;/video&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; 然后发现使用这段代码在修改编码之前不可播放视频，修改编码之后可以播放相应的视频。最后在找到Android测试机发现也是可以的，至此问题解决。
 </content>
    </entry>
    
     <entry>
        <title>半透明的悬浮提示窗</title>
        <url>https://iihui.github.io/post/ios-alert-window/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html">  项目中需要一个悬浮提示窗，从网上找到一篇以OC为示例的文章，因为公司项目是Swift写的，因此需要将OC转为Swift。
 OC代码 .h文件 //CustomAlertWindow.h #import &amp;lt;UIKit/UIKit.h&amp;gt;typedef NS_ENUM(NSInteger, AlertWindowPositionOption) { AlertWindowPositionTopMiddle = 0, AlertWindowPositionCenter, AlertWindowPositionBottomMiddle }; @interface CustomAlertWindow : UIWindow &#43; (instancetype)aletWindowWithPositionOption:(AlertWindowPositionOption)positionType andInfoText:(NSString *)text; //显示 - (void)show; // 消失 - (void)dismiss; @end .m文件 //CustomAlertWindow.m  #import &amp;#34;CustomAlertWindow.h&amp;#34; #define LABEL_MARGIN 10 //Label的外边距 #define CENTER_Y_TO_EDGE 80 //悬浮窗中心点距边缘的纵坐标值  @implementation CustomAlertWindow &#43; (instancetype)aletWindowWithPositionOption:(AlertWindowPositionOption)positionType andInfoText:(NSString *)text { return [[CustomAlertWindow alloc] initWithPositionOption:positionType andInfoText:text]; } - (instancetype)initWithPositionOption:(AlertWindowPositionOption)positionType andInfoText:(NSString *)text { self = [super init]; if (self) { UILabel *infoLabel = [[UILabel alloc] initWithFrame:CGRectMake(0, 0, 40, 15)]; infoLabel.text = text; infoLabel.textAlignment = NSTextAlignmentCenter; infoLabel.font = [UIFont systemFontOfSize:13]; infoLabel.textColor = [UIColor whiteColor]; //label尺寸适应文字大小  [infoLabel sizeToFit]; //根据labelSize确定window的大小  CGSize labelSize = infoLabel.frame.size; CGSize windowSize = CGSizeMake(labelSize.width &#43; 2*LABEL_MARGIN, labelSize.height &#43; 2*LABEL_MARGIN); //根据window的尺寸确定label的中心点位置  infoLabel.center = CGPointMake(windowSize.width / 2, windowSize.height / 2); //得到屏幕的尺寸  CGRect superRect = [[UIScreen mainScreen] bounds]; CGSize superSize = superRect.size; //计算window的大小  self.frame = CGRectMake((superSize.width - windowSize.width) / 2, 0, windowSize.width, windowSize.height); //根据指定的positionType设置window的center  switch (positionType) { case AlertWindowPositionTopMiddle: self.center = CGPointMake(superSize.width / 2, CENTER_Y_TO_EDGE); break; case AlertWindowPositionCenter: self.center = CGPointMake(superSize.width / 2, superSize.height / 2); break; case AlertWindowPositionBottomMiddle: self.center = CGPointMake(superSize.width / 2, superSize.height - CENTER_Y_TO_EDGE); break; default: break; } self.windowLevel = UIWindowLevelAlert &#43; 1; self.backgroundColor = [UIColor colorWithRed:64 / 255.0 green:64 / 255.0 blue:64 / 255.0 alpha:0.7]; self.layer.cornerRadius = 5; [self addSubview:infoLabel]; } return self; } //显示window - (void)show { [self makeKeyAndVisible]; } //window消失 - (void)dismiss { [self resignKeyWindow]; } @end  Swift实现 根据上面的OC代码，将其改造为Swift代码：
import Foundation //参考自https://www.jianshu.com/p/e31eeb26cdce enum positionStyle: Int { case TopMiddle = 0 case Center = 1 case BottomMiddle = 2 } class NoteAlertWindow: UIWindow { fileprivate var style = positionStyle.TopMiddle fileprivate var infoLabel: UILabel? fileprivate var labelMargin: CGFloat = 10 fileprivate var centerYToEdge: CGFloat = 80 required init?(coder aDecoder: NSCoder) { super.init(coder: aDecoder) } init(option: positionStyle, text: String) { let frame = CGRect() super.init(frame: frame) self.style = option if self.infoLabel == nil { self.infoLabel = UILabel(frame: CGRect(x: 0, y: 0, width: 30, height: 15)) adjustWindow(message: text) self.addSubview(self.infoLabel!) } } func show() { self.makeKeyAndVisible() } func dismiss() { self.resignKey() } func moveCenter(center: CGPoint) { self.center = center } func setMessage(text: String) { adjustWindow(message: text) } fileprivate func adjustWindow(message: String) { self.infoLabel?.text = message self.infoLabel?.textAlignment = .center self.infoLabel?.font = UIFont.systemFont(ofSize: 13) self.infoLabel?.textColor = UIColor.white self.infoLabel?.sizeToFit() if let labelSize = self.infoLabel?.frame.size { let windowSize = CGSize(width: labelSize.width &#43; 2 * self.labelMargin, height: labelSize.height &#43; 2 * self.labelMargin) self.infoLabel?.center = CGPoint(x: windowSize.width / 2, y: windowSize.height / 2) let superGect = UIScreen.main.bounds let superSize = superGect.size self.frame = CGRect(x: (superSize.width - windowSize.width) / 2, y: 0, width: windowSize.width, height: windowSize.height) switch self.style { case .TopMiddle: self.center = CGPoint(x: superSize.width / 2, y: self.centerYToEdge) case .Center: self.center = CGPoint(x: superSize.width / 2, y: superSize.height / 2) case .BottomMiddle: self.center = CGPoint(x: superSize.width / 2, y: superSize.height / 2 - self.centerYToEdge) } self.windowLevel = UIWindowLevelAlert &#43; 1 self.backgroundColor = UIColor(red: 64 / 255.0, green: 64 / 255.0, blue: 64 / 255.0, alpha: 0.7) self.layer.cornerRadius = 5 } } }  </content>
    </entry>
    
     <entry>
        <title>UIWebview 加载含特殊字符网页</title>
        <url>https://iihui.github.io/post/ios-webview-html/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>iOS</tag><tag>UIWebView</tag>
        </tags>
        <content type="html">  UIWebview中加载的html文件中如果含有\n,&#39;等特殊字符时，显示为一片空白。查阅资料得知需要将这些特殊字符进行预处理。
 预处理 class HTMLUtils{ static func escapsedHTML(html: String)-&amp;gt;String{ var result = html if !result.isEmpty{ result = result.replacingOccurrences(of: &amp;#34;\\&amp;#34;, with: &amp;#34;\\\\&amp;#34;) result = result.replacingOccurrences(of: &amp;#34;\&amp;#34;&amp;#34;, with: &amp;#34;\\\&amp;#34;&amp;#34;) result = result.replacingOccurrences(of: &amp;#34;&amp;#39;&amp;#34;, with: &amp;#34;\\&amp;#39;&amp;#34;) result = result.replacingOccurrences(of: &amp;#34;\r&amp;#34;, with: &amp;#34;\\r&amp;#34;) result = result.replacingOccurrences(of: &amp;#34;\n&amp;#34;, with: &amp;#34;\\n&amp;#34;) } return result } }  </content>
    </entry>
    
     <entry>
        <title>JS事件捕获</title>
        <url>https://iihui.github.io/post/js-event/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>JS</tag>
        </tags>
        <content type="html">  DOM事件从发生到开始经历了三个阶段，分别为捕获阶段、命中阶段以及冒泡阶段。捕获阶段表示从最上层开始，直到最下层(点击的那个target元素)，路过的所有节点都可以捕获到该事件。命中阶段:如果某个事件到达了target，它就会进行处理。冒泡阶段:事件从最下层向上传递，依次触发父元素的该事件处理。
 </content>
    </entry>
    
     <entry>
        <title>使用Visual Code的文件对比功能</title>
        <url>https://iihui.github.io/post/qa-compare/</url>
        <categories>
          <category>QA</category>
        </categories>
        <tags>
          <tag>QA</tag>
        </tags>
        <content type="html">  在使用坚果云的时候，由于较长时间没有同步，导致本地文件和云端文件冲突，再次同步时，坚果云保留了两个版本。为了弄清两个文件的差异，以进行修改，需要一个工具来比对。最初是想下载一个专门的文件对比软件，但转念一想或许Visual Code可以呢，一搜果真Visual Code自带文件对比功能。
 废话不多说，首先放上动图：
上面动图的操作可以分解为3步，第一步为打开左侧边栏，第二步为打开需要比较的文件，第三步为对比。
 第一步 首先打开SideBar，在菜单栏中依次点击View--&amp;gt;Appearance--&amp;gt;Toggle Side Bar,如下图所示:
 第二步 按住Command &#43; o(字母)打开要比较的文件，或者在菜单栏找到File---&amp;gt;Open：  第三步 在左侧的Open Editors目录下找到上一步需要比较的文件，然后点击鼠标右键，选中Compare Selected进行比对：  </content>
    </entry>
    
     <entry>
        <title>创建新的Target</title>
        <url>https://iihui.github.io/post/ios-new-target/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html">  项目需要新建一条众测流水线，因此首先需要基于DEV环境新建一个Target，然后将新建的Target配置到新建的流水线上。
 Duplicate 新Target的创建一般以已有的Target为模板，如下图所示，首先选中模板Target，然后右键点击选中Duplicate就能创建新的Target:
 修改Target名字 首先点击新的Target然后按回车键修改名字，此时修改的名字
修改plist 一旦点击Duplicate就会生成一个模板的copy,同时会生成一个新的plist文件，如下图所示： 新的plist文件和
</content>
    </entry>
    
     <entry>
        <title>Range的保存与恢复</title>
        <url>https://iihui.github.io/post/js-focus-save/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>JS</tag>
        </tags>
        <content type="html">  在iOS 11.3以下的UIWebview中插入图片时，因图片选择器的弹出导致UIWebview失去焦点，故在插入图片前需先保存图片将要插入的位置。
 保存range区域 图片选择器打开前，利用一个全局的Range对象保存插入前光标所在的位置的Range对象：
//插入图片和超链接的时候因为webview会失去焦点，因此需要保存range区域 let currentSelection; function backupRange() { let selection = window.getSelection(); if (selection.rangeCount) { let range = selection.getRangeAt(0); this.currentSelection = { &amp;#34;startContainer&amp;#34;: range.startContainer, &amp;#34;startOffset&amp;#34;: range.startOffset, &amp;#34;endContainer&amp;#34;: range.endContainer, &amp;#34;endOffset&amp;#34;: range.endOffset } } }  恢复Range区域 选择图片后，插入时要找到图片选择器打开前光标所在的Range，以便插入到正确的位置：
//恢复保存的range区域 function restoreRange() { if (this.currentSelection) { let selection = window.getSelection(); selection.removeAllRanges(); let range = document.createRange(); range.setStart(this.currentSelection.startContainer, this.currentSelection.startOffset); range.setEnd(this.currentSelection.endContainer, this.currentSelection.endOffset); selection.addRange(range); // 向选区中添加一个区域  } }  </content>
    </entry>
    
     <entry>
        <title>Swift访问权限</title>
        <url>https://iihui.github.io/post/ios-access-level/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html">  访问权限用于限制部分代码被其它源文件或者模块访问，目的是隐藏某些代码的实现细节。在Swift中可以设置类型(类、结构和枚举)的访问权限，也可以设置属性和方法的访问权限。Swift提供了5个访问级别，这些访问级别以模块和源文件为区分粒度。
 模块和源文件 模块 模块是指独立的代码单元，在iOS中框架或应用程序就是一个独立模块。在一个模块中可以用import关键字导入另一个模块。
源文件 源文件即Swift中的源代码文件，它通常属于一个模块，即一个框架（Framework）或者应用程序。
访问级别 Swift有5个级别的访问权限，从高到低依次为open，public，internal，fileprivate和private。它们遵循的原则是，高级别的变量不允许被定义为低级别变量的成员变量。例如，一个private的类中不应该出现public的String。但是，低级别的变量可以定义在高级别的变量中。例如，public的class中可以含有private的Int值。
open open具有最高的访问权限。其修饰的类和方法可以在任意Module中被访问和重写，它是Swift3中新添加的访问权限。
public public的权限仅次于open。与open唯一的区别在于，它修饰的对象可以在任意module中被访问，但是不能被其他module重写或继承。
open与public的区别 虽然open和public都有最高的访问级别，但open访问权限只适用于修饰class和class的成员，它与public有明显的不同：
  public修饰的class只允许外部模块调用，但是不允许外部模块继承，本模块可以继承。而open修饰的class既允许其他模块调用，也允许被子类继承。
  public修饰的成员只允许其他模块调用，但不能被外部模块重写(override)，本模块可以重写。而open修饰的成员既允许被其他模块调用，也允许成员被覆盖。
  open和public如果是用于继承某个类的话，那么open和public必须是在父类的约束限定之下。例如：不能父类是用public修饰，而子类却用open修饰。
  其他模块继承覆盖父类的成员时，也需要把成员声明为open。
  open class SubclassableParentClass { public func foo() { } open func bar() { } public final func baz() { } } open class SubclassC: SubclassableParentClass { //非法，成员没有被声明为open  override func bar() { } } internal internal是默认的权限。它表示只能在当前定义的module中访问和重写。它可以被一个module中的多个文件访问，但不能被其他module访问。
fileprivate 由fileprivate修饰的实体可以在当前文件内被访问。若某个功能只要在文件内使用，则可以使用这个访问符修饰，这也是Swift 3新添加的权限。
private private是最低阶别的访问权限，它的对象只能在定义的作用域内使用，离开了这个作用域，即时是同一个文件的其他作用域，也无法访问。
 </content>
    </entry>
    
     <entry>
        <title>img添加和取消点击监听</title>
        <url>https://iihui.github.io/post/js-image-addclicklistener/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>JS</tag>
        </tags>
        <content type="html">  一篇图文笔记可能有多张图片，目前的需求为单击图片后开始预览图片。想到的解决思路有两种，第一种是为每张图片添加点击事件的监听，这种方式的麻烦在于要监听是否有新图片插入，一旦有新图片插入时则要对其加入点击事件的监听；第二种则是全局监听点击事件，用户一旦点击，则判断该点击事件是否在img标签上，如果是则进入图片预览，否则什么也不做。
 第一种方式 每次进入图文笔记的浏览模式时为所有img添加点击事件的监听。因此，需要监听是否有新图片插入，一旦有新图片插入时需要将原来所有图片的点击事件的监听删除，再重新为所有图片添加新的点击监听。
添加监听 function addImagesClickListener(){ $(&amp;#39;body&amp;#39;).on(&amp;#39;click&amp;#39;, &amp;#39;img&amp;#39;, function () { let position = this.offsetTop; this.focus(); let result = {}; result.position = position.toString(); //顺便将图片所在纵位置返回  result.src = $(this).attr(&amp;#34;src&amp;#34;); let jsonString = JSON.stringify(result); let escapedJsonString = encodeURI(jsonString); //重新编码  let scheme = &amp;#34;position://&amp;#34;; document.location.href = scheme &#43; &amp;#34;#&amp;#34; &#43; escapedJsonString; //向ios发送  }); }  取消监听 function removeImagesClickListener() { // let pic = document.getElementsByTagName(&amp;#39;img&amp;#39;);  // for (i = 0; i &amp;lt; pic.length; i&#43;&#43;) {  // pic[i].off(&amp;#39;click&amp;#39;);  // }  $(&amp;#39;img&amp;#39;).each(function () { $(this).off(&amp;#39;click&amp;#39;); //移除所有图片的点击监听  }) }  第二种方式 利用全局监听点击事件，检查该点击事件的元素是否在img上，如果是则进入图片预览模式，但是这种方式会与UIWebview键盘弹出有冲突，因此进入图片浏览时需要先关掉键盘：
//与软键盘弹出有冲突，应该先关闭键盘 function clickHandler(event) { if (event.target instanceof HTMLImageElement) { //点击的是图片标签,则获取点击图片的src  $(&amp;#39;img&amp;#39;).each(function () { if (this.isSameNode(event.target)) { //https://segmentfault.com/q/1010000000156830/a-1020000000156902  document.activeElement.blur(); //首先关闭键盘以免冲突  let result = {}; result.src = $(this).attr(&amp;#34;src&amp;#34;); let jsonString = JSON.stringify(result); let escapedJsonString = encodeURI(jsonString); //重新编码  let scheme = &amp;#34;position://&amp;#34;; document.location.href = scheme &#43; &amp;#34;#&amp;#34; &#43; escapedJsonString; //向ios发送  } }); } }  </content>
    </entry>
    
     <entry>
        <title>img点击监听</title>
        <url>https://iihui.github.io/post/js-image-clickedlistener/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>JS</tag>
        </tags>
        <content type="html">  一篇图文笔记可能有多张图片，目前的需求为单击图片后开始预览图片。想到的解决思路有两种，第一种是为每张图片添加点击事件的监听，这种方式的麻烦在于要监听是否有新图片插入，一旦有新图片插入时则要对其加入点击事件的监听；第二种则是全局监听点击事件，用户一旦点击，则判断该点击事件是否在img标签上，如果是则进入图片预览，否则什么也不做。
 第一种方式 每次进入图文笔记的浏览模式时为所有img添加点击事件的监听。因此，需要监听是否有新图片插入，一旦有新图片插入时需要将原来所有图片的点击事件的监听删除，再重新为所有图片添加新的点击监听。
添加监听 function addImagesClickListener(){ $(&amp;#39;body&amp;#39;).on(&amp;#39;click&amp;#39;, &amp;#39;img&amp;#39;, function () { let position = this.offsetTop; this.focus(); let result = {}; result.position = position.toString(); //顺便将图片所在纵位置返回  result.src = $(this).attr(&amp;#34;src&amp;#34;); let jsonString = JSON.stringify(result); let escapedJsonString = encodeURI(jsonString); //重新编码  let scheme = &amp;#34;position://&amp;#34;; document.location.href = scheme &#43; &amp;#34;#&amp;#34; &#43; escapedJsonString; //向ios发送  }); }  取消监听 function removeImagesClickListener() { // let pic = document.getElementsByTagName(&amp;#39;img&amp;#39;);  // for (i = 0; i &amp;lt; pic.length; i&#43;&#43;) {  // pic[i].off(&amp;#39;click&amp;#39;);  // }  $(&amp;#39;img&amp;#39;).each(function () { $(this).off(&amp;#39;click&amp;#39;); //移除所有图片的点击监听  }) }  第二种方式 利用全局监听点击事件，一旦出现点击事件，则判断该点击事件的元素是否在img上，如果是则进入图片预览模式，但是这种方式会与UIWebview键盘弹出有冲突，因此进入图片浏览前需要先关掉键盘：
//与软键盘弹出有冲突，应该先关闭键盘 function clickHandler(event) { if (event.target instanceof HTMLImageElement) { //点击的是图片标签,则获取点击图片的src  $(&amp;#39;img&amp;#39;).each(function () { if (this.isSameNode(event.target)) { //https://segmentfault.com/q/1010000000156830/a-1020000000156902  document.activeElement.blur(); //首先关闭键盘以免冲突  let result = {}; result.src = $(this).attr(&amp;#34;src&amp;#34;); let jsonString = JSON.stringify(result); let escapedJsonString = encodeURI(jsonString); //重新编码  let scheme = &amp;#34;position://&amp;#34;; document.location.href = scheme &#43; &amp;#34;#&amp;#34; &#43; escapedJsonString; //向ios发送  } }); } }  </content>
    </entry>
    
     <entry>
        <title>单例模式</title>
        <url>https://iihui.github.io/post/ios-singleton/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html">  单例模式(Singleton Pattern)属于创建型模式，该模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有一个单例对象被创建。
 第一种方式 利用Swift中全局变量的懒加载和全局变量初始化时默认使用dispatch_once以保证全局变量的构造器只会被调用一次:
let sharedManager = MyManager(string: someString) //定义全局变量 class MyManager { let string: String //初始化器 init(string: String) { self.string = string } }  第二种方式 利用static和private两个关键字,static关键字说明该变量是类变量而不是实例变量；而private保证了该类变量为单例：
class MyManager { //全局变量 static let shared = MyManager(string: someString) //属性 let string: String //初始化器 private init(string: String) { self.string = string } } //使用 print(MyManager.shared)  第三种方式 第三种方式是让单例在闭包中初始化，同时加入类方法以获取单例。这种方式的好处是可以在闭包中做一些额外的配置：
class MyManager { //private修饰 private static let sharedManager: MyManager = { let shared = MyManager(string: someString) //可以做一些其他的配置 //... return shared }() //Properties let string: String //构造函数，由private修饰 private init(string: String) { self.string = string } //访问器 class func shared() -&amp;gt; MyManager { return sharedManager } } //使用 print(MyManager.shared()) 单例的缺陷   由于单例是共享的，因此程序员无法预测单例当前的状态。
  因为其它共享的实例可以修改，因此测试困难。
  无法对访问权限作出限定，容易造成管理上的混乱。
   参考资料
</content>
    </entry>
    
     <entry>
        <title>基于PageController的图片预览</title>
        <url>https://iihui.github.io/post/ios-image-preview/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html"> 参考资料 参考资料 参考资料 参考资料
</content>
    </entry>
    
     <entry>
        <title>LLDB 调试</title>
        <url>https://iihui.github.io/post/ios-debug/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html">  LLDB是一个庞大的工具,内置了许多有用的命令。
 命令语法结构 &amp;lt;command&amp;gt; [&amp;lt;subcommand&amp;gt; [&amp;lt;subcommand&amp;gt;...]] &amp;lt;action&amp;gt; [-options [option-value]] [argument [argument...]] 其中：
 command和subcommand为LLDB调试命令的名称，命令和子命令按照层级结构来排列：一个命令对象为跟随其的子命令对象创建一个上下文，子命令又为其子命令创建一个上下文，依此类推。 action  上面的这些元素之间通过空格来分割，如果某一元素自身含有空格，则可以使用双引用。而如果元素中又包含双引号，则可以使用反斜杠；或者元素使用单引号。如下所示：
(lldb) command [subcommand] -option &amp;#34;some \&amp;#34;quoted\&amp;#34; string&amp;#34; (lldb) command [subcommand] -option &amp;#39;some &amp;#34;quoted&amp;#34; string&amp;#39; 获取变量值和状态 使用expression和e可以获取和改变变量的值
获取整个APP的状态和指定语言的命令  bugreport:生成当前应用状态的完整报告 frame:获取当前线程的当前栈帧的概述  参考资料 参考资料
</content>
    </entry>
    
     <entry>
        <title>多图片选择</title>
        <url>https://iihui.github.io/post/ios-image-selector/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html"> 第一步 JSAPI中有个文件选择器，而文件选择器中有选择多个图片的功能。首先在WebviewController.swift中找到:
case UrlSchema.fileSelectorSchema.rawValue: //文件选择器 fileSelectorService.presentFileSelector(self.webConfig, params: paramDic)  第二步 首先查看fileSelectorService的创建:
fileprivate lazy var fileSelectorService: FileSelectorService = FileSelectorService(callbackDelegate: self) 而FileSelectorService继承自BaseCallbackService:
class FileSelectorService: BaseCallbackService { } func presentFileSelector(_ webConfig: WebConfig, params: NSDictionary) { self.urlParams = params var webFileType:WebFileType? if let type = params[&amp;#34;type&amp;#34;] as? String ,type != &amp;#34;&amp;#34;{ switch type { case &amp;#34;video&amp;#34;: webFileType = .video break case &amp;#34;photo&amp;#34;: webFileType = .image break case &amp;#34;audio&amp;#34;: webFileType = .audio break case &amp;#34;document&amp;#34;: webFileType = .doc break case &amp;#34;compressed&amp;#34;: webFileType = .compressed break default : webFileType = .other break } } let maxCount = (params[&amp;#34;maxCount&amp;#34;] as? NSString)?.integerValue let showDownloadFile = (params[&amp;#34;showDownloadFile&amp;#34;] as? String) == &amp;#34;false&amp;#34; ? false : true //由于ImageSelector（UIViewController）无法继承FileSelectorBaseViewController(UITableViewController) //所以改用这种方式实现判断 //根据version和type决定使用文件选择/图片选择 let version = params[&amp;#34;version&amp;#34;] as! String if version == &amp;#34;1&amp;#34; { self.presentFileSelector(type: webFileType, showDownloadFile: showDownloadFile, webConfig: webConfig, maxCount: maxCount, fileSelectorProtocol: self) } else if version == &amp;#34;2&amp;#34; { if webFileType == .video || webFileType == .image { self.presentImageSelector(type: webFileType, showDownloadFile: showDownloadFile, webConfig: webConfig, maxCount: maxCount, fileSelectorProtocol: self) }else { self.presentFileSelector(type: webFileType, showDownloadFile: showDownloadFile, webConfig: webConfig, maxCount: maxCount, fileSelectorProtocol: self) } } } 同时FileSelectorService继承了FileSelectorRouter和ImageSelectorRouter协议
extension FileSelectorService:FileSelectorRouter,ImageSelectorRouter{} 第三步 接着在FileSelectorService类中的presentFileSelector方法中出现调用多图片选择器：
if webFileType == .video || webFileType == .image { self.presentImageSelector(type: webFileType, showDownloadFile: showDownloadFile, webConfig: webConfig, maxCount: maxCount, fileSelectorProtocol: self) }  然后进入到presentImageSelector:
import Foundation protocol ImageSelectorRouter:BaseRouter{} extension ImageSelectorRouter { var newInstance:ImageSelectorViewController { return router.sbFileManage.instantiateViewController(withIdentifier: &amp;#34;ImageSelectorViewController&amp;#34;) as! ImageSelectorViewController } func presentImageSelector(type:WebFileType?, showDownloadFile: Bool, webConfig:WebConfig,maxCount:Int?,fileSelectorProtocol:FileSelectorCallbackProtocol?,albumModel:AlbumSelectorViewModel? = nil) { guard let fromVC = keyWindow?.safeRootViewController else { return } let vc = newInstance if let webFileType = type { vc.presenter.type = webFileType } vc.presenter.albumModel = albumModel vc.presenter.webConfig = webConfig vc.presenter.showDownloadFile = showDownloadFile vc.fileSelectorProtocol = fileSelectorProtocol let nc = RotatableNavigationController(rootViewController: vc) if let count = maxCount { vc.presenter.maxCount = count } present(fromVC, toVC: nc) } //首页扫一扫使用和jsapi func presentImageSelector(fileSelectorProtocol: FileSelectorCallbackProtocol) { guard let fromVC = (UIApplication.shared.delegate as? AppDelegate)?.topViewController else { return } let vc = newInstance vc.presenter.type = .image vc.presenter.webConfig = nil vc.presenter.showDownloadFile = true vc.fileSelectorProtocol = fileSelectorProtocol vc.presenter.maxCount = 1 vc.isSingleSelection = true let nc = RotatableNavigationController(rootViewController: vc) present(fromVC, toVC: nc) } }  第四步 根据第三步的代码，将上面的presentImageSelector方法中的代码加入到NewNoteViewController中:
fileprivate var imageSelectorPicker:ImageSelectorViewController{ let instance = router.sbFileManage.instantiateViewController(withIdentifier: &amp;#34;ImageSelectorViewController&amp;#34;) as! ImageSelectorViewController instance.presenter.type = .image instance.presenter.albumModel = nil //instance.presenter.maxCount=10 instance.presenter.showDownloadFile = true instance.fileSelectorProtocol = self return instance } 然后再处理回调，将获得的图片先进行压缩然后进行拦截展示：
extension NewNoteViewController:FileSelectorCallbackProtocol { //文件选择回调 func didFinishSelectFile(_ files: [FileSelectorCallbackModel]) { for file in files { if let image = file.fileImage { let imageSrc = self.newNoteViewControllerPresenter.insertImage(image: image) var isNeedRestoreRange = &amp;#34;N&amp;#34; if self.newNoteViewControllerPresenter.isLowerBoundaryVersion(boundaryVersion: self.boundaryVersion){ isNeedRestoreRange = &amp;#34;Y&amp;#34; } self.webView.stringByEvaluatingJavaScript(from: &amp;#34;insertImage(&amp;#39;\(imageSrc)&amp;#39;,&amp;#39;\(isNeedRestoreRange)&amp;#39;)&amp;#34;) } } }  </content>
    </entry>
    
     <entry>
        <title>Swift中for-in的各种姿势</title>
        <url>https://iihui.github.io/post/swift-for-in/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html">  Swift中只有一种形式的for循环，即for-in。但是for-in有多种形式，包括常规用法和区间循环。
 常规用法 常规用法一般用于直接访问数组中的元素，分为直接访问和按索引访问：
let arr = [34,78,789,-12] for item in arr{ print(item) } 在OC中是通过索引i来访问数组中的元素，在Swift中需要借助枚举enumerate来实现
for item in arr.enumerated(){ print(item.offset,item.element) } for (i,num) in arr.enumerated(){ print(i,num) }  区间循环 在Swift中...表示闭区间，例如0...10表示0，1，2，...，10；而..&amp;lt;表示前闭后开区间，例如0..&amp;lt;10表示0，1，2，...，9。
for i in 0...10{ print(i) } for i in 0..&amp;lt;10{ print(i) } 在...和..&amp;lt;这两种表示中要求左边界小于等于右边界，灵活性较弱。因此，Swift提供了一种更灵活的stride，以满足不同的递增条件以和开闭区间的结合。
func stride&amp;lt;T&amp;gt;(from start: T, to end: T, by stride: T.Stride) func stride&amp;lt;T&amp;gt;(from start: T, through end: T, by stride: T.Stride) //from:开始位置包括上边界by：递增步长 //to：结束位置，前闭后开区间，不包含右边界 //through：结束位置，全闭区间，包含右边界 for i in stride(from: 0, to: 10, by: 2){ print(i, terminator: &amp;#34;\t&amp;#34;) //02468 } for i in stride(from: 0, through: 10, by: 2){ print(i, terminator: &amp;#34;\t&amp;#34;) //0246810 } 如果要实现递减，则需要将by改成负数:
for i in stride(from: 10, through: 0, by: -2){ print(i, terminator: &amp;#34;\t&amp;#34;) //1086420 } 中途改变by的值没有作用，查看源码发现by是以传值的方式传递到stride函数中的：
var step = -3 for i in stride(from: 10, through: 0, by: step){ print(i, terminator: &amp;#34;\t&amp;#34;) //10741 step -= 2 //虽然改变了step但结果依然是10741 }  参考资料 参考资料
 </content>
    </entry>
    
     <entry>
        <title>基本内排序算法Swift实现</title>
        <url>https://iihui.github.io/post/ios-sort/</url>
        <categories>
          <category>算法</category>
        </categories>
        <tags>
          <tag>算法</tag>
        </tags>
        <content type="html">  排序就是重新排列表中的元素，使表中的元素满足按关键字递增或者递减的排列过程。排序算法分为内排序和外排序。内排序是指排序期间元素全部放在内存中的排序；而外排序是指在排序期间元素太多，不能同时存放在内存中，必须在排序过程中根据要求，不断在内，外存之间移动的排序。内排序可归纳为插入排序，选择排序，交换排序、归并排序，计数排序，基数排序等。
 插入排序 直接插入排序 直接插入排序是在有序的基础上进行排序。对于数组来说第一个元素默认是有序的，从第二个元素开始，在前面已经有序的元素中找到当前元素应该在的位置进行插入：
//直接插入排序，时间复杂度为O(n^2)，空间复杂度为O(1)，稳定的排序算法 static func insertSort&amp;lt;T: Comparable&amp;gt;(data: [T]) -&amp;gt; [T] { var result = data var j: Int for i in 1 ..&amp;lt; result.count { let tmp = result[i] j = i - 1 while j &amp;gt;= 0 { if result[j] &amp;gt; tmp { result[j &#43; 1] = result[j] j -= 1 } else { break } } result[j &#43; 1] = tmp } return result }  直接插入排序是稳定的排序算法 时间复杂度为$O(n^2)$ 空间复杂度为$O(1)$   折半插入排序 折半插入排序，在查找当前元素应该插入的位置时，利用前面元素已经有序的特点，以二分法进行查找：
//二分插入排序,时间复杂度为O(nlog(n))，空间复杂度为O(1)，不稳定的排序算法,例子为(2,2,2) static func binarySort&amp;lt;T: Comparable&amp;gt;(data: [T]) -&amp;gt; [T] { var result = data var start, end, mid: Int for i in 1 ..&amp;lt; result.count { let tmp = result[i] start = 0 end = i - 1 while start &amp;lt;= end { mid = start &#43; (end - start) / 2 if result[mid] == result[i] { end = mid break } else if result[mid] &amp;gt; result[i] { end = mid - 1 } else { start = mid &#43; 1 } } for j in stride(from: i - 1, through: end &#43; 1, by: -1) { result[j &#43; 1] = result[j] } result[end &#43; 1] = tmp } return result }  是不稳定的排序算法，例如(1,1,1,1,1) 时间复杂度为$O(n^2)$，二分查找插入位置，因为不是查找相等值，而是基于比较查插入合适的位置，所以必须查到最后一个元素才知道插入位置。 空间复杂度为$O(1)$   Shell排序 希尔排序是先将待排序的表分割为若干形如$L[i,i&#43;d,i&#43;2d,..i&#43;kd]$的子表，分别进行直接插入排序，当整个表中元素已呈基本有序时，再对全体进行一次直接插入排序。
//shell排序，时间复杂度O(nlog^k(n)),空间复杂度为O(1),不稳定的排序算法，例子为(2,2,1) static func shellSort&amp;lt;T: Comparable&amp;gt;(data: [T]) -&amp;gt; [T] { var result = data var step = result.count / 2 while step &amp;gt;= 1 { self.assistShellSort(data: &amp;amp;result, step: step) step /= 2 } return result } static private func assistShellSort&amp;lt;T: Comparable&amp;gt;(data: inout [T], step: Int) { guard step &amp;gt;= 1 else { return } var j = 0 for i in 1 ..&amp;lt; data.count { let tmp = data[i] j = i - step while j &amp;gt;= 0 { if data[j] &amp;gt; tmp { data[j &#43; step] = data[j] j -= step } else { break } } data[j &#43; step] = tmp } }  是不稳定的排序算法，例如(2,1,1) 空间复杂度为$O(1)$   选择排序 简单选择排序 简单选择排序，首先从数组所有元素中找到最小的元素，然后将其与第一个元素进行交换，这样第一个元素就变成了最小元素；然后从第二个元素开始找剩下元素中最小的那一个，并将这个最小元素与第二个元素进行交换，如此第二个元素就变成第二小的元素，依次类推：
//选择排序，时间复杂度为O(n^2),空间复杂度为O(1),不稳定的排序算法，例子为(2,2,1) static func selectSort&amp;lt;T: Comparable&amp;gt;(data: [T]) -&amp;gt; [T] { var result = data var index: Int for i in 0 ..&amp;lt; result.count - 1 { index = i for j in i &#43; 1 ..&amp;lt; result.count { if result[j] &amp;lt; result[index] { index = j } } if index != i { (result[index], result[i]) = (result[i], result[index]) } } return result }  不稳定的排序算法，例如2,2,1 时间复杂度为$O(n^2)$ 空间复杂度为$O(1)$   堆排序 堆排序算法，是先将数组排成大顶堆（也可以是小顶堆）。然后将堆顶元素（当前最大）和数组的最后一个元素进行交换，那么此时堆顶到数组的倒数第二个元素之间的堆可能就不再满足堆的定义，需要调整。调整好之后，堆顶元素即为堆顶到数组的倒数第二个元素之间最大的元素，此时将堆顶元素和倒数第二个元素交换，此时又可能不满足堆的定义了，因此再调整堆，如此继续，直到处理完所有数据。
//堆排序，时间复杂度为O(nlog(n))，空间复杂度为O(1)，不稳定的排序算法，例子为(2,2,1) static func heapSort&amp;lt;T: Comparable&amp;gt;(data: [T]) -&amp;gt; [T] { var result = data //首先排序为大顶堆 for i in stride(from: (result.count - 1) / 2, through: 0, by: -1) { self.adjustHeap(data: &amp;amp;result, start: i, end: result.count - 1) } //然后交换，再重新调整为大顶堆 for i in stride(from: result.count - 1, through: 1, by: -1) { (result[0], result[i]) = (result[i], result[0]) self.adjustHeap(data: &amp;amp;result, start: 0, end: i - 1) } return result } //辅助函数，默认除了第一个元素不满足大顶堆，所以要调整第一个元素到合适位置 static private func adjustHeap&amp;lt;T: Comparable&amp;gt;(data: inout [T], start: Int, end: Int) var parent = start, child = 2 * start &#43; 1 while child &amp;lt;= end { if child &amp;lt; end, data[child] &amp;lt; data[child &#43; 1] { child &#43;= 1 } if data[parent] &amp;lt; data[child] { (data[parent], data[child]) = (data[child], data[parent]) parent = child child = 2 * parent &#43; 1 }else{ break } } }  是不稳定的排序算法,例如(1,2,2) 时间复杂度为$O(nlog(n))$ 空间复杂度为$O(1)$   交换排序  交换排序，就是根据序列中两个元素关键字的比较结果来对换这两个记录在序列中的位置。
 冒泡排序 冒泡排序假设待排序表长为n，从后往前（或从前往后）两两比较相邻元素的值，若为逆序$A[i-1]&amp;gt;A[i]$，则交换它们，直到序列比较完。称之为一趟冒泡，结果将最小的元素交换到待排序列的第一个位置（关键字最小的元素如气泡一般逐渐往上漂浮，直到水面，这就是冒泡排序的名字的由来）。下一趟冒泡时，前一趟确定的最小元素不再参与比较，待排序减少一个元素，每趟冒泡的结果把序列中的最小元素放到序列的最终位置，&amp;hellip;，这样最多做$n-1$趟冒泡就能把所有元素排好序。
//交换排序，时间复杂度为O(n^2),空间复杂度为O(1),稳定的排序算法 static func bubbleSort&amp;lt;T: Comparable&amp;gt;(data: [T]) -&amp;gt; [T] { var result = data var flag = false //用于标识本趟是否有交换 for i in 0 ..&amp;lt; result.count - 1 { flag = false for j in 0 ..&amp;lt; result.count - i - 1 { //大数沉底 if result[j] &amp;gt; result[j &#43; 1] { (result[j], result[j &#43; 1]) = (result[j &#43; 1], result[j]) flag = true } } if flag == false { break } } return result }  是稳定的排序算法 时间复杂度为$O(n^2)$ 空间复杂度为$O(1)$   快速排序 //快速排序，时间复杂度为O(nlog(n))，空间复杂度为log(n),不稳定的排序算法，例子(2,2,1) static func quickSort&amp;lt;T: Comparable&amp;gt;(data: inout [T], start: Int, end: Int) { guard start &amp;lt; end else { return } let pivot = assistQuickSort(data: &amp;amp;data, start: start, end: end) if pivot &amp;gt; start { quickSort(data: &amp;amp;data, start: start, end: pivot - 1) } if end &amp;gt; pivot { quickSort(data: &amp;amp;data, start: pivot &#43; 1, end: end) } } //在start...end之间随机抽取一个数字，并将其放置其最终的位置 static private func assistQuickSort&amp;lt;T: Comparable&amp;gt;(data: inout [T], start: Int, end: Int) -&amp;gt; Int { let index = Int.randomIntNumber(lower: start, upper: end &#43; 1) (data[end], data[index]) = (data[index], data[end]) var small = start - 1 for i in start ..&amp;lt; end { if data[i] &amp;lt; data[end] { small &#43;= 1 if small != i { (data[small], data[i]) = (data[i], data[small]) } } } small &#43;= 1 (data[small], data[end]) = (data[end], data[small]) return small } extension Int { //返回的结果：[lower,upper)之间的半开半闭区间的数。 public static func randomIntNumber(lower: Int = 0, upper: Int = Int(UInt32.max)) -&amp;gt; Int { return lower &#43; Int(arc4random_uniform(UInt32(upper - lower))) } //生成某个区间的随机数 public static func randomIntNumber(range: Range&amp;lt;Int&amp;gt;) -&amp;gt; Int { return randomIntNumber(lower: range.lowerBound, upper: range.upperBound) } }   是不稳定的排序算法，例如(3,2,2)时，Pivot为0
  时间复杂度为$O(nlog(n))$
  空间复杂度为$O(log(n))$
  平均条件下，最快的排序算法
   归并排序  归并的含义是将两个或者两个以上的有序表组合成一个新的有序表。假定待排序表含有n个记录，则可以视为n个有序子表，每个表的长度为1，然后两两归并，得到$\biggl\lceil\frac{n}{2}\biggr\rceil$个长度为2或1的有序表，再两两归并，&amp;hellip;，如此重复，直到合并成一个长度为n的有序表为止，这种排序方法称为二路归并排序。
 //归并排序，时间复杂度为O(nlog(n)),空间复杂度为(O(n),稳定的排序算法 static func mergeSort&amp;lt;T: Comparable&amp;gt;(data: [T]) -&amp;gt; [T] { var result = data var assist = data self.mergeSort(data: &amp;amp;result, assist: &amp;amp;assist, start: 0, end: result.count - 1) return result } static private func mergeSort&amp;lt;T: Comparable&amp;gt;(data: inout [T], assist: inout [T], start: Int, en if start &amp;lt; end { let mid = start &#43; (end - start) / 2 mergeSort(data: &amp;amp;data, assist: &amp;amp;assist, start: start, end: mid) mergeSort(data: &amp;amp;data, assist: &amp;amp;assist, start: mid &#43; 1, end: end) var index = start, i = start, j = mid &#43; 1 while i &amp;lt;= mid &amp;amp;&amp;amp; j &amp;lt;= end { if data[i] &amp;lt; data[j] { assist[index] = data[i] i &#43;= 1 } else { assist[index] = data[j] j &#43;= 1 } index &#43;= 1 } while i &amp;lt;= mid { assist[index] = data[i] index &#43;= 1 i &#43;= 1 } while j &amp;lt;= mid { assist[index] = data[j] index &#43;= 1 j &#43;= 1 } data = assist } } func mergeSort(data:inout Array&amp;lt;Int&amp;gt;){ var assist = data mergeSort(data: &amp;amp;data, assist: &amp;amp;assist,start: 0,end: data.count-1) } func mergeSort(data:inout Array&amp;lt;Int&amp;gt;,assist:inout Array&amp;lt;Int&amp;gt;,start:Int,end:Int){ if start == end{ assist[start] = data[start] return } let length = (end - start)/2 mergeSort(data: &amp;amp;data, assist: &amp;amp;assist, start: start, end: start &#43; length) mergeSort(data: &amp;amp;data, assist: &amp;amp;assist, start: start &#43; length &#43; 1, end: end) var i=start, j = start &#43; length &#43; 1,k = start while i &amp;lt;= start &#43; length &amp;amp;&amp;amp; j &amp;lt;= end{ if data[i] &amp;lt;= data[j]{ assist[k] = data[i] i &#43;= 1 }else{ assist[k] = data[j] j &#43;= 1 } k &#43;= 1 } if i &amp;lt;= start &#43; length { assist[k...(k &#43; (start &#43; length - i))] = data[i...start&#43;length] } if j &amp;lt;= end { assist[k...(k &#43; (end - j))] = data[j...end] } data = assist }  计数排序 计数排序是一种非比较性质的排序算法，元素从未排序状态变为已排序状态的过程，是由额外空间的辅助和元素本身的值决定的。计数排序过程中不存在元素之间的比较和交换操作，根据元素本身的值，将每个元素出现的次数记录到辅助空间后，通过对辅助空间内数据的计算，即可确定每一个元素最终的位置。
//计数排序，时间复杂度为O(n&#43;K),空间复杂度为O(n&#43;K),稳定的排序算法 static func countSort(data: [Int]) -&amp;gt; [Int]? { guard let arr = preCountSort(data: data), let max = arr.max() else return nil } var countArr = [Int](repeating: 0, count: max &#43; 1) for item in arr { countArr[item] &#43;= 1 } for i in 1 ..&amp;lt; countArr.count { countArr[i] &#43;= countArr[i - 1] } var result = [Int](repeating: 0, count: arr.count) for i in stride(from: arr.count - 1, through: 0, by: -1) { result[countArr[arr[i]] - 1] = arr[i] countArr[arr[i]] -= 1 } let realResult = postCountSort(data: data, result: result) return realResult } static private func preCountSort(data: [Int]) -&amp;gt; [Int]? { guard let min = data.min() else { return nil } if min &amp;lt; 0 { let adder = abs(min) let result = data.map { $0 &#43; adder } return result } else { return data } } static private func postCountSort(data: [Int], result: [Int]) -&amp;gt; [Int]? guard data.count == result.count, let min = data.min() else { return nil } var realResult = result if min &amp;lt; 0 { realResult = result.map { $0 &#43; min } } return realResult } 参考资料
 基数排序 基数排序(Radix Sort)是桶排序的扩展，它的基本思想是：将整数按位数切割成不同的数字，然后按每个位数分别比较。具体做法是：将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后,待排序序列就变成一个有序序列。
//十进制的基数排序 static func radixSort(data: [Int]) -&amp;gt; [Int]? { guard var arr = preRadixSort(data: data), let max = arr.max() else { return nil } var assist = 1 while assist &amp;lt;= max { inRadixSort(data: &amp;amp;arr, assist: assist, radix: 10) assist *= 10 } return arr } static private func preRadixSort(data: [Int]) -&amp;gt; [Int]? { for item in data { if item &amp;lt; 0 { return nil } } return data } static private func inRadixSort(data: inout [Int], assist: Int, radix: Int) { var countArr = [Int](repeating: 0, count: 10) for item in data { countArr[(item / assist) % radix] &#43;= 1 } var tmpArr = data for i in 1 ..&amp;lt; countArr.count { countArr[i] &#43;= countArr[i - 1] } for i in stride(from: data.count - 1, through: 0, by: -1) { tmpArr[countArr[(data[i] / assist) % radix] - 1] = data[i] countArr[(data[i] / assist) % radix] -= 1 } data = tmpArr } 总结  </content>
    </entry>
    
     <entry>
        <title>iOS允许HTTP请求</title>
        <url>https://iihui.github.io/post/ios-http/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html"> 在iOS 9之后，苹果默认要求App访问的url必须为https的安全链接，为了能在项目中请求Http链接，需要在项目中自动生成的Info.plist文件里，将App Transport Security Settings下的Allow Arbitrary Loads设置为YES「如果没有则先添加这两项」:
 </content>
    </entry>
    
     <entry>
        <title>Framework</title>
        <url>https://iihui.github.io/post/ios-framework/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html"> 链接库 库是一种共享程序代码的方式，分为静态库和动态库。静态库链接时被完整地拷贝到可执行文件，多次使用时就会有多个副本。
而动态库在链接时不复制，程序运行时由系统动态加载到内存，供程序调用。动态库只加载一次到内存，然后供多个程序共用，以节省内存。
静态库的形式 在iOS中静态库分为.a和.framework。.a是一个纯二进制文件，.framework中除了二进制文件之外，还有资源文件。.a文件不能直接使用，至少要有.h文件配合，而.framework文件可以直接使用。
$$ .a &#43; .h &#43; sourceFile = .framework$$
 动态库的形式 在iOS中动态库分为.dylib和.framework两种形式。.framework既可以是动态库又可以是静态库，需要在构建的时候进行设置：
 构建Framework 一般构建 新建项目时选择Cocoa Touch Framwork： 然后输入Product Name： 为了让制作出的framework在低版本的系统上也能使用，可以在General-&amp;gt;Deployment Info里设置一个较低的发布版本: 将需要添加的文件加入到项目中，进行编译，如下图所示选择不同的active scheme则会生成对应于不同平台的framework：  引入OC代码 如果要在framework中引入OC代码，则首先将.m和.h文件拖入到项目中。然后在设置时选中相应的tagert，找到Build Phases,再在其下的Header中找到相应的头文件，将该头文件从project拖到public下:
再在创建工程时，自动生成的.h文件中引入刚刚拖到工程中的.h文件：  使用Framework 首先将自己构建的Framework拖到目标工程中，如下图所示： 添加的时候选中Copy items if needed和Create groups，然后需要加到哪个target就在对应的target前进行勾选: 添加完成后如下图所示： 然后到相应的target的设置中，找到General下的Embedded Binaries：
接着点击&#43;号添加相应的Framework： 最后的效果如下图所示:  参考资料 参考 参考
</content>
    </entry>
    
     <entry>
        <title>桥接文件</title>
        <url>https://iihui.github.io/post/ios-bridge/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html"> 因为历史原因，在使用Swift编程时，常常需要用到OC类中的方法，此时就需要使用桥接文件来引入OC中的头文件，以告诉Swift。
手动创建桥接文件 第一步 首先使用快捷键Command&#43;N来新建一个文件：  第二步 选择Header File:  第三步 给Header File命名：  第四步 点击工程配置，添加关联：  第五步 设置桥接文件的路径：  第六步 将要引入的OC头文件，加入到桥接文件中，例如：
//透云QR解码 #import &amp;#34;TYQRViewController.h&amp;#34; //显示GIF的Label #import &amp;#34;UIImage&#43;GIF.h&amp;#34; #import &amp;#34;CFTextModel.h&amp;#34; #import &amp;#34;CFLabel.h&amp;#34; #import &amp;#34;CFTableViewCell.h&amp;#34; #import &amp;#34;CFTextView.h&amp;#34; //百度语音 #import &amp;#34;BDSEventManager.h&amp;#34; #import &amp;#34;BDSASRDefines.h&amp;#34; #import &amp;#34;BDSASRParameters.h&amp;#34;  参考 参考资料
 </content>
    </entry>
    
     <entry>
        <title>WKWebView</title>
        <url>https://iihui.github.io/post/ios-wkwebview/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html"> self.webView.scrollView.addObserver(self, forKeyPath: &amp;#34;contentSize&amp;#34;, options: .new, context: nil) } override func observeValue(forKeyPath keyPath: String?, of object: Any?, change: [NSKeyValueChangeKey : Any]?, context: UnsafeMutableRawPointer?) { if let key = keyPath, key == &amp;#34;contentSize&amp;#34;{ let fittingSize = self.webView.sizeThatFits(CGSize.zero) self.webView.frame = CGRect(x: 0, y: noteTitleTextField.frame.height, width: fittingSize.width, height: fittingSize.height) } } </content>
    </entry>
    
     <entry>
        <title>JS的prototype</title>
        <url>https://iihui.github.io/post/js-prototype/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>js</tag>
        </tags>
        <content type="html">  在JS中，每当定义一个对象(函数也是对象)时，对象中都会包含一些预定义的属性；每个对象都有一个prototype对象，这个属性指向函数的原型对象。
 原型对象 缘由 Brendan Eich在设计JS时，将所有的数据类型都设计为对象，因此需要有一种机制将这些对象都联系起来。但他只想设计一种简易的脚本语言，所以没有引入类的概念，因为一旦有了类的概念，JS就是一种完整的面向对象的编程语言。
借鉴了Java和C&#43;&#43;使用new来生成实例，Brendan Eich利用new后面跟构造函数「因为没有类的概念」生成对象。
function DOG(name) { this.name = name; this.species = &amp;#39;犬科&amp;#39;; } var dogA = new DOG(&amp;#34;大毛&amp;#34;); var dogB = new DOG(&amp;#34;二毛&amp;#34;); 上面这两个对象的species属性都是独立的，修改其中一个，不会影响到另外一个，即每一个实例对象都有自己属性和方法的副本，通过这种方式无法达到数据共享。
 引入 考虑到数据共享的需要，Brendan Eich打算为构造函数设置一个prototype属性，这个属性包含一个对象，所有实例对象需要共享的属性和方法，都放在这个对象里面；那些不需要共享的属性和方法，就放在构造函数中。
实例对象一旦创建，将自动引用prototype对象的属性和方法。即实例对象的属性和方法，分为两种，一种是本地的，另一种是引用的。
function DOG(name) { this.name = name; } DOG.prototype = { species: &amp;#34;犬科&amp;#34; }; var dogA = new DOG(&amp;#34;大毛&amp;#34;); var dogB = new DOG(&amp;#34;二毛&amp;#34;); alert(dogA.species); // 犬科 alert(dogB.species); // 犬科  总结 由于所有的实例对象共享一个prototype对象，因此在外界看起来，prototype就好像是实例对象的原型，而实例对象则好像继承了prototype对象一样。
 参考资料 参考资料
 </content>
    </entry>
    
     <entry>
        <title>iOS 版本检查</title>
        <url>https://iihui.github.io/post/ios-new-version/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html"> 首先由AboutViewController中的presenter调用其requestLastestVersion方法，而presenter是 AboutPresenter类的实例：
lazy var presenter:AboutPresenter = AboutPresenter(delegate:self) presenter.requestLatestVersion() AboutPresenter类 而AboutPresenter类的实现如下所示:
import Foundation protocol AboutPresenterDelegate:class { func updateUIForLatestVersion(shouldUpdate:Bool,updateMessage:String,updateUrl:String,minOSVersion: String?) } class AboutPresenter:NSObject,WelcomeHttpProtocol { lazy var webConfigs:[WebConfig?] = [self.webConfigService.versionDescriptionWebConfig,self.webConfigService.teamWebConfig,self.webConfigService.statisticWebConfig] let publishVersion:String = UpdateService().publishVersion let appDelegate = UIApplication.shared.delegate as! AppDelegate let deviceID:String = EnvironmentService.shared.deviceID fileprivate lazy var welcomHttpController: WelcomeHttpController = WelcomeHttpController(delegate: self) fileprivate lazy var webConfigService = WebConfigService() fileprivate weak var delegate:AboutPresenterDelegate? init(delegate:AboutPresenterDelegate?) { self.delegate = delegate } func requestLatestVersion() { welcomHttpController.requestLatestVersion(false) } func didReceiveLatestVersion(_ jsonData: JSON) { let retCode = jsonData[&amp;#34;data&amp;#34;][&amp;#34;retCode&amp;#34;].stringValue let message = jsonData[&amp;#34;data&amp;#34;][&amp;#34;changeLog&amp;#34;].stringValue let updateUrl = jsonData[&amp;#34;data&amp;#34;][&amp;#34;appUrl&amp;#34;].stringValue let isLatest = (retCode == &amp;#34;0&amp;#34; || retCode == &amp;#34;&amp;#34;) let minOSVersion = jsonData[&amp;#34;data&amp;#34;][&amp;#34;minOSVersion&amp;#34;].string appDelegate.isLatest = isLatest delegate?.updateUIForLatestVersion(shouldUpdate: !isLatest, updateMessage: message, updateUrl: updateUrl, minOSVersion: minOSVersion) } func didError() { BaseHttpController.commonNetworkError() } }  WelcmeHttpController类 在presenter中的requestLastestVersion方法中调用了welcomHttpController.requestLatestVersion(false)，而WelcmeHttpController的实现为：
import UIKit protocol WelcomeHttpProtocol: BaseHttpProtocol { func didReceiveLatestVersion(_ jsonData: JSON) } class WelcomeHttpController: BaseHttpController { fileprivate weak var delegate: WelcomeHttpProtocol? fileprivate lazy var environmentService = EnvironmentService.shared fileprivate lazy var updateService = UpdateService() fileprivate lazy var userInfoService = UserInfoService() init(delegate: WelcomeHttpProtocol) { super.init() self.delegate = delegate } func requestLatestVersion(_ async: Bool) { let dataDic = NSMutableDictionary() dataDic[&amp;#34;rand&amp;#34;] = UUID().uuidString dataDic[&amp;#34;buildVersion&amp;#34;] = updateService.buildVersion dataDic[&amp;#34;pubVersion&amp;#34;] = updateService.publishVersion if let activeUser = userInfoService.activeUserEntity { dataDic[&amp;#34;pathID&amp;#34;] = activeUser.pathID } let metaDic = getDefaultMetaData(ConfigRequestAction.getLatestVersion) if async { startAsynchronousRequest(metaDic: metaDic, dataDic: dataDic, handler: {(response, data, error) -&amp;gt; Void in if error == nil { let jsonData = JSON(data: data!) self.delegate?.didReceiveLatestVersion(jsonData) } else { self.didError() } }) } else { if let result = startSynchronousRequest(metaDic: metaDic, dataDic: dataDic, timeoutInterval: 3) { if result.error == nil { let jsonData = JSON(data: result.data!) self.delegate?.didReceiveLatestVersion(jsonData) } else { self.didError() } } else { self.didError() } } } override func didError() { self.delegate?.didError() } } updateUIForLatestVersion 最后由AboutViewController作为代理实现updateUIForLatestVersion方法，用于更新该版本的提示
func updateUIForLatestVersion(shouldUpdate:Bool,updateMessage:String,updateUrl:String,minOSVersion: String?) { if shouldUpdate { if let minOS = minOSVersion { let minF = (minOS as NSString).floatValue let sysF = (UIDevice.current.systemVersion as NSString).floatValue if minF &amp;gt; sysF { let alertView = UIAlertView(title: &amp;#34;发现更新&amp;#34;, message: &amp;#34;最新版移事通已不再支持您的手机系统版本，请升级手机系统到\(minOS)或以上后再检查更新&amp;#34;, delegate: self, cancelButtonTitle: nil otherButtonTitles: &amp;#34;确定&amp;#34;.localized) alertView.tag = 102 alertView.show() return } } self.newAppUrl = updateUrl let alertVC = UIAlertView(title: &amp;#34;发现更新&amp;#34;.localized, message: &amp;#34;&amp;#34;, delegate: self, cancelButtonTitle: &amp;#34;取消&amp;#34;.localized, otherButtonTitles: &amp;#34;更新&amp;#34;.localized) alertVC.tag = 100 alertVC.extShow(.left, messageStr: updateMessage) } else { let alertView = FlashAlertView(message: &amp;#34;已经是最新版本&amp;#34;.localized, delegate: nil) alertView.show() } }  </content>
    </entry>
    
     <entry>
        <title>javascript 中this指针</title>
        <url>https://iihui.github.io/post/js-this/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>js</tag>
        </tags>
        <content type="html">  在JavaScript中，this是动态绑定，或称为运行期绑定的，这导致JavaScript中的this关键字具有多重含义。它可以是全局对象、当前对象或者任意对象，这完全取决于函数的调用方式。
  作为对象方法调用 在JS中，函数也是对象，因此函数可以作为一个对象的属性，此时该函数被称为该对象的方法，在使用这种调用方式时，this被自然地绑定到该对象。
var point = { x : 0, y : 0, moveTo : function(x, y) { this.x = this.x &#43; x; this.y = this.y &#43; y; } }; point.moveTo(1, 1)//this 绑定到当前对象，即 point 对象  作为函数调用 函数可以直接调用，此时this绑定到全局对象，在浏览器中，window就是该全局对象。在下面的例子中，函数调用时，this被绑定到全局对象，接下来执行赋值语句，相当于隐式的声明了一个全局变量。
function makeNoSense(x) { this.x = x; } makeNoSense(5); x;// x 已经成为一个值为 5 的全局变量 对于内部函数(即声明在另一个函数体中的函数)，如果使用this指针，那么绑定的是全局对象，会产生下面问题：
var point = { x: 0, y: 0, moveTo: function(x, y) { // 内部函数  var moveX = function(x) { this.x = x; //this 绑定到了哪里？  }; // 内部函数  var moveY = function(y) { this.y = y; //this 绑定到了哪里？  }; moveX(x); moveY(y); } }; point.moveTo(1, 1); point.x; //==&amp;gt;0 point.y; //==&amp;gt;0 x; //==&amp;gt;1 y; //==&amp;gt;1  这属于JavaScript的设计缺陷，正确的设计方式是内部函数的this应该绑定到其外层函数对应的对象上，为了规避这一缺陷，使用变量替换的方式：
var point = { x: 0, y: 0, moveTo: function(x, y) { var that = this; // 内部函数  var moveX = function(x) { that.x = x; }; // 内部函数  var moveY = function(y) { that.y = y; }; moveX(x); moveY(y); } }; point.moveTo(1, 1); point.x; //==&amp;gt;1 point.y; //==&amp;gt;1   作为构造函数调用 JavaScript支持面向对象编程，但它没有类的概念，而是使用基于原型prototype的继承方式。
相应的JavaScript中的构造函数也很特殊，如果不使用new调用，则和普通函数一样。约定俗成，构造函数以大写字母开头，以提醒调用者使用正确的方式调用。
function Point(x, y){ this.x = x; this.y = y; }  使用apply或call调用 在JS中函数也是对象，对象则有方法，apply和call就是函数对象的方法。他们允许切换函数执行的上下文环境context,即this绑定的对象。
function Point(x, y) { this.x = x; this.y = y; this.moveTo = function(x, y) { this.x = x; this.y = y; }; } var p1 = new Point(0, 0); var p2 = { x: 0, y: 0 }; p1.moveTo(1, 1); p1.moveTo.apply(p2, [10, 10]); //p1的方法应用到p2 函数存在①定义时上下文；②运行时上下文；③上下文是可以改变的。在JS中call和apply都是为了改变某个函数执行的上下文context而存在的，即是改变函数体内的this的指向。
var func = function(arg1, arg2) { //语句 }; func.call(this, arg1, arg2); func.apply(this, [arg1, arg2])  参考资料 参考资料 一定要看
 </content>
    </entry>
    
     <entry>
        <title>html 元素分类</title>
        <url>https://iihui.github.io/post/html-element-category/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>html</tag>
        </tags>
        <content type="html"> 元素分类 HTML元素，指的是从开始标签(start tag)到结束标签(end tag)的所有代码。 HTML元素包括顶级元素，块级元素，内联元素。
 顶级元素   html
  body
  frameset
   块级元素 以块显示的元素，高度宽度都是可以设置的。块级元素默认状态下每次都占据一整行，后面的内容也必须再新起一行显示。
块级元素能够独立存在，块级元素是构成HTML的主要元素，任意一个块级元素均可以用盒模型来解释说明，常用的块级元素有:
  div常用来组合块级元素，像几个小盒子组成的大盒子一样，作为一个分区。
  p 段落。
  h1~h6 标题。
  table 表格。
  ul 无序列表。
  ol 有序列表。
  li 列表项。
  hr 水平分隔线。
  form html 表单。
  dl 定义列表。
  blockquote 长引用。
   内联元素 内联元素是文本的显示方式，与块级元素相反，内联元素的高度和宽度是不可以设置的，其宽度就是自身文字和图片的宽度，内联元素需依附其他块级元素存在。
内联元素的显示不会独自占据一个行。内联元素可以变成块级元素，通过css的display:inline和float来实现。
常用内联元素
  span类似于div对于块元素的作用，span用来组合内联元素。
  a 链接
  input 输入框
  button 按钮
  select 单选和多选框
  br 换行
  textarea 多行文本输入
  b,big,i,em
  q 短引用
   </content>
    </entry>
    
     <entry>
        <title>盒子模型</title>
        <url>https://iihui.github.io/post/html-box-model/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>JS</tag>
        </tags>
        <content type="html">  W3C组织建议把网页上所有的对象都放在一个盒(box)中，设计师可以在对象创建时控制这个盒子的属性，这些对象包括段落、列表、标题、图片以及层。盒模型主要定义四个区域：内容(content)、内边距(padding)、边框(border)和外边距(margin)。
 模型图示 在CSS中margin是指从自身边框到另一个容器边框之间的距离，就是容器外距离。padding是指自身边框(border)到自身内容之间的距离，表示容器内距离。 下面是margin，background-color，background-image，padding，content，border盒模型的3D示意图:
 margin 外边距margin包括margin-top、margin-right、margin-bottom、margin-left，控制块级元素之间的距离，它们是透明不可见的。 根据上、右、下、左的顺时针规则,可以写成：margin: 40px 40px 40px 40px;当上下、 左右的margin值均一致，可简写margin: 40px 40px;当上下左右都相同时可以写成margin:40px;
 padding padding包括padding-top、padding-right、padding-bottom、padding-left，控制块级元素内部，content与boarder之间的距离。
body { padding: 36px;} //对象四边的补丁边距均为36px body { padding: 36px 24px; } //上下两边的补丁边距为36px，左右两边的补丁边距为24px body { padding: 36px 24px 18px; } //上、下两边的补丁边距分别为36px、18px，左右两边的补丁边距为24px body { padding: 36px 24px 18px 12px; } //上、右、下、左补丁边距分别为36px、24px、18px、12px  参考资料 参考资料
 </content>
    </entry>
    
     <entry>
        <title>selection 对象</title>
        <url>https://iihui.github.io/post/js-selection/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html">  在富文本编辑器中，需要控制光标的各种状态信息，位置信息。浏览器提供了selection对象和range对象来操作光标。
 selection Selection对象表示用户选择的文本范围或插入符号的当前位置。它代表页面中的文本选区，可能横跨多个元素(element)，文本选区由用户拖拽鼠标而产生。
let selection = window.getSelection(); 通常需要操作selection对象所对应的用户选择区(range)(俗称拖蓝)，获取方式为:
if (selection.rangeCount &amp;gt; 0) { let range = selection.getRangeAt(0); } //或者 if (selection.rangeCount) { let range = selection.getRangeAt(0); }  range对象 range对象代表页面上一段连续的区域，通过range对象可以获取或者修改页面上的任何区域，也可以通过Range的方法进行复制和移动页面上的任何区域。
  startContainer: range范围的起始节点。
  endContainer:range 范围的结束节点。
  startOffset: 如果startContainer是文本节点、注释节点、或者CDATA节点，则返回起点在startContainer中的字符偏移量，如果startContainer是元素节点，则返回起点在startContainer.childNodes中的次序。
  endOffset: 表示终点，含义与startOffset类似。
  commonAncestorContainer: 返回包含startContainer和endContainer的最近祖先节点。
  collapsed:返回一个用于判断range起始位置和终止位置是否相同的布尔值。
   range常用方法   setStart(node,offset):设置起点的位置，node是对startContainer的引用，偏移则是startOffset。
  setEnd(node,offset): 设置的终点的位置，node是对endContainer的引用，偏移则是endOffset。
  selectNode(referenceNode)：设置Range的范围，包括referenceNode和它的所有子孙节点。
  selectNodeContents(referenceNode)设置Range的范围，包括它的所有后代节点，但不包含referenceNode节点。与selectNode区别较大。
  collapse(bool): 向起点start折叠。
  insertNode(node): 在range的起始处插入节点。
  cloneRange(): 返回一个当前Range的副本
  function resetRange(startContainer, startOffset, endContainer, endOffset) { let selection = window.getSelection(); selection.removeAllRanges(); let range = document.createRange(); range.setStart(startContainer, startOffset); range.setEnd(endContainer, endOffset); selection.addRange(range); } 参考资料
 </content>
    </entry>
    
     <entry>
        <title>KVO 介绍</title>
        <url>https://iihui.github.io/post/ios-kvo/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>iOS</tag><tag>oc</tag><tag>swift</tag>
        </tags>
        <content type="html">  在应用开发中，经常需要使用观察者模式，以监听某些对象属性的变化，然后进行相应操作。OC提供了一套简洁优雅的观察方式——KVO。KVO(key-value observing)是一种通知机制，当指定的被观察者对象的属性被修改时，KVO会自动通知相应的观察者。KVO由NSKeyValueObserving协议提供支持，NSObject类继承了该协议，所以任何NSObject的子类都可使用该方法。
 KVO的使用 KVO的使用比较简单，只需要给对象的指定属性添加监听，并设置监听类型。每当对指定的属性进行读写操作时，OC就会调用observeValueForKeyPath方法，在observeValueForKeyPath中进行判断，确定是哪个对象的事件。
下面的例子是便实现一个属性值的监听。可总结为三步：第一步是添加监听；第二步是实现协议；第三步是移除监听：
Person *person = [Person alloc] init]; /* 作用:给对象绑定一个监听器(观察者) - Observer 观察者 - KeyPath 要监听的属性 - options 选项(方便在监听的方法中拿到属性值) */ [person addObserver:person forKeyPath:@&amp;#34;name&amp;#34; options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld context:nil]; // 移除监听 [person removeObserver:person forKeyPath:@&amp;#34;name&amp;#34;]; /** * 当监听的属性值发生改变 * * @param keyPath 要改变的属性 * @param object 要改变的属性所属的对象 * @param change 改变的内容 * @param context 上下文 */ - (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&amp;lt;NSString *,id&amp;gt; *)change context:(void *)context{ NSLog(@&amp;#34;%@------%@------%@&amp;#34;, keyPath, object, change); } 添加监听 //第一个参数 observer观察者 （这里观察self.myKVO对象的属性变化） //第二个参数 keyPath被观察的属性名称(这里观察 self.myKVO 中 num 属性值的改变) //第三个参数 options： 观察属性的新值、旧值等的一些配置（枚举值，可以根据需要设置，例如这里可以使用两项） //第四个参数 context： 上下文，可以为 KVO 的回调方法传值（例如设定为一个放置数据的字典） - (void)addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options context:(nullable void *)context; 实现协议 在回调方法中处理属性值发生变化。
//keyPath:属性名称 //object:被观察的对象 //change:变化前后的值都存储在change字典中 //context:注册观察者时，context 传过来的值  - (void)observeValueForKeyPath:(nullable NSString *)keyPath ofObject:(nullable id)object change:(nullable NSDictionary *)change context:(nullable void *)context; 移除观察者。 - (void)removeObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath; 注意事项 使用KVO消息传递机制有两个要求：
  观察者必须知道被观察者对象，即在同一作用域。
  观察者还需要知道被观察对象的生命周期，因为在销毁发送者对象之间，需要取消观察者的注册。
  Swift中属性观察器 在Swift中有两个属性观察者willSet和didSet,类似于触发器。用来监控属性除初始化之外的属性值变化，当属性值发生变化时可以对此作出响应。
 不仅可以在属性值发生变化后触发didSet,也可以在属性值改变前触发willSet。 给属性添加观察者必须要声明清楚属性的类型，否则编译器报错。 willSet可以带一个newName的参数，没有的话，默认命名为newValue。 didSet 可以带一个oldName的参数，表示旧的值，不带的话，默认命名为oldValue。 属性初始化时，willSet和didSet不会调用。只有初始化上下文之外，属性值发生变化时才会调用。 即使设置的值和原来的一样，willSet和didSet也会被调用。  var firstName: String = &amp;#34;First&amp;#34; { willSet { //新值设置之前被调用，在此可以进行条件筛选，过滤数据 print(&amp;#34;willSet的新值是\(newValue)&amp;#34;) } didSet { //新值设置之后立即调用，在此可以进行条件筛选，过滤数据,可以直接绑定数据到UI上面 print(&amp;#34;didSet的旧值是\(oldValue)--- 新值是 \(firstName)&amp;#34;) self.nameLabel.text = firstName } }  Swift实现KVO值监听 利用设计模式中的观察者模式，观察者定义了对象之间的一对多依赖。当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。观察者模式适用在一个被观察者（数据源）要通知多个观察者的场景。
参考资料 参考资料
 </content>
    </entry>
    
     <entry>
        <title>UITableView</title>
        <url>https://iihui.github.io/post/ios-uitableview/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html">  UITableView可以显示多行多组数据,创建表格视图有两种风格，一种为Plain，另一种为Grouped。
 点击不变色 func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&amp;gt; UITableViewCell { let cellId = &amp;#34;noteDetailInfoCell&amp;#34; let cell = tableView.dequeueReusableCell(withIdentifier: cellId, for: indexPath) as! NoteDetailInfoCell cell.titleLabel.text = info[indexPath.row&#43;1].0 cell.titleLabel.textColor = &amp;#34;878997&amp;#34;.extHexStringToUIColor() cell.infoLabel.text = info[indexPath.row&#43;1].1 cell.infoLabel.textColor = &amp;#34;4b5169&amp;#34;.extHexStringToUIColor() self.notetitleLabel.text = info[0].1 cell.selectionStyle = .none //点击某行不变色 return cell } 链接
range
 </content>
    </entry>
    
     <entry>
        <title>给图片添加点击监听</title>
        <url>https://iihui.github.io/post/js-img/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>js</tag>
        </tags>
        <content type="html"> 给所有图片添加监听 function setImagesClick(){ $(&amp;#39;body&amp;#39;).on(&amp;#39;click&amp;#39;,&amp;#39;img&amp;#39;,function(){ let position = this.offsetTop; //当前元素距离顶部的距离  //window.scrollTo(0,position)  let result = {}; result.position = position.toString() let jsonString = JSON.stringify(result); let escapedJsonString = encodeURI(jsonString); //重新编码  let scheme = &amp;#34;position://&amp;#34;; document.location.href = scheme &#43; &amp;#34;#&amp;#34; &#43; escapedJsonString; //向ios发送  }); } 参考资料
 </content>
    </entry>
    
     <entry>
        <title>RunLoop</title>
        <url>https://iihui.github.io/post/ios-runloop/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html"> 概念 一般来讲，一个线程一次只能执行一个任务，执行完成后，线程就会退出。若我们需要一个机制，让线程能随时处理事件但并不退出，通常的代码逻辑是下面这样的：
function loop() { initialize(); do { var message = get_next_message(); process_message(message); } while (message != quit); } 这种模型被称为Event Loop,实现这种模型的关键点在于：
 如何管理事件/消息 如何让线程在没有处理消息时休眠以避免资源占用，在有消息到来时立刻被唤醒。  因此，RunLoop实质上是一个对象，这个对象管理了其需要处理的事件和消息
参考资料
</content>
    </entry>
    
     <entry>
        <title>权限检查</title>
        <url>https://iihui.github.io/post/ios-authority/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html"> 相机权限检查 相机和音频的权限分为4种，分别是.denied,restricted,.authorized,.notDetermined,.authorized四种:
  .denied 未授权，用户曾经选择过拒绝授权。
  .authorized 已经授权。
  .restricted 未授权，例如家长控制。
  .notDetermined 没有询问过用户是否授权，所以是未确定状态。
  //MARK:检查相机访问权限 func cameraPermissionCheck(){ let authStatus = AVCaptureDevice.authorizationStatus(forMediaType: AVMediaTypeVideo) switch authStatus { case .denied, .restricted: let alert = UIAlertController(title: &amp;#34;提示&amp;#34;.localized, message: CameraAccessMsg, preferredStyle: .alert) let settingAction = UIAlertAction(title: &amp;#34;去设置&amp;#34;.localized, style: .default) { (_) in let url = NSURL(string: UIApplicationOpenSettingsURLString)! if UIApplication.shared.canOpenURL(url as URL){ UIApplication.shared.openURL(url as URL) } } let cancelAction = UIAlertAction(title: &amp;#34;取消&amp;#34;.localized, style: .cancel) { (_) in DPrint(&amp;#34;cancel!&amp;#34;) } alert.addAction(settingAction) alert.addAction(cancelAction) self.present(alert, animated: true, completion: nil) default:break } } func cameraPermissionCheck(){ let msg = &amp;#34;没有相机访问权限，请移步到设置--&amp;gt;隐私--&amp;gt;相机--&amp;gt;APP&amp;#34; let authStatus = AVCaptureDevice.authorizationStatus(for: .video) switch authStatus { case .denied, .restricted,.notDetermined: let alert = UIAlertController(title: &amp;#34;提示&amp;#34;, message: msg, preferredStyle: .alert) let settingAction = UIAlertAction(title: &amp;#34;去设置&amp;#34;, style: .default) { (_) in let url = URL(string: UIApplicationOpenSettingsURLString) if let cameraURL = url,UIApplication.shared.canOpenURL(cameraURL){ UIApplication.shared.open(cameraURL, options: [:], completionHandler: nil) } } let cancelAction = UIAlertAction(title: &amp;#34;取消&amp;#34;, style: .cancel) { (_) in print(&amp;#34;点击了取消&amp;#34;) } alert.addAction(settingAction) alert.addAction(cancelAction) self.present(alert, animated: true, completion: nil) default:break } } override func viewDidAppear(_ animated: Bool) { super.viewDidAppear(animated) cameraPermissionCheck() }  麦克风权限检查 let status = AVCaptureDevice.authorizationStatus(forMediaType: AVMediaTypeAudio) if status == .denied || status == .restricted { let message = &amp;#34;麦克风访问权限被禁用，请前往系统设置-&amp;gt;隐私-&amp;gt;麦克风中，启用本程序对麦克风的访问权限&amp;#34;.localized let tipsAlertController = UIAlertController(title: &amp;#34;提示&amp;#34;.localized, message: message, preferredStyle: .alert) let confirm = UIAlertAction(title: &amp;#34;去设置&amp;#34;.localized, style: .default){ (_) in let url = NSURL(string: UIApplicationOpenSettingsURLString)! if UIApplication.shared.canOpenURL(url as URL) { UIApplication.shared.openURL(url as URL) } } let cancelAction = UIAlertAction(title: &amp;#34;取消&amp;#34;.localized, style: .cancel) { (_) in self.dismiss(animated: true, completion: nil) } tipsAlertController.addAction(confirm) tipsAlertController.addAction(cancelAction) self.present(tipsAlertController, animated: true, completion: nil) } 参考资料
 </content>
    </entry>
    
     <entry>
        <title>透明度渐变动画</title>
        <url>https://iihui.github.io/post/ios-animation/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html"> CABasicAnimation关键帧动画 所谓关键帧动画，就是将Layer的属性作为KeyPath来注册，只要指定动画的起始帧和结束帧，然后自动计算和实现中间的过度的一种动画方式。
func recordingButtonAnimation(){ let animation = CABasicAnimation(keyPath: &amp;#34;opacity&amp;#34;) animation.fromValue = 1.0 animation.toValue = 0.3 animation.fillMode = kCAFillModeForwards animation.isRemovedOnCompletion = false animation.duration = self.animationDuration self.recordButton.layer.add(animation, forKey: nil) } //添加定时器 if recordingAnimationTimer == nil{ recordingAnimationTimer = Timer.scheduledTimer(timeInterval: self.animationDuration, target: self, selector: #selector(recordingButtonAnimation), userInfo: nil, repeats: true) } //销毁定时器 self.recordingAnimationTimer?.invalidate() //移除动画层 self.recordButton.layer.removeAllAnimations() 属性说明：
 duration动画时长，默认为0,不设置的话会快速执行完动画 speed 执行速度，默认为1倍速度，如果设置了该属性，则执行时长为$\frac{duration}{speed}$ repeatCount重复次数，默认为0，如果需要设置为永久的话可以设置为HUGE_VALE autoreverses 动画执行完是否执行逆动画，默认不执行 fromValue 开始值 toValue 结束值  CABasicAnimation执行完动画后会回归动画开始的状态，如果想要让它变成动画执行最后的状态，设置一下两个属性：
animation.removedOnCompletion = false animation.fillMode = kCAFillModeForwards 如果要设置永久重复，则需要将repeatCount的值置为HUGE或者.greatestFiniteMagnitude。
let animation = CABasicAnimation(keyPath: &amp;#34;opacity&amp;#34;) animation.duration = 1.0 animation.repeatCount = .greatestFiniteMagnitude//HUGE animation.autoreverses = true animation.fromValue = 1.0 animation.toValue = 0.0 testButton.layer.add(animation, forKey: nil) 当给一个CALayer添加动画时，动画其实并没有改变这个Layer的实质属性，取而代之，系统会创建一个原始Layer的拷贝。苹果称这个原始Layer为Model Layer，而这个复制的Layer被称为Presentation Layer。
Presentation Layer的属性会随着动画的进度实时改变，而Model Layer中对应的属性不会发生变化。默认情况下，系统会在duration时间后自动移除CAKeyframeAnimation。当移除某个动画后，系统会自动销毁这个Layer的Presentation Layer，只留下Model Layer。因为Model Layer的属性没有发生变化，所以视图一瞬间就回到了动画的初始状态。要解决这种状态需要先把removeOnCompletion设置为false,然后设置fillMode为kCAFillModeForwards。
animation.removedOnCompletion = false animation.fillMode = kCAFillModeForwards 关于fillMode它有四个值：
 KCAFillModelRemoved 这个是默认值，表示动画开始前和结束后对Model Layer没有影响，动画结束会回到视图的初始状态。 kCAFillModeForwards 当动画结束后，Model Layer会保持动画的最后状态。 kCAFillModeBackwards 在动画开始前，只要将动画加入到一个Layer,则Layer立即进入动画的初始状态并等待动画开始。 kCAFillModeBoth 动画加入Layer后，Layer便处于初始状态，动画结束后Layer保持最后的状态。   添加引导动画 fileprivate var guideImageView:UIImageView? private let guideKey = &amp;#34;GUIDE_NOTE_SPEECH_KEY&amp;#34; //应用级别的引导，如果增加用户的id，则是用户级别的引导 func showGuide(){ let isShowed = UserDefaults.standard.value(forKey: self.guideKey) if isShowed == nil { let guideImage = UIImage(named: &amp;#34;guide_note_speech&amp;#34;) if self.guideImageView == nil{ self.guideImageView = UIImageView(image: guideImage) let width:CGFloat = 132 let height:CGFloat = 100 let x = bottomView.bounds.width/2 &#43; 15 let y = topView.bounds.size.height &#43; centerView.bounds.size.height &#43; soundWaveView.bounds.size.height - height &#43; 20 if let guideView = self.guideImageView{ self.guideImageView?.frame = CGRect(x: x, y: y, width: width, height: height) self.view.addSubview(guideView) let startPoint = CGPoint(x: 0, y: 1) setAnchorPoint(point: startPoint, view: guideView) UIView.animate(withDuration: 1.2, delay: 0, options: [.repeat, .autoreverse], animations: { guideView.transform = CGAffineTransform(scaleX: 0.8, y: 0.8) }, completion:nil) } } } } 需要注意的是：因为上面的函数涉及到bounds的计算，因此guideShow函数应当放到viewDidLayoutSubviews()中，或者viewDidAppear(_ animated: Bool)中，经过试验，发现如果放到viewDidLayoutSubviews()中，图片会变黑很多。
override func viewDidLayoutSubviews() { super.viewDidLayoutSubviews() showGuide() } override func viewDidAppear(_ animated: Bool) { super.viewDidAppear(animated) showGuide() } 取消引导动画时，首先应当移除引导的imageview，并将key记录到plist文件中。如果设置时用户点击某个按钮时移除引导，则将如下代码添加到相应UIButton的响应函数中：
if let guideView = self.guideImageView{ self.removeGuide(view: guideView) } func removeGuide(view:UIView) { view.removeFromSuperview() UserDefaults.standard.setValue(true, forKey: self.guideKey) } 如果是用户点击imageView的任何地方，移除引导，则应先在imageView里添加手势，如下所示：
func tapGuide(gesture: UITapGestureRecognizer) { gesture.view?.removeFromSuperview() UserDefaults.standard.setValue(true, forKey: self.guideKey) } guideImageView.isUserInteractionEnabled = true let tapGesture = UITapGestureRecognizer(target: self, action: #selector(tapGuide(gesture:))) guideImageView.addGestureRecognizer(tapGesture) 适配iPad添加横竖屏的支持
private let guideKey = &amp;#34;GUIDE_NOTE_SPEECH_KEY12&amp;#34; func showGuide(){ let isShowed = UserDefaults.standard.value(forKey: self.guideKey) if isShowed == nil { self.guideImageView?.removeFromSuperview() let guideImage = UIImage(named: &amp;#34;guide_note_speech&amp;#34;) self.guideImageView = UIImageView(image: guideImage) let width:CGFloat = 132 let height:CGFloat = 100 let bounds = UIScreen.main.bounds let x = bounds.size.width/2 &#43; 20 var y = bounds.size.height - self.bottomView.bounds.size.height - height if let navHeight = self.navigationController?.navigationBar.bounds.size.height{ y -= navHeight } if let guideView = self.guideImageView{ self.guideImageView?.frame = CGRect(x: x, y: y, width: width, height: height) guideView.alpha = 0.8 self.view.addSubview(guideView) let startPoint = CGPoint(x: 0, y: 1) setAnchorPoint(point: startPoint, view: guideView) UIView.animate(withDuration: 1.6, delay: 0, options: [.repeat, .autoreverse], animations: { guideView.transform = CGAffineTransform(scaleX: 0.8, y: 0.8) }, completion:nil) } } } 参考资料 参考资料 参考资料 参考资料
 同时添加两个效果 let transformA = CGAffineTransform(scaleX: 0.5, y: 0.5) let transformB = CGAffineTransform(translationX:100, y：100) guideImageView.transform = transformA.concatenating(transformB) 参考资料
 </content>
    </entry>
    
     <entry>
        <title>透明度渐变动画</title>
        <url>https://iihui.github.io/post/ios-opicity-animation/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html"> CABasicAnimation关键帧动画 所谓关键帧动画，就是将Layer的属性作为KeyPath来注册，只要指定动画的起始帧和结束帧，然后自动计算和实现中间的过度的一种动画方式。
func recordingButtonAnimation(){ let animation = CABasicAnimation(keyPath: &amp;#34;opacity&amp;#34;) animation.fromValue = 1.0 animation.toValue = 0.3 animation.fillMode = kCAFillModeForwards animation.isRemovedOnCompletion = false animation.duration = self.animationDuration self.recordButton.layer.add(animation, forKey: nil) } //添加定时器 if recordingAnimationTimer == nil{ recordingAnimationTimer = Timer.scheduledTimer(timeInterval: self.animationDuration, target: self, selector: #selector(recordingButtonAnimation), userInfo: nil, repeats: true) } //销毁定时器 self.recordingAnimationTimer?.invalidate() //移除动画层 self.recordButton.layer.removeAllAnimations() 属性说明：
 duration动画时长，默认为0,不设置的话会快速执行完动画 speed 执行速度，默认为1倍速度，如果设置了该属性，则执行时长为$\frac{duration}{speed}$ repeatCount重复次数，默认为0，如果需要设置为永久的话可以设置为HUGE_VALE autoreverses 动画执行完是否执行逆动画，默认不执行 fromValue 开始值 toValue 结束值  CABasicAnimation执行完动画后会回归动画开始的状态，如果想要让它变成动画执行最后的状态，设置一下两个属性：
animation.removedOnCompletion = false animation.fillMode = kCAFillModeForwards 如果要设置永久重复，则需要将repeatCount的值置为HUGE或者.greatestFiniteMagnitude。
let animation = CABasicAnimation(keyPath: &amp;#34;opacity&amp;#34;) animation.duration = 1.0 animation.repeatCount = .greatestFiniteMagnitude//HUGE animation.autoreverses = true animation.fromValue = 1.0 animation.toValue = 0.0 testButton.layer.add(animation, forKey: nil)  添加引导动画 fileprivate var guideImageView:UIImageView? private let guideKey = &amp;#34;GUIDE_NOTE_SPEECH_KEY&amp;#34; //应用级别的引导，如果增加用户的id，则是用户级别的引导 func showGuide(){ let isShowed = UserDefaults.standard.value(forKey: self.guideKey) if isShowed == nil { let guideImage = UIImage(named: &amp;#34;guide_note_speech&amp;#34;) if self.guideImageView == nil{ self.guideImageView = UIImageView(image: guideImage) let width:CGFloat = 132 let height:CGFloat = 100 let x = bottomView.bounds.width/2 &#43; 15 let y = topView.bounds.size.height &#43; centerView.bounds.size.height &#43; soundWaveView.bounds.size.height - height &#43; 20 if let guideView = self.guideImageView{ self.guideImageView?.frame = CGRect(x: x, y: y, width: width, height: height) self.view.addSubview(guideView) let startPoint = CGPoint(x: 0, y: 1) setAnchorPoint(point: startPoint, view: guideView) UIView.animate(withDuration: 1.2, delay: 0, options: [.repeat, .autoreverse], animations: { guideView.transform = CGAffineTransform(scaleX: 0.8, y: 0.8) }, completion:nil) } } } } 需要注意的是：因为上面的函数涉及到bounds的计算，因此guideShow函数应当放到viewDidLayoutSubviews()中，或者viewDidAppear(_ animated: Bool)中，经过试验，发现如果放到viewDidLayoutSubviews()中，图片会变黑很多。
override func viewDidLayoutSubviews() { super.viewDidLayoutSubviews() showGuide() } override func viewDidAppear(_ animated: Bool) { super.viewDidAppear(animated) showGuide() } 取消引导动画时，首先应当移除引导的imageview，并将key记录到plist文件中。如果设置时用户点击某个按钮时移除引导，则将如下代码添加到相应UIButton的响应函数中：
if let guideView = self.guideImageView{ self.removeGuide(view: guideView) } func removeGuide(view:UIView) { view.removeFromSuperview() UserDefaults.standard.setValue(true, forKey: self.guideKey) } 如果是用户点击imageView的任何地方，移除引导，则应先在imageView里添加手势，如下所示：
func tapGuide(gesture: UITapGestureRecognizer) { gesture.view?.removeFromSuperview() UserDefaults.standard.setValue(true, forKey: self.guideKey) } guideImageView.isUserInteractionEnabled = true let tapGesture = UITapGestureRecognizer(target: self, action: #selector(tapGuide(gesture:))) guideImageView.addGestureRecognizer(tapGesture) 适配iPad添加横竖屏的支持
private let guideKey = &amp;#34;GUIDE_NOTE_SPEECH_KEY12&amp;#34; func showGuide(){ let isShowed = UserDefaults.standard.value(forKey: self.guideKey) if isShowed == nil { self.guideImageView?.removeFromSuperview() let guideImage = UIImage(named: &amp;#34;guide_note_speech&amp;#34;) self.guideImageView = UIImageView(image: guideImage) let width:CGFloat = 132 let height:CGFloat = 100 let bounds = UIScreen.main.bounds let x = bounds.size.width/2 &#43; 20 var y = bounds.size.height - self.bottomView.bounds.size.height - height if let navHeight = self.navigationController?.navigationBar.bounds.size.height{ y -= navHeight } if let guideView = self.guideImageView{ self.guideImageView?.frame = CGRect(x: x, y: y, width: width, height: height) guideView.alpha = 0.8 self.view.addSubview(guideView) let startPoint = CGPoint(x: 0, y: 1) setAnchorPoint(point: startPoint, view: guideView) UIView.animate(withDuration: 1.6, delay: 0, options: [.repeat, .autoreverse], animations: { guideView.transform = CGAffineTransform(scaleX: 0.8, y: 0.8) }, completion:nil) } } } 参考资料 参考资料 参考资料 参考资料
 同时添加两个效果 let transformA = CGAffineTransform(scaleX: 0.5, y: 0.5) let transformB = CGAffineTransform(translationX:100, y：100) guideImageView.transform = transformA.concatenating(transformB) 参考资料
 </content>
    </entry>
    
     <entry>
        <title>Gif的播放与暂停</title>
        <url>https://iihui.github.io/post/ios-gif/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html">  Gif的播放有两种方式，一种是通过UIWebview；一种是通过UIImageView的方式。使用UIWebview的缺点是不可以暂停。
 UIWebView import UIKit class ViewController: UIViewController { override func viewDidLoad() { super.viewDidLoad() guard let path = Bundle.main.path(forResource: &amp;#34;demo&amp;#34;, ofType:&amp;#34;gif&amp;#34;) else{ return } let url = URL(fileURLWithPath: path) do{ let gifData = try Data(contentsOf: url) let webView = UIWebView() webView.frame = CGRect(x: 0, y: 100, width: self.view.frame.width, height: 600) webView.scalesPageToFit = true webView.load(gifData, mimeType: &amp;#34;image/gif&amp;#34;, textEncodingName: String(), baseURL: NSURL() as URL) self.view.addSubview(webView) }catch{} } }  UIImageView 使用UIImageView播放GIF有两个要点：一是从gif文件中获取图片数组，二是获取gif文件的播放时长。
import UIKit class ViewController: UIViewController { override func viewDidLoad() { super.viewDidLoad() let imageView = UIImageView() imageView.frame = CGRect(x: 0, y: 100, width: self.view.frame.width, height: 600) self.view.addSubview(imageView) guard let path = Bundle.main.path(forResource: &amp;#34;demo&amp;#34;, ofType:&amp;#34;gif&amp;#34;) else{ return } let url = URL(fileURLWithPath: path) do{ let gifData = try Data(contentsOf: url) guard let imageSource = CGImageSourceCreateWithData(gifData as CFData, nil) else { return } let imageCount = CGImageSourceGetCount(imageSource) var images = [UIImage]() var gifDuration:TimeInterval = 0 for index in 0..&amp;lt;imageCount{ guard let cgImage = CGImageSourceCreateImageAtIndex(imageSource, index, nil) else{ return } let image = UIImage(cgImage: cgImage) images.append(image) if index == 0{ imageView.image = image } var tmpProperty:NSDictionary? if let tmp = CGImageSourceCopyPropertiesAtIndex(imageSource, index, nil){ tmpProperty = tmp as NSDictionary if let property = tmpProperty{ guard let gifDic = property[kCGImagePropertyGIFDelayTime] as? NSDictionary else{ continue } guard let imageDuration = gifDic[kCGImagePropertyGIFDelayTime] as? NSNumber else{ continue } gifDuration &#43;= imageDuration.doubleValue } } } imageView.animationImages = images imageView.animationDuration = gifDuration imageView.animationRepeatCount = 10 imageView.startAnimating() }catch{} } } 参考资料
 </content>
    </entry>
    
     <entry>
        <title>iOS视频开发入门</title>
        <url>https://iihui.github.io/post/ios-video/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html"> 视频实质 纯粹的视频（不包括音频）实质上就是一组帧图片，经过视频编码成为视频(video)文件再把音频（audio）文件以及字幕文件组装在一起成为视频（movie）文件。
1秒内出现的图片数就是帧率，图片间隔越小画面就越流畅，所以帧率越高效果就越好，需要的存储空间也就越多。
 录制视频的3种实现方式   UIImagePickerViewController：只能设置一些简单的参数来实现基本的视频录制的效果，自定义程度不高。
  AVFoundation：苹果提供的底层多媒体框架，用于音视频采集、解码、视频编辑等，使用AVFoundation进行视频录制有以下两种方式：
  AVCaptureSession &#43; AVCaptureMoiveFileOutput。
  AVCaptureSession &#43; AVAssetWriter。
     UIImagePickerController 这种方式只能设置一些简单的参数，自定义程度不高，只能自定义界面上的操作按钮以及视频的画质：
- (void)viewDidLoad { [super viewDidLoad]; if ([self isVideoRecordingAvailable]) { return; } self.sourceType = UIImagePickerControllerSourceTypeCamera; self.mediaTypes = @[(NSString *)kUTTypeMovie]; self.delegate = self; //隐藏系统自带UI  self.showsCameraControls = NO; //设置摄像头  [self switchCameraIsFront:NO]; //设置视频画质类别  self.videoQuality = UIImagePickerControllerQualityTypeMedium; //设置散光灯类型  self.cameraFlashMode = UIImagePickerControllerCameraFlashModeAuto; //设置录制的最大时长  self.videoMaximumDuration = 20; } - (BOOL)isVideoRecordingAvailable { if([UIImagePickerController isSourceTypeAvailable:UIImagePickerControllerSourceTypeCamera]){ NSArray *availableMediaTypes = [UIImagePickerController availableMediaTypesForSourceType:UIImagePickerControllerSourceTypeCamera]; if([availableMediaTypes containsObject:(NSString *)kUTTypeMovie]){ return YES; } } return NO; } - (void)switchCameraIsFront:(BOOL)front { if (front) { if([UIImagePickerController isCameraDeviceAvailable:UIImagePickerControllerCameraDeviceFront]){ [self setCameraDevice:UIImagePickerControllerCameraDeviceFront]; } } else { if([UIImagePickerController isCameraDeviceAvailable:UIImagePickerControllerCameraDeviceRear]){ [self setCameraDevice:UIImagePickerControllerCameraDeviceRear]; } } }  AVCaptureSession&#43;AVCaptureMovieFileOutput 采用AVCaptureSession&#43;AVCaptureMovieFileOutput进行视频录制一般要经过以下6步：
 创建捕捉会话AVCaptureSession,用于控制input到output的流向。 设置视频的输入设备 AVCaptureDeviceInput，用于视频采集，然后将设备绑定到AVCaptureSession的输入口input中。 设置音频输入设备 AVCaptureDeviceInput，用于音频采集，然后将设备绑定到AVCaptureSession的输入口input中。 设置输出源AVCaptureMovieFileOutput。此时音频和视频会合并在一起，在代理方法中也可以单独拿到视频或者音频数据，给AVCaptureMovieFileOutput指定路径，开始录制之后就会向这个路径写入数据。 添加视频预览层。 开始采集数据，这个时候还没有写入数据，用户点击录制后就可以开始写入数据。  如果需要对视频进行实时处理，则需要对相机缓冲区中的视频流进行处理：
 定义一个视频数据输出AVCaptureVideoDataOutput,并将其添加到Session上。 设置接受的Controller作为视频数据输出缓冲区Sample Buffer的代理。 实现代理方法。   参考资料 参考资料
 AVCaptureSession&#43;AVAssetWriter 基本流程为
 创建捕捉会话 设置视频的输入和输出 设置音频的输入和输出 添加视频预览层 开始采集数据，这个时候还没有写入数据，用户点击录制的时候才开始写入数据 初始化AVAssetWriter，我们会拿到视频和音频数据流，用AVAssetWriter写入文件，这一步需要自己实现。    录制视频开启蓝牙录音 思路是先判断是否有蓝牙或者耳机插入，如果有则将其设置为音频输入源，否则使用默认的麦克风，应当注意的是要在设置了音频输入源之后，再设置self.captureSession.usesApplicationAudioSession = true和self.captureSession.automaticallyConfiguresApplicationAudioSession = false。
fileprivate var isBlueToothAvailable = false fileprivate var audioSession = AVAudioSession.sharedInstance() func isBlueToothConnected()-&amp;gt;Bool{ let route = AVAudioSession.sharedInstance().currentRoute for item in route.outputs{ if item.portType == AVAudioSessionPortHeadphones || item.portType == AVAudioSessionPortBluetoothA2DP{ self.isBlueToothAvailable = true return true } } return false } if isBlueToothConnected(){ do{ try audioSession.setCategory(AVAudioSessionCategoryPlayAndRecord, with: AVAudioSessionCategoryOptions.allowBluetooth) }catch{} } if self.isBlueToothAvailable { self.captureSession.usesApplicationAudioSession = true self.captureSession.automaticallyConfiguresApplicationAudioSession = false } 参考资料
 </content>
    </entry>
    
     <entry>
        <title>HTML入门</title>
        <url>https://iihui.github.io/post/htm-primer/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>html</tag>
        </tags>
        <content type="html"> 简介 HTML指的是超文本标记语言 (Hyper Text Markup Language)，它不是一种编程语言，而是一种标志语言，标记语言是一套标记标签，使用标记标签来描述网页。
 .htm or .html 当保存HTML文件时，可以使用.htm,也可以使用.html文件后缀。使用.htm,这只是长久以来形成的习惯，因为过去的很多软件只允许三个字母的文件后缀。对于新的软件，使用.html完全没有问题。
 HTML标签 HTML标签是由尖括号包围的关键词，比如&amp;lt;html&amp;gt;。标签通常是成对出现的「也有可能是单个出现」，比如&amp;lt;b&amp;gt;和&amp;lt;/b&amp;gt;；标签对中的第一个标签时开始标签，第二个标签是结束标签。
 HTML元素 HTML文档用于描述网页「HTML文档也被称为网页」，文档包含HTML标签和纯文本。HTML元素，指的是从开始标签(start tag)到结束标签(end tag)的所有代码。元素的内容是开始标签与结束标签之间的内容。
某些HTML元素具有空内容，没有内容的HTML元素被称为空元素,空元素在开始标签中进行关闭。
&amp;lt;html lang=&amp;#34;en&amp;#34;&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;#34;UTF-8&amp;#34;&amp;gt; &amp;lt;meta name=&amp;#34;viewport&amp;#34; content=&amp;#34;width=device-width, initial-scale=1.0&amp;#34;&amp;gt; &amp;lt;meta http-equiv=&amp;#34;X-UA-Compatible&amp;#34; content=&amp;#34;ie=edge&amp;#34;&amp;gt; &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;div&amp;gt;测试&amp;lt;/div&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt;  HTML属性 大多数HTML元素可拥有属性,属性提供了有关HTML元素的更多的信息，属性总是以名称/值对的形式出现，比如：name=&amp;quot;value&amp;quot;：
  属性总是在HTML元素的开始标签中规定。
  属性和属性值对大小写不敏感。不过，万维网联盟在其HTML 4 推荐标准中推荐小写的属性/属性值。而新版本的(X)HTML要求使用小写属性。
  属性值应该始终被包括在引号内，双引号是最常用的，不过使用单引号也没有问题。
  &amp;lt;a href=&amp;#34;http://www.w3school.com.cn&amp;#34;&amp;gt;This is a link&amp;lt;/a&amp;gt;  外部样式表 &amp;lt;head&amp;gt; &amp;lt;link rel=&amp;#34;stylesheet&amp;#34; type=&amp;#34;text/css&amp;#34; href=&amp;#34;mystyle.css&amp;#34;&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;head&amp;gt; &amp;lt;link href=&amp;#34;./style.css&amp;#34; rel=&amp;#34;stylesheet&amp;#34; type=&amp;#34;text/css&amp;#34;&amp;gt; &amp;lt;/head&amp;gt;  内部样式表 &amp;lt;head&amp;gt; &amp;lt;style type=&amp;#34;text/css&amp;#34;&amp;gt; body {background-color: red} p {margin-left: 20px} &amp;lt;/style&amp;gt; &amp;lt;/head&amp;gt;  内联样式表 &amp;lt;p style=&amp;#34;color: red; margin-left: 20px&amp;#34;&amp;gt; This is a paragraph &amp;lt;/p&amp;gt;  超链接 超链接可以是一个字，一个词，或者一组词，也可以是一副图像，你可以点击这些内容来跳转到新的文档或者当前文档的某个部分。
通过使用&amp;lt;a&amp;gt;标签在HTML中创建新链接，可以有两种使用超链接的方式：
  通过使用href属性创建指向另一个文档的链接。
  通过使用name属性，创建文档内的书签（锚）。
   页面间跳转 &amp;lt;a href=&amp;#34;http://www.w3school.com.cn/&amp;#34;&amp;gt;Visit W3School&amp;lt;/a&amp;gt; &amp;lt;a href=&amp;#34;http://www.w3school.com.cn/html/html_links.asp#tips&amp;#34;&amp;gt;有用的提示&amp;lt;/a&amp;gt;&amp;lt;!--从其他页面创建指向该页面的锚--&amp;gt;  页面内跳转 页面内的跳转需要两个步骤：
  设置一个锚点链接&amp;lt;a href=&amp;quot;#miao&amp;quot;&amp;gt;去找喵星人&amp;lt;/a&amp;gt;。需要注意的是要在href的属性值value前加#。
  在页面中需要的位置设置一个锚点&amp;lt;a name=&amp;quot;miao&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;，标签中按需填写必要的文字，一般不写内容。设置锚点有两种方式
  &amp;lt;a name=&amp;quot;miao&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;。
  &amp;lt;h3 id=&amp;quot;miao&amp;quot;&amp;gt;喵星人基地&amp;lt;/h3&amp;gt;。这种方式不用单独添加一个a标签来设置锚点。
    &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;#34;utf-8&amp;#34;&amp;gt; &amp;lt;title&amp;gt;测试&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;ul&amp;gt; &amp;lt;li&amp;gt;&amp;lt;a href=&amp;#34;#miao&amp;#34;&amp;gt;去找喵星人&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;!--同一个文档中创建指向该锚的链接--&amp;gt; &amp;lt;li&amp;gt;&amp;lt;a href=&amp;#34;#wang&amp;#34;&amp;gt;去找汪星人&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;!--同一个文档中创建指向该锚的链接--&amp;gt; &amp;lt;li&amp;gt;&amp;lt;a href=&amp;#34;#meng&amp;#34;&amp;gt;其他萌物&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;!--同一个文档中创建指向该锚的链接--&amp;gt; &amp;lt;/ul&amp;gt; &amp;lt;a name=&amp;#34;miao&amp;#34;&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;!--设置锚点方法1--&amp;gt; &amp;lt;h3 id=&amp;#34;miao&amp;#34;&amp;gt;喵星人基地&amp;lt;/h3&amp;gt;&amp;lt;!--设置锚点方法2--&amp;gt; &amp;lt;p&amp;gt;喵喵喵~&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt;喵喵喵~&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt;喵喵喵~&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt;喵喵喵~&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt;喵喵喵~&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt;喵喵喵~&amp;lt;/p&amp;gt; &amp;lt;a name=&amp;#34;wang&amp;#34;&amp;gt;&amp;lt;/a&amp;gt; &amp;lt;p&amp;gt;汪汪汪~&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt;汪汪汪~&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt;汪汪汪~&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt;汪汪汪~&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt;汪汪汪~&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt;汪汪汪~&amp;lt;/p&amp;gt; &amp;lt;a name=&amp;#34;meng&amp;#34;&amp;gt;&amp;lt;/a&amp;gt; &amp;lt;p&amp;gt;萌萌萌~&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt;萌萌萌~&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt;萌萌萌~&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt;萌萌萌~&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt;萌萌萌~&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt;萌萌萌~&amp;lt;/p&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; 参考资料
 图片 在HTML中，图像由&amp;lt;img&amp;gt;标签定义，&amp;lt;img&amp;gt;是空标签，即只包含属性，没有闭合标签。
&amp;lt;img src=&amp;#34;https://i.loli.net/2018/12/06/5c09153160635.jpg&amp;#34; alt=&amp;#34;none&amp;#34;&amp;gt; &amp;lt;!--`alt`属性表示当图片找不到时，应该显示的替换文本--&amp;gt;  span标签 span标签表示无语义行内元素，常用来组合文档内的行内元素，以便通过样式来格式化它们。
 类 可以为元素表设置类，然后为相同的类定义CSS样式：
&amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;style&amp;gt; .cities { background-color:black; color:white; margin:20px; padding:20px; } &amp;lt;/style&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;div class=&amp;#34;cities&amp;#34;&amp;gt; &amp;lt;h2&amp;gt;London&amp;lt;/h2&amp;gt; &amp;lt;p&amp;gt;London is the capital city of England. It is the most populous city in the United Kingdom, with a metropolitan area of over 13 million inhabitants.&amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div class=&amp;#34;cities&amp;#34;&amp;gt; &amp;lt;h2&amp;gt;Paris&amp;lt;/h2&amp;gt; &amp;lt;p&amp;gt;Paris is the capital and most populous city of France.&amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div class=&amp;#34;cities&amp;#34;&amp;gt; &amp;lt;h2&amp;gt;Tokyo&amp;lt;/h2&amp;gt; &amp;lt;p&amp;gt;Tokyo is the capital of Japan, the center of the Greater Tokyo Area, and the most populous metropolitan area in the world.&amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt;  HTML布局 &amp;lt;div&amp;gt;元素常用于布局工具，因为能够轻松通过CSS对其进行定位，下面这个例子使用4个&amp;lt;div&amp;gt;元素来创建多列布局：
&amp;lt;body&amp;gt; &amp;lt;div id=&amp;#34;header&amp;#34;&amp;gt; &amp;lt;h1&amp;gt;City Gallery&amp;lt;/h1&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div id=&amp;#34;nav&amp;#34;&amp;gt; London&amp;lt;br&amp;gt; Paris&amp;lt;br&amp;gt; Tokyo&amp;lt;br&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div id=&amp;#34;section&amp;#34;&amp;gt; &amp;lt;h1&amp;gt;London&amp;lt;/h1&amp;gt; &amp;lt;p&amp;gt; London is the capital city of England. It is the most populous city in the United Kingdom, with a metropolitan area of over 13 million inhabitants. &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; Standing on the River Thames, London has been a major settlement for two millennia, its history going back to its founding by the Romans, who named it Londinium. &amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div id=&amp;#34;footer&amp;#34;&amp;gt; Copyright W3School.com.cn &amp;lt;/div&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;style&amp;gt; #header { background-color:black; color:white; text-align:center; padding:5px; } #nav { line-height:30px; background-color:#eeeeee; height:300px; width:100px; float:left; padding:5px; } #section { width:350px; float:left; padding:10px; } #footer { background-color:black; color:white; clear:both; text-align:center; padding:5px; } &amp;lt;/style&amp;gt;  HTML框架 通过使用框架，你可以在同一个浏览器窗口中显示不止一个页面。每份HTML文档称为一个框架，并且每个框架都独立于其他的框架。
使用框架的缺点——开发人员必须同时跟踪更多的HTML文档。
结构框架标签frameset定义如何将窗口分割为框架，每个frameset定义了一系列行与列。rows/columns的值规定了每行与每列占据屏幕面积。
&amp;lt;frameset cols=&amp;#34;25%,75%&amp;#34;&amp;gt; &amp;lt;frame src=&amp;#34;frame_a.htm&amp;#34;&amp;gt; &amp;lt;frame src=&amp;#34;frame_b.htm&amp;#34;&amp;gt; &amp;lt;/frameset&amp;gt; 上面的代码设置两列的框架集，第一列被设置占浏览器的25%，第二列占浏览器的75%。
假如一个框架有可见边框，用户可以拖动边框来改变它的大小。为了避免这种情况发生，可以在&amp;lt;frame&amp;gt;标签中加入：noresize=&amp;quot;noresize&amp;quot;。
不能将&amp;lt;body&amp;gt;&amp;lt;/body&amp;gt;标签与&amp;lt;frameset&amp;gt;&amp;lt;/frameset&amp;gt;标签同时使用。不过，假如你添加包含一段文本的&amp;lt;noframes&amp;gt;标签，就必须将这段文字嵌套于 &amp;lt;body&amp;gt;&amp;lt;/body&amp;gt;标签内。
 内联框架 内联框架用于在网页内显示页面，使用iframe标签，其中width和height可以设置宽度和高度，默认值是像素，也可以使用百分比来显示。
&amp;lt;body&amp;gt; &amp;lt;iframe src=&amp;#34;http://localhost:1313/post/htm-primer/&amp;#34; width=&amp;#34;600&amp;#34; height=&amp;#34;600&amp;#34;&amp;gt;&amp;lt;/iframe&amp;gt; &amp;lt;/body&amp;gt; ifame标签的frameborder属性规定是否显示 iframe周围的边框，值为0表示移除边框。
frame可用作链接的目标（target）。链接的target属性必须引用 iframe的name属性。
&amp;lt;iframe src=&amp;#34;http://localhost:1313/post/htm-primer/&amp;#34; width=&amp;#34;600&amp;#34; height=&amp;#34;600&amp;#34; frameborder=&amp;#34;0&amp;#34;&amp;gt;&amp;lt;/iframe&amp;gt; &amp;lt;br/&amp;gt; &amp;lt;iframe src=&amp;#34;http://localhost:1313/post/htm-primer/&amp;#34; name=&amp;#34;iframe_a&amp;#34;&amp;gt;&amp;lt;/iframe&amp;gt; &amp;lt;p&amp;gt;&amp;lt;a href=&amp;#34;http://www.w3school.com.cn&amp;#34; target=&amp;#34;iframe_a&amp;#34;&amp;gt;W3School.com.cn&amp;lt;/a&amp;gt;&amp;lt;/p&amp;gt;  背景颜色 &amp;lt;body&amp;gt;标签具有两个配置背景的属性，背景可以是颜色或者图片，分别是背景颜色属性bgcolor和背景图片属性background。bgcolor用于设置背景颜色；而background将背景设置为图片，其属性值为图片的URL。
&amp;lt;body bgcolor=&amp;#34;#000000&amp;#34;&amp;gt; &amp;lt;body bgcolor=&amp;#34;rgb(0,0,0)&amp;#34;&amp;gt; &amp;lt;body bgcolor=&amp;#34;black&amp;#34;&amp;gt; &amp;lt;body background=&amp;#34;clouds.gif&amp;#34;&amp;gt; &amp;lt;body background=&amp;#34;http://www.w3school.com.cn/clouds.gif&amp;#34;&amp;gt; &amp;lt;body&amp;gt;标签中的背景颜色（bgcolor）、背景（background）和文本（text）属性在最新的HTML标准（HTML4和XHTML）中已被废弃。W3C在其的推荐标准中已删除这些属性。
 HTML脚本 &amp;lt;html&amp;gt; &amp;lt;body&amp;gt; &amp;lt;script type=&amp;#34;text/javascript&amp;#34;&amp;gt; document.write(&amp;#34;&amp;lt;h1&amp;gt;Hello World!&amp;lt;/h1&amp;gt;&amp;#34;) &amp;lt;/script&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt;  HTML头部 head元素是所有头部元素的容器，head内部的元素可包含脚本，指示浏览器在何处可以找到样式表，提供元信息等。以下标签都可以加到&amp;lt;head&amp;gt;部分：
  &amp;lt;title&amp;gt;:定义浏览器工具栏中的标题。
&amp;lt;title&amp;gt;RichTextEditor&amp;lt;/title&amp;gt;   &amp;lt;base&amp;gt;: 为页面上所有的链接规定默认的地址或默认目标。
&amp;lt;head&amp;gt; &amp;lt;base href=&amp;#34;http://www.w3school.com.cn/images/&amp;#34; /&amp;gt; &amp;lt;base target=&amp;#34;_blank&amp;#34; /&amp;gt; &amp;lt;/head&amp;gt;   &amp;lt;link&amp;gt;: 定义文档与外部资源之间的关系。
&amp;lt;head&amp;gt; &amp;lt;link rel=&amp;#34;stylesheet&amp;#34; type=&amp;#34;text/css&amp;#34; href=&amp;#34;mystyle.css&amp;#34; /&amp;gt; &amp;lt;/head&amp;gt;   &amp;lt;meta&amp;gt;:定义文档的元数据信息，元数据用于规定页面的描述，关键词，修改时间等。
&amp;lt;meta charset=&amp;#34;utf-8&amp;#34;&amp;gt; &amp;lt;meta name=&amp;#34;viewport&amp;#34; content=&amp;#34;width=device-width, initial-scale=1.0,maximum-scale=1.0, user-scalable=no&amp;#34; &amp;gt; &amp;lt;meta content=&amp;#34;ie=edge&amp;#34; http-equiv=&amp;#34;X-UA-Compatible&amp;#34;&amp;gt;   &amp;lt;script&amp;gt;:用于定义客户端的脚本。
  &amp;lt;style&amp;gt;: 定义样式信息。
&amp;lt;head&amp;gt; &amp;lt;style type=&amp;#34;text/css&amp;#34;&amp;gt; body {background-color:yellow} p {color:blue} &amp;lt;/style&amp;gt; &amp;lt;/head&amp;gt;    HTML URL URL统一资源定位器，也被称为网址，其用于定位万维网上的文档（或其他数据）:
scheme://host.domain:port/path/filename  scheme: 定义因特网服务的类型，例如http,https,ftp,file等。 host: 定义域主机，http的默认主机是www。 domain: 定义因特网的域名，例如mmhui.top。 :post: 定义主机上的端口，http默认是80。 Path: 定义服务器上的路径，如果省略，则文档必须位于网站的根目录下。 filename:定义文档或者资源的名称。   URL的编码 URL只能使用ASCII字符集来通过因特网进行发送，但是URL中常常包含ASCII集合之外的字符，URL必须转换为有效的ASCII格式。
URL编码使用%其后跟随两位的十六进制的数来替代非ASCII字符。
 文档类型 HTML文档存在不同的版本，只有事先声明HTML文档的版本，浏览器才能完全正确的显示出HTML页面。!DOCTYPE可以用于声明HTML文档的版本：
html 5 文档 &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;!--html5文档--&amp;gt; html 4.1 文档 &amp;lt;!DOCTYPE HTML PUBLIC &amp;#34;-//W3C//DTD HTML 4.01 Transitional//EN&amp;#34; &amp;#34;http://www.w3.org/TR/html4/loose.dtd&amp;#34;&amp;gt; &amp;lt;!--html 4.1 文档--&amp;gt; xhtml 1.0 文档 &amp;lt;!DOCTYPE html PUBLIC &amp;#34;-//W3C//DTD XHTML 1.0 Transitional//EN&amp;#34; &amp;#34;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&amp;#34;&amp;gt; &amp;lt;!--xhtml 1.0文档--&amp;gt;  高度 function getInfo(){ let s = &amp;#34;&amp;#34;; s &#43;= &amp;#34; 网页可见区域宽：&amp;#34;&#43; document.body.clientWidth; s &#43;= &amp;#34; 网页可见区域高：&amp;#34;&#43; document.body.clientHeight; s &#43;= &amp;#34; 网页可见区域宽：&amp;#34;&#43; document.body.offsetWidth &#43; &amp;#34; (包括边线和滚动条的宽)&amp;#34;; s &#43;= &amp;#34; 网页可见区域高：&amp;#34;&#43; document.body.offsetHeight &#43; &amp;#34; (包括边线的宽)&amp;#34;; s &#43;= &amp;#34; 网页正文全文宽：&amp;#34;&#43; document.body.scrollWidth; s &#43;= &amp;#34; 网页正文全文高：&amp;#34;&#43; document.body.scrollHeight; s &#43;= &amp;#34; 网页被卷去的高(ff)：&amp;#34;&#43; document.body.scrollTop; s &#43;= &amp;#34; 网页被卷去的高(ie)：&amp;#34;&#43; document.documentElement.scrollTop; s &#43;= &amp;#34; 网页被卷去的左：&amp;#34;&#43; document.body.scrollLeft; s &#43;= &amp;#34; 网页正文部分上：&amp;#34;&#43; window.screenTop; s &#43;= &amp;#34; 网页正文部分左：&amp;#34;&#43; window.screenLeft; s &#43;= &amp;#34; 屏幕分辨率的高：&amp;#34;&#43; window.screen.height; s &#43;= &amp;#34; 屏幕分辨率的宽：&amp;#34;&#43; window.screen.width; s &#43;= &amp;#34; 屏幕可用工作区高度：&amp;#34;&#43; window.screen.availHeight; s &#43;= &amp;#34; 屏幕可用工作区宽度：&amp;#34;&#43; window.screen.availWidth; s &#43;= &amp;#34; 你的屏幕设置是 &amp;#34;&#43; window.screen.colorDepth &#43;&amp;#34; 位彩色&amp;#34;; s &#43;= &amp;#34; 你的屏幕设置 &amp;#34;&#43; window.screen.deviceXDPI &#43;&amp;#34; 像素/英寸&amp;#34;; } 去除UIWebview底部的黑线   将UIWebView的opaque设置为false。
  设置UIWebView的背景颜色以清除颜色。
   </content>
    </entry>
    
     <entry>
        <title>CSS 入门</title>
        <url>https://iihui.github.io/post/css-primer/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>CSS</tag><tag>code</tag>
        </tags>
        <content type="html"> 关注点分离和混合 关注点分离 关注点分离的意思是：各种技术只负责自己的领域，不要混合在一起，形成耦合。对于网页开发来说，主要是三种技术分离。
  HTML:负责网页的结构，称为语义层。
  CSS:负责网页的样式，称为视觉层。
  JavaScript:负责网页的逻辑和交互，称为逻辑层或者交互层。
  也就是说不要写行内样式和行内脚本，例如下面的代码就很糟糕：
&amp;lt;h1 style=&amp;#34;color:red;font-size:46px;&amp;#34; onclick=&amp;#34;alert(&amp;#39;Hi&amp;#39;)&amp;#34;&amp;gt; Hello World &amp;lt;/h1&amp;gt;  关注点混合 而React出现之后，这个原则就不适用了，因为React是组件结构，强制要求把HTML,CSS,JavaScript写在一起。
const style = { &amp;#39;color&amp;#39;: &amp;#39;red&amp;#39;, &amp;#39;fontSize&amp;#39;: &amp;#39;46px&amp;#39; }; const clickHandler = () =&amp;gt; alert(&amp;#39;hi&amp;#39;); ReactDOM.render( &amp;lt;h1 style={style} onclick={clickHandler} &amp;gt; Hello, world! &amp;lt;/h1&amp;gt; document.getElementById(&amp;#39;example&amp;#39;) ); 上面代码写在一个文件中，封装了结构、样式和逻辑，完全违背了关注点分离的原则。但是，这种方式有利于组件的隔离。每个组件包含了所有需要用到的代码，不依赖外部，组件之间没有耦合，很方便复用。所以，随着React的走红和组件模式深入人心，这种关注点混合的新写法逐渐成为主流。
CSS 实例 CSS规则是由两个主要的部分构成：选择器以及一条或者多条声明，声明总是以分号结束。
* { margin:0; padding:0; } p { font-size:2em; } .info { background:#ff0; } p.info { background:#ff0; } p.info.error { color:#900; font-weight:bold; } #info { background:#ff0; } p#info { background:#ff0; } CSS的注释是由/*开始，以*/结束，用于解释代码，并可以随意编辑它，浏览器会忽略它。
 选择器 CSS的基本选择器包括：  通用选择器，匹配任何元素。 标签选择器，匹配所有使用该标签的元素。 class选择器，匹配所有class属性中包含info的元素。 id选择器，匹配所有id属性为footer的元素。   标签选择器 标签选择器，即将HTML中的标签作为选择器：
p { &amp;lt;!--标签选择器--&amp;gt; line-height: auto; //行距自动变化 margin-top: 0px; margin-bottom: 15px; /*24*/ } html, body { &amp;lt;!--标签选择器--&amp;gt; padding: 0; margin: 0; font-family: Arial, Helvetica, sans-serif; }  id选择器 id选择器可以为标有特定的id的HTML元素指定特定的样式。HTML元素以id属性来设置id选择器，CSS中id选择器以#来定义：
#separatorDiv { -webkit-user-select: none; padding-left: 10px; padding-right: 10px; } #content { outline: 0px solid transparent; } 需要特别注意的是ID属性不要以数字开头，否则ID在火狐浏览器中不起作用。
 class选择器 class选择器用于描述一组元素的样式，class选择器有别于id选择器，class可以在多个元素中使用。class选择器在HTML中以class属性表示, 在 CSS中，类选择器以一个点.号显示。在下例中，所有拥有center类的HTML元素均为居中:
.center {text-align:center;} 同样地，类名的第一个不能使用数字，否则无法在火狐浏览器中起作用。
参考资料
 innerHeight 和outerHeight 通过window.innerHeight和window.outerHeight可以得到整个窗口的高度，其中：
  innerHeight 是DOM视口的大小，包括滚动条。
  couterHeight 是整个浏览器窗口的大小，包括窗口标题，工具栏和状态栏等。
  在不支持window.innerHeight的浏览器中，可以读取documentElement和body的高度，它们的大小和window.innerHeight类似，但有区别。
document.documentElement.clientHeight document.body.clientHeight 其中documentElement是文档根元素——&amp;lt;html&amp;gt;标签，而body就是&amp;lt;body&amp;gt;标签。因此为了解决兼容性问题，常常使用如下代码：
var height = window.innerHeight || document.documentElement.clientHeight|| document.body.clientHeight; 实际上后面两种方式获取的高度和window.innerHeight是不一样的，这3个属性的值逐渐变小，具体来说:
  window.innerHeight包括整个DOM：内容，边框以及滚动条高度。
  documentElement.clientHeight不包括整个文档滚动条高度，但包括&amp;lt;html&amp;gt;元素的边框高度。
  body.clientHeight不包括整个文档的滚动条高度，也不包括&amp;lt;html&amp;gt;元素的边框高度，也不包括&amp;lt;body&amp;gt;的边框和滚动条高度。
   滚动高度 使用JS控制页面滚动时（如回到顶部），需要知道页面当前滚动到了哪里，以及将要滚动到哪里。这涉及到4个DOM属性，所有的DOM元素都有以下4个属性。
  clientHeight 内部可视区域的高度。
  offsetHeight 整个可视区域的高度，包括border和scrollbar在内。
  scrollHeight 元素内部的高度，包括溢出的部分。
  scrollTop 元素内容向上滚动了多少像素，如果没有滚动则返回0。
   参考资料
</content>
    </entry>
    
     <entry>
        <title>XCode快捷键</title>
        <url>https://iihui.github.io/post/xcode-quick/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html"> MAC键盘图标  ⌘——Command () ⌃ ——Control ⌥——Option (alt) ⇧——Shift ⇪——Caps Lock   快捷键  Command&#43;R 运行 Command&#43;B 编译 Command&#43;. 停止 Command &#43; Shift &#43; K 清除工程 Command &#43; K 清除控制台信息 Command &#43; N 新建文件 Command &#43; Shift &#43; N 创建新工程   导航栏  Command&#43;0~9 工程导航  Command &#43; 0 快速打开实用面板 Command &#43; 1 查看工程文件 Command &#43; 2 版本控制导航 Command &#43; 3 符号导航(类) Command &#43; 4 警告和错误导航 Command &#43; 5 测试导航 Command &#43; 6 调试导航 Command &#43; 7 断点导航 Command &#43; 9 报告导航   Command &#43; Option &#43; 0 打开右侧导航栏 Command &#43; Option &#43; T 打开工具栏 Command &#43; Shift &#43; Y 打开底部导航栏 Command &#43; Z 撤销 Command &#43; Shift &#43; Z 反撤销   查找与跳转  Command &#43; F 在当前文档中查找 Command &#43; Shift &#43; G 搜索上一处 Command &#43; G 搜索下一处 Command &#43; L 跳转到特定行 Command &#43; Shift &#43; O（字母） 快速查找打开类 Command &#43; Shift &#43; J 快速定位到当前类在项目中的位置 Command &#43; Shift &#43; 0(数字zero)查看帮助文档 Command &#43; Control&#43;↑/Command&#43;Control&#43;↓ 类文件和实现文件之间跳转 Command&#43;Control&#43;←/Command&#43;Control&#43;→ 回到上一个/下一个打开的页面 Command&#43;Option&#43;←/Command&#43;Option&#43;→ 收放方法体，即将方法体收起或者展开 Control &#43; 6 在当前类查找变量和方法 「键入方法或者变量名&#43;Enter跳转」   光标操作  Control &#43; F 向右一个字符 Control &#43; B 向左一个字符 Control &#43; P 向上一行 Control &#43; N 向下一行 Control &#43; A 跳到行首 Control &#43; E 跳到行尾 Control &#43; T 调换光标两边的字符 Control &#43; D 删除光标右侧的单个字符 Control &#43; K 删除本行剩余的字符   整体位移  Command &#43; [ 选中的代码整体左移 Command &#43; ] 选中的代码整体右移 Command &#43; Option &#43; [ 选中的代码整体上移 Command &#43; Option &#43; ] 选中的代码整体下移   补充   Command &#43; Option &#43; 点击桌面上空白的区域:把除Finder窗口以外的所有窗口隐藏起来，直接显示桌面。分别点击Dock栏上各个相关应用程序图标就可以解除窗口的隐藏状态了。
  Command &#43; Option &#43; H: 把所有已打开的程序窗口（不包括当前正在运行的应用程序窗口）最小化到Dock栏上。注意不是关闭哦，是最小化。如果需要把程序窗口恢复到屏幕上，直接点击相应的应用程序图标就可以了。
  参考资料 参考资料 参考资料
 </content>
    </entry>
    
     <entry>
        <title>OC 入门</title>
        <url>https://iihui.github.io/post/oc-tour/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>OC</tag><tag>iOS</tag>
        </tags>
        <content type="html">  Objective-C简称OC， 是C语言的严格超集——任何C语言程序不经过修改都可以直接通过OC的编译器，在OC中使用C语言代码也是完全合法的。OC被描述为覆盖在C语言上的一层，因为OC的原意就是在C语言的主体上加入面向对象的特性。
 文件扩展名    文件扩展名 类型和作用     .h 头文件，包含类，类型，函数和常数声明   .m 源代码文件，典型的源代码文件扩展名，可以包含OC和C代码   .mm 源代码文件，带这种扩展名的源代码文件，除了可以包含OC和C代码以外，还可以包含C&#43;&#43;代码    源代码中需要包含头文件的时候，可以使用标准的#include编译选项，也可以使用#import选项，但是OC中使用#import可以确保相同的文件只包含一次，因此一般使用#import来引入头文件。
 语法 Objective-C最大的特色使用Smalltalk的消息传递模型。在OC中与其说是对象调用方法，不如说向对象传递消息更为精确。调用方法 在OC中，调用方法视为向对象发送消息，所有方法(类方法和实例方法)都被视为对消息的回应。
所有消息的处理直到运行时（runtime）才会动态决定，并交由类自行决定如何处理收到的消息。也就是说，一个类不保证一定会回应收到的消息，如果类收到了一个无法处理的消息，程序只会抛出异常，不会出错或崩溃。
在OC中发送消息的语法为：
[obj method: argument]; //C&#43;&#43;对应的是obj.method(argument); 一个例子:
[car fly] 上面的例子典型的C&#43;&#43;意义解读是:调用car类的fly方法。若car类里头没有定义fly方法，那编译肯定不会通过。但是OC里，应当解读为:发送一个fly的消息给car对象，fly是消息，而car是消息的接收者。car收到消息后会决定如何回应这个消息，若car类别内定义有fly方法就运行方法内之代码，若car内不存在fly方法，则程序依旧可以通过编译，运行期则抛出异常。
因此OC天生具备鸭子类型的动态类型绑定能力，运行期间才处理消息，允许发送未知消息给对象，可以发送消息给整个对象集合而不需要检查每个对象的类型，也具备消息转发机制。同时空对象nil接受消息后默认不做任何回应，所以发送消息给nil也不用担心崩溃。
 字符串 作为C语言的超集，OC支持C语言字符串方面的约定：单个字符被单引号包括，字符串被双引号包括。但是，大多数OC通常不使用C语言风格的字符串，大多数框架把字符串传递给NSString对象NSString类提供了字符串的类包装，包含了所有你期望的优点——包括对保存任意长度字符串的内建内存管理机制，支持Unicode，printf风格的格式化工具等。
因为这种字符串使用的非常频繁，OC提供了一个助记符可以方便地从常量值创建NSString对象，即在普通的双引号字符串前放置一个@符号:
NSString* myString = @&amp;#34;My String\n&amp;#34;; NSString* anotherString = [NSString stringWithFormat:@&amp;#34;%d %s&amp;#34;, 1, @&amp;#34;String&amp;#34;]; // 从一个C语言字符串创建Objective-C字符串 NSString* fromCString = [NSString stringWithCString:&amp;#34;A C string&amp;#34; encoding:NSASCIIStringEncoding];  类 OC类的说明包含两个部分：定义(interface)和实现(implementation)。类定义包含了类声明、实例变量的定义以及相关的方法（包括类方法和实例方法）；实现则包含了类方法的实际代码。
类的声明总是以@interface编译选项开始，由@end编译选项结束。类名之后的（用冒号分隔）是父类的名字。类的变量声明在被大括号包含的代码块中。变量块后是类声明的方法的列表，每个变量和方法声明都以分号结尾。
 Interface 定义部分，以关键字@interface作为开始，@end作为结束，其中定义的实例变量的默认权限是protected：
@interface MyObject : NSObject { int memberVar1; // 实例变量，在定义部分声明的实例变量的默认访问权限是protected  id memberVar2; //id 类型表示任意类型 } &#43;(return_type) class_method; // 类方法  -(return_type) instance_method1; // 实例方法 -(return_type) instance_method2: (int) p1; -(return_type) instance_method3: (int) p1 andPar: (int) p2; @end 方法前面的&#43;或者-号代表函数的类型：加号&#43;代表类方法（class method），不需要实例就可以调用，与C&#43;&#43;的静态函数（static member function）相似；减号-表示一般的实例方法（instance method）。下面是与OC对应的C&#43;&#43;的声明：
class MyObject : public NSObject { protected: int memberVar1; // 实体变量  void * memberVar2; public: static return_type class_method(); // 类方法  return_type instance_method1(); // 实例方法  return_type instance_method2( int p1 ); return_type instance_method3( int p1, int p2 ); } OC定义一个新方法时，名称内的冒号代表传递参数：
- (void) setColorToRed: (float)red Green: (float)green Blue:(float)blue; /* 声明方法*/ [myColor setColorToRed: 1.0 Green: 0.8 Blue: 0.2]; /* 调用方法*/ 上面这个方法的签名是setColorToRed:Green:Blue。每个冒号后面都带着一个float类别的参数，分别代表红绿蓝三色。
 Implementation 实现块包含了公开的方法的实现，以及定义私有变量以及方法，以关键字@implementation作为区块的开始，@end结尾。
@implementation MyObject { int memberVar3; //私有实例变量 } &#43;(return_type) class_method { .... //方法的实现部分 } -(return_type) instance_method1 { .... } -(return_type) instance_method2: (int) p1 { .... } -(return_type) instance_method3: (int) p1 andPar: (int) p2 { .... } @end   不只Interface区域可定义实体变量，Implementation区块也可以定义实体变量。
  两者的差别在于访问权限的不同，Interface区块内的实体变量默认权限为protected。而在implementation区域定义的实体变量则默认为private，故在Implementation区块定义私有成员更匹配面向对象之封装原则，因为类的私有信息就不需暴露在公开interface(.h文件)中。
   创建对象 OC创建对象需通过alloc以及init两个消息,alloc的作用是分配内存，init是初始化对象。init与alloc都是定义在NSObject里的方法，父对象收到这两个信息并做出正确回应后，新对象才创建完毕。
MyObject * my = [[MyObject alloc] init]; 在OC 2.0里，若创建对象不需要参数，则可以直接使用new
MyObject * my = [MyObject new];  方法 在OC中类可以声明两种类型的方法：实例方法和类方法。实例方法在类的一个具体实例的范围内执行，即要调用实例方法前，需要首先创建类的实例，而类方法不需要创建一个实例。
方法声明包括方法类型标识符，返回值类型，一个或多个方法标识关键字，参数类型和名信息，下图展示 insertObject:atIndex: 实例方法的声明。
  声明由一个减号-开始，这表明这是一个实例方法。方法实际的名字(insertObject:atIndex:)是所有方法标识关键的级联，包含了冒号。
  冒号表明了参数的出现，如果方法没有参数，你可以省略第一个(也是唯一的)方法标识关键字后面的冒号。
  当需要调用一个方法时，即传递消息给对应的对象，这里的消息是指方法标识符以及传递给方法的参数信息。
  发送给对象的所有消息都会动态分发，这样有利于实现OC的多态行为。
  如果子类定义了和父类具有相同标识符的方法，那么子类首先收到消息，然后选择把收到的消息转发（也可以不转发）给他的父类。
  消息被中括号包括。中括号里，接收消息的对象在左边，消息（包括消息需要的任何参数）在右边。例如，给myArray变量传递消息insertObject:atIndex:消息，需要使用如下的语法：
[myArray insertObject:anObj atIndex:0]; 为了避免过多地声明本地变量保存临时结果，OC允许使用嵌套消息，每个嵌套消息的返回值可以作为其他消息的参数。例如，有另外一个对象叫做myAppObject有方法可以访问数组对象，以及插入一个对象到一个数组，就可以将前面的例子写成如下的形式：
[[myAppObject getArray] insertObject:[myAppObject getObjectToInsert] atIndex:0]; 消息也可以传递给类本身，当给类发消息的时候，指定的方法必须为类方法。类方法的典型用途是用做创建新类实例的工厂方法，或者是访问类相关的共享信息的途径。
NSMutableArray* myArray = nil; // nil 基本上等同于 NULL  // 创建一个新的数组，并把它赋值给 myArray 变量 myArray = [NSMutableArray arrayWithCapacity:0]; 上面是一个类方法作为一个工厂方法来使用。arrayWithCapacity是NSMutableArray类的类方法，为类的新实例分配内容并初始化，然后返回。
 属性 属性使用一个等式来表示：@property = 成员变量 &#43; getter &#43; setter，即一个属性包含了一个成员变量以及该成员变量的getter和setter方法：
@property = 成员变量 &#43; getter &#43; setter 为什么OC要添加属性，这就要从成员变量说起。成员变量的写法，一般如下：
@interface Person :NSObject { int _age; //定义成员变量，_下划线开始是苹果的编程规范 } @end 成员变量具有如下的特点：
  只能通过对象来访问
  成员变量离不开类，离开了类就不是成员变量
  成员变量不能在定义的时候同时进行初始化
  成员变量存储在当前对象对应的堆空间中，不会自动释放，只能手动释放
  成员变量前加_是苹果的编程规范
  在OC中.访问符是为getter和setter服务的，而在OC中成员变量默认是没有getter和setter方法，因此在类外无法直接访问。如果需要访问就要自定义的getter和setter方法，然后通过自定义的getter和setter方法来访问成员变量。
因此，苹果为了大众方便，在iOS 5以后使用了属性@property。定义属性时会自动将getter和setter方法实现了，你无须再手动去实现getter和setter方法。当然了，如果你需要在getter和setter方法中想要做点事情，直接重写就好。
顺带地，@property还会生成一个成员变量，变量名就是_属性名。当然这个名字你也可以修改，是在.m文件中的implements中去定义：
@synthesize name = myName; 参考文献 参考文献
属性提供了一些关键字用以控制setter和getter的实现细节, 这些关键字我们称为属性的属性(attribute)，总共有三类:
 读写性readonly,readwrite。其中readonly表示只能读取, 不能写入（系统默认是可读写的）  @property (readonly)NSString *name; 表示只能读取 @property (readwrite)NSString *name；表示可以读写  原子性控制atomic，nonatomic。其中atomic表示属性对应的setter和getter方法在多线程访问下绝对安全。而nonatomic表示不做线程安全处理，只是普通的setter和getter方法。使用atomic, 需要不断地对setter和getter加锁解锁以保证线程安全, 会很占用系统资源, 降低系统性能。  @property(readwrite,nonatomic)NSString *name;表示name 可读写, 无原子性   语义设置assign, retain, copy,strong,weak。这5个属性决定了setter方法中是如何赋值的。
 其中assign实现setter和getter是直接赋值，计数器不会加一，简单的赋值方法，默认赋值方式，适合基本数据类型。相当于说两个对象指向同个内存区，一个地方的变了，其他的也跟着改变。  @property(nonatomic, assign) NSInteger age; -(void)setName:(NSInteger )age { _age = age; } -(NSInteger )age { return _age; }   strong : 表示强引用关系，即拥有对象的所有权。
  weak : 表示弱引用，不拥有对象的所有权，当目标对象被销毁之后，属性值会被自动设为nil;
  ​copy(拷贝)：把原来的对象拷贝过来，计数器会加一，比如原来对象的地址为0x01 ,拷贝过来的对象的地址为0x02。用于希望保持一份传入值的拷贝，而不是值自身的情况，即把原来的对象完整的赋值到另外一地方，重新加载一内存区，一个地方变了不影响另一个地方的对象。是内容拷贝。
  ​retain(保留)：这种方式传递的是指针，原有的对象和被赋值的对象的地址是一样的。释放旧的对象,将旧对象的值赋予输入对象,再提高输入对象的索引计数为1。是指针拷贝。
     设计模式 设计模式的两个目标
 可复用性：得到较高的生产效率。 可扩展性：当用户的需求发生变化时，做很少的变化就能够满足用户的需求。  单例模式 单例设计模式：自始至终一个类只有一个对象实例。Cocoa中主要的单例类有：
 UIApplication NSNotificationCenter NSUserDefaults NSFileManager NSBundle  OC中单例模式： //singleton.h @interface Singleton:NSObject &#43; (Singleton *) sharedManager @property (nonatomic,strong) NSString * singletonData; @end //singleton.m @implemention Singleton @synthesize singletonData = _singletonData; static Singleton * sharedManager = nil &#43; (Singleton *) sharedManager{ static dispatch_once_t once; dispatch_once(&amp;amp;once,^{ sharedManager = [[self alloc] init]; }); return sharedManager; } 单例设计模式使用场景：
 在整个过程中只需要一个实例保存状态。 无状态对象(只有方法，没有属性）  单例模式时，访问对象时，修改状态的时候要十分小心（它就像一个全局变量）。
UIApplication  sharedApplication方法：它是创建和获得UIApplication实例的实例方法。 openURL:方法：该方法可以打开一些内置的iOS应用，其中包括打开浏览器、打开Google地图、拨打电话、发送短信和发送Email等。  [[UIApplication sharedApplication] openURL: [NSURL URLWithString:@&amp;#34;http://www.baidu.com&amp;#34;]];  委托模式 委托：某个对象指定另一个对象处理某些特定任务（某些方法的实现）的设计模式。例如当没空的时候委托别人帮忙买火车票，乘车人、乘车日期以及出发地和目的地就是协议「规定」（协议通俗的说就是某种规定，如果能执行这种规定就说遵守了某个协议）。
在上面的类图中带空心三角形的实线表示继承；带空心三角形的虚线表示实现接口；带箭头的实线表示单向关联（has）。上面的意思是通用类有一个叫做“委托协议”的成员，它被赋值为（绑定到）为一个委托对象实例，而委托对象实现了委托协议中的相关方法。然后通过这个委托对象实例来做相应的动作（完成委托的事情）。
  委托需要做的工作有： 1.1 定义协议与协议中的方法 1.2 声明委托变量 1.3 设置代理（委托变量绑定到哪个对象实例） 1.4 通过委托变量调用委托方法
  代理需要做的工作有: 2.1 遵循协议（在类的定义时声明遵循相应的协议） 2.2 实现委托方法（实现协议中的方法）
  场景 场景：Boss准备举行一场party，准备邀请Atany来参加party，但是Boss没空写email给Atany，于是他委托Henry与Mary来做这件事情。
在YGViewController.h（根控制器，程序第一个界面，类似于Boss）中首先定义协议，接着声明委托变量（Boss并没有实现inviteToMyParty这个方法，他没有自己去邀请）：
#import &amp;lt;UIKit/UIKit.h&amp;gt;@protocol InviteDelegate -(void)inviteToMyParty:(NSString *)personName;//1.1定义协议与方法 @end @interface YGViewController : UIViewController @property (assign,nonatomic) id&amp;lt;InviteDelegate&amp;gt; delegate;//1.2声明委托变量 - (IBAction)ClickByMary:(id)sender;//委托给Mary - (IBAction)ClickByHenry:(id)sender;//委托给Henry @end 然后再设置代理，最后通过委托变量调用委托方法：
- (IBAction)ClickByMary:(id)sender { Mary *mary = [[Mary alloc]init]; self.delegate = mary;//1.3设置代理  [self.delegate inviteToMyParty:@&amp;#34;atany&amp;#34;];//1.4通过委托变量调用委托方法 } - (IBAction)ClickByHenry:(id)sender { Henry *henry = [[Henry alloc]init]; self.delegate = henry;//1.3设置代理  [self.delegate inviteToMyParty:@&amp;#34;atany&amp;#34;];//1.4通过委托变量调用委托方法 } BOSS可以选择不同的代理（Henry与Mary）来做这件事情（inviteToMyParty），而自己却不用做。以Henry为例，首先遵循协议，然后实现协议中的委托方法：
#import &amp;lt;UIKit/UIKit.h&amp;gt;#import &amp;#34;YGViewController.h&amp;#34; @interface Henry : UIViewController &amp;lt;InviteDelegate&amp;gt;//2.1遵循协议 @end -(void)inviteToMyParty:(NSString *)personName{ NSString *hello = [NSString stringWithFormat:@&amp;#34;Hello,%@&amp;#34;,personName]; NSString *str = [NSString stringWithFormat:@&amp;#34;Hey Boy,this is Henry,Come to our party Please!!&amp;#34;]; UIAlertView *alert = [[UIAlertView alloc]initWithTitle:hello message:str delegate:self cancelButtonTitle:@&amp;#34;OK&amp;#34; otherButtonTitles:nil]; [alert show]; }  观察者设计模式 观察模式的定义
有很多观察者正在观察对象的变化，当对象发生时会通知所有的观察者
KVO是观察对象属性的变化 通知机制观察的是对象的变化
NSNotification 可以通过object（NSObject） 和 userInfo（NSDictionary） 来回传数据
投送通知：postNotification
KVO要搞清楚谁是观察者，谁是被观察者
模态视图：关闭不能通过故事板，只能通过代码实现
runtime  runtime是一套存C语言的API，OC代码最终都会被编译器转为运行时代码，通过消息机制决定函数的调用方式。
 消息机制的基本原理 在OC语言中，对象方法调用都是类似[receiver selector]的形式，其本质：让对象在运行时发送消息的过程。
方法调用[receiver selector]分为两个过程：
  编译阶段。[receiver selector]方法被编译器转化，分为两种情况
 不带参数的方法被编译为objc_msgSend(receiver,selector) 带参数的方法被编译为objc_msgSend(receiver,selector,org1,org2,...)    运行阶段：消息接收者receiver寻找对应的selector，也分为两种情况
 接收者能找到对应的selector，直接执行receiver对象的selector方法 接收者找不到对应的selector，消息被转发或者临时向接收者添加这个selector对应的实现内容，否则崩溃。    总而言之，OC调用方法[receiver selector]，编译阶段确定了要向那个接收者发送message消息，但是接收者如何响应决定于运行时的判断。
</content>
    </entry>
    
     <entry>
        <title>swift中的方法</title>
        <url>https://iihui.github.io/post/swift-method/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html">  在Swift中方法是关联了特定类型的函数。类，结构体，枚举类型都能定义实例方法，方法封装了给定类型特定的任务和功能。
 实例方法 实例方法是属于特定实例（类实例、结构体实例或者枚举实例）的函数。实例方法只能在类型的具体实例里被调用，不能独立于实例而被调用，也就是说不能直接使用类名直接调用。
class Counter { var count = 0 func increment() { count &#43;= 1 } func increment(by amount: Int) { count &#43;= amount } func reset() { count = 0 } }  异变方法 在Swift中结构体和枚举是值类型。默认情况下，值类型属性不能被自身的实例方法修改。如果需要改变结构体或者枚举类型的属性，应该将实例方法进行异变。即在实例方法的func关键字前添加mutating关键字：
struct Point { var x = 0.0, y = 0.0 mutating func moveBy(x deltaX: Double, y deltaY: Double) { x &#43;= deltaX y &#43;= deltaY } } 但是，不能在常量结构体类型里调用异变方法，因为常量代表自身属性不能被改变，即使这些属性是变量属性：
let fixedPoint = Point(x: 3.0, y: 3.0) fixedPoint.moveBy(x: 2.0, y: 3.0) //编译器会报错，因为常量结构体里的数据不能被修改，而moveBy声明是异变的，所以矛盾，编译器会报错。  self属性 每一个类的实例都隐含一个叫做self的属性，它完全和实例本身相等，可以使用self来调用实例的方法或者使用实例的属性。
struct Point { var x = 0.0, y = 0.0 func isToTheRightOf(x: Double) -&amp;gt; Bool { return self.x &amp;gt; x //形参的优先级别高于实例属性 } } 枚举的异变方法可以设置隐含的self属性为相同枚举里的不同成员。也就是在枚举类型中其异变的方法中，self也是可以变换的：
enum TriStateSwitch { case off, low, high mutating func next() { switch self { case .off: self = .low case .low: self = .high case .high: self = .off } } } 类型方法 类型方法是用来定义类型本身调用的方法，通过在func关键字前加static来实现。类还可以用关键字class来允许子类重写父类的方法实现。
在类方法中，隐含的self指向的是类本身而不是类的实例。同样在类型方法中，有self访问的属性与同名的形参相比，优先级低一些：
struct Point{ static var x = 12 static func test(x:Int)-&amp;gt;Bool{ return self.x &amp;gt; x } }  </content>
    </entry>
    
     <entry>
        <title>JavaScript 数据类型</title>
        <url>https://iihui.github.io/post/js-data-struct/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>JS</tag>
        </tags>
        <content type="html"> JavaScript不需要进行类型声明，因此它是一种弱类型的语言，这意味着可以在任何阶段改变变量的数据类型。
字符串 字符串是由零个或者多个字符组成，必须包含在引号中，单引号和双引号都可以。
 数值 如果想给一个变量赋一个数值，不必限定它必须是一个整数。JavaScript允许使用带小数点的数值，并且允许任意位的小数。
 数组 字符串、数值、布尔值都被称为标量（如果某个变量称为标量，那么在任何时候它就只能有一个值）。
数组的声明 var beatles = Array(4) //声明长度 var beatles = Array() var beatles = Array(&amp;#34;John&amp;#34;,&amp;#34;Paul&amp;#34;,&amp;#34;George&amp;#34;,&amp;#34;Ringo&amp;#34;} var bratles = [&amp;#34;John&amp;#34;,&amp;#34;Paul&amp;#34;,&amp;#34;George&amp;#34;,&amp;#34;Ringo&amp;#34;] var lennon = [&amp;#34;john&amp;#34;,1992,false] //数组中声明不同类型的元素 填充数组 var lennon = Array() lennon[&amp;#34;name&amp;#34;] = &amp;#34;john&amp;#34; lennon[&amp;#34;year&amp;#34;] = 1940 lennon[&amp;#34;living&amp;#34;] = false  对象 与数组相似，对象也是使用一个名字来表示一组值，对象的每个值都是对象的一个属性。
var lennon = Object() lennon.name = &amp;#34;john&amp;#34; lennon.year = 1980 lennon.living = false var lennon = {name:&amp;#34;john&amp;#34;,year:1940,living:false} //更简洁的声明方式  运算符 相等操作符==并不是表示严格意义的相等。例如下面的代码中==操作符认为空字符和false的值是相等的，因此返回真。
var a = false var b = &amp;#34;&amp;#34; if ( a == b){ alert(&amp;#34;a 等于 b“) } 如果要进行严格意义的相等判断，则需要使用===，这个全等操作符，不仅比较值而且比较类型。同理，要比较严格不等也要使用！==。
</content>
    </entry>
    
     <entry>
        <title>泼辣修图中的人像工具</title>
        <url>https://iihui.github.io/post/pixel-portrait/</url>
        <categories>
          <category>后期</category>
        </categories>
        <tags>
          <tag>后期</tag><tag>泼辣</tag>
        </tags>
        <content type="html">  在泼辣修图中有22个强大且易用的人像调整工具，涵盖了面部结构、五官大小、肤色亮度等等的调整。当图片中出现一张脸时，泼辣修图会智能的识别脸部并区分其五官，选中相应的区域然后调整对应的参数即可。
 自动调整 点击自动增强，程序可以自动优化五官、结构和肤色，使得照片呈现更好的状态。
 皮肤控制 皮肤控制选项包括平滑，光泽，阴影，高光，色相，跑和度，下面一一说明：
皮肤平滑：提高数值可以实现磨皮效果，让皮肤更加光滑细腻，降低数值可以增加皮肤质感。
皮肤光泽：提高数值可以为面部补光，让面部看起来更加白皙明亮，降低数值可以降低面部的亮度。
皮肤阴影：控制面部较暗区域的亮度，一般而言我们需要降低皮肤阴影的数值，提高皮肤高光的数值，让面部的立体感更加强烈。皮肤高光：控制面部较亮区域的亮度，一般而言我们需要降低皮肤阴影的数值，提高皮肤高光的数值，让面部的立体感更加强烈。
皮肤色相：改变皮肤的色彩，例如让皮肤由偏红色转变为偏黄色.
皮肤饱和度：控制面部皮肤的色彩鲜艳程度，如果我们感觉面部过于泛红时可以降低该选项；如果感觉面部皮肤没有气色时，可以提高该选项。
 面部控制 面部控制选项包括面部宽度，下巴宽度，前额宽度。其中面部宽度用于调整面部的宽度，下巴高度用于控制下巴的高度，前额宽度用于控制额头的高低：
 眼睛控制 眼睛控制包括眼睛大小、亮度、对比度以及清晰度：
 鼻子调整 鼻子控制包括：鼻子宽度和鼻子长度：
 嘴巴调整 嘴巴控制包括微笑、嘴高度、嘴宽度、亮度以及饱和度：
 牙齿控制 牙齿控制包括牙美白和牙亮度：
 参考资料
</content>
    </entry>
    
     <entry>
        <title>泼辣修图后期术语3</title>
        <url>https://iihui.github.io/post/pixel-term3/</url>
        <categories>
          <category>后期</category>
        </categories>
        <tags>
          <tag>后期</tag>
        </tags>
        <content type="html"> 质感 质感：质感是指物体的材质与质量所带给人的感觉。在泼辣修图中，质感选项下的调整包括清晰度、锐化、降噪色彩、降噪明度。
清晰度 清晰度用来调整画面的清晰程度。提高清晰度数值可以让画面更加清晰，可以用来修复轻微失焦的画面。降低清晰度数值可以画面更加模糊，有时候可以用它来模拟动漫效果、水彩效果等。
 锐化 锐化是补偿图像的轮廓，增强图像的边缘及灰度跳变的部分，使图像变得清晰。它的效果相较于清晰度更加细腻。
 降噪色彩 噪点分为两种：色彩噪点与明度噪点。所谓色彩噪点，就是带有颜色的画面噪点；所谓明度噪点，就是不带有色彩的画面噪点。
下面的左图，可以明显的观察到颜色噪点的存在（为了方便观察，此处的锐化值提高到了&#43;50）。当对中间这张图应用了色彩降噪之后，画面留下的就是明度噪点，可以看到，明度噪点就是类似黑白颗粒一样的存在。最右边这张图是同时使用色彩降噪和明度降噪之后的效果，可以看到画面相较于原图更加纯净。
 去雾 去雾是指消除画面中的雾霾或为画面添加雾霾。提高去雾值，让画面更加通透自然；降低去雾值，为画面加入雾气。
 曲线 曲线分为白色曲线、红色曲线、绿色曲线、蓝色曲线，白色曲线又称为RGB曲线，红色曲线、绿色曲线、蓝色曲线又统称为通道曲线。
曲线的初始形态是一条45度的直线，当调整这条直线的形态时就可以达到调整画面的目的。利用白色曲线可以调整画面的曝光，利用红色曲线、绿色曲线、蓝色曲线可以调整画面的色彩。
 白色曲线 </content>
    </entry>
    
     <entry>
        <title>泼辣修图后期术语2</title>
        <url>https://iihui.github.io/post/pixel-term2/</url>
        <categories>
          <category>后期</category>
        </categories>
        <tags>
          <tag>后期</tag><tag>泼辣</tag>
        </tags>
        <content type="html"> 曝光 曝光：用于调整画面的明亮程度。提高曝光值会让画面变得更加明亮，整体显得干净而又轻盈；降低曝光值会让画面变得更加昏暗，整体显得沉重而又严肃。
 高光、白色色阶、黑色色阶、阴影 可以按照曝光去划分照片的区域，例如把照片划分为最亮的区域、较亮的区域、较暗的区域和最暗的区域，这样我们就可以实现对照片的精细调整。
在泼辣修图中，这4个区域，按照如下关系进行对应：①高光——最亮的区域；②白色色阶——较亮的区域；③黑色色阶——较暗的区域；④阴影——最暗的区域。
高光对应的是画面中最亮的部分，例如天空。降低高光值，可以降低天空的亮度，让天空的细节得到更好的呈现。
白色色阶对应的是画面中比较亮的部分，它的影响范围一般比高光更大。这两个参数调整并不会对画面中较暗的区域，如下图所示调整高光和白色色阶并不会影响阴影和黑色色阶部分：  阴影对应最暗的区域；黑色色阶对应的是画面中比较暗的部分，它影响的范围一般比阴影更大。阴影和黑色色阶两个参数调整并不会对画面中较亮的区域。  色温 当黑体发射的光的颜色与某个光源所发射的光的颜色相同时，这个黑体加热的温度称之为该光源的颜色温度，简称色温。简而言之色温就是指光线的颜色，不同的光源具有不同的色温。
当色温越高的时候，光源发出的颜色就越偏冷，大致是经历一个红——橙红——黄——黄白——白——蓝白的渐变过程。 一天中的色温也是在不停发生变化的，例如日出之前的色温是蓝色，日出之后的色温是橙色，中午的色温是白色，而晚上的色温是黄色等等，引起太阳光颜色变化的原因主要是因为大气层的反射作用，而并不是因为太阳的温度发生了大幅度的改变。
为画面加入黄色可以提高色温值；或画面加入蓝色可以降低色温值。  白平衡 白平衡是指将白色还原为白色的过程。如果我们身处一个黄色光源的环境之中，那么环境中的白色会被渲染成黄色。由于人眼具有智能色偏修正的功能，即使进入这样一个环境，过不了多久我们就能适应这个环境的光源色彩，因此有可能感觉不到白色发生了异常。但是，相机没有智能色偏修正，因此需要借助白平衡的能力来实现纠正色偏的效果。
可以通过为相机设置一个机内色温值来实现白平衡的效果，当机内色温值与外界一致时，相机就能正确的表现白色。例如现在外界色温是4000K，我们将机内色温也设置为4000K时，白色就能被相机还原为白色。
如果相机内设置的色温大于环境中的色温时，相机就会认为外界色温是偏蓝色的，因此需要增加黄色来中和蓝色，以实现还原白色的效果。
如果相机内设置的色温小于环境中的色温时，相机就会认为外界色温是偏黄色的，因此需要增加蓝色来中和黄色，以实现还原白色的效果。
 使用色温值来调节白平衡 不同的色温能够给人不同的心理感受。例如暖色能够给人一种温暖、温馨、和谐的感觉；冷色则能够给人一种平静、阴凉、寒冷的感觉；中性色则能给人一种安宁、舒适、稳定的感觉。
在后期创作的时候，就要学会使用不同的色温去辅助我们表达不同的感情效果。可以利用色温工具实现画面的白平衡，从而得到一个更加中性的色彩取向。
  当画面偏蓝的时候，可以提高色温值，为画面加入暖色（黄色），从而实现白平衡的效果。   当画面偏黄的时候，我们可以降低色温值，为画面加入冷色（蓝色），从而实现白平衡的效果。    色调 色调：为画面加入洋红色（品红色）可以提高色调值；为画面加入绿色可以降低色调值。也就是说，当降低色调工具的值时，可以为画面加入绿色，当我们提高色调工具的值时，可以为画面加入洋红色。 如果画面偏洋红色，就可以降低色调为画面加入绿色，从而削弱洋红色，以呈现出更加中性的色调：  色温和色调工具通常结合起来帮助我们调整画面的白平衡以及渲染画面的色彩。例如这一张照片：
为了降低画面的色温值，为画面加入蓝色；提高色调值，为画面加入洋红色：  色调分离 利用色调分离工具可以为画面的阴影或高光加入指定的色彩。当为高光加入某种色彩时，它主要会影响画面中亮度较高的区域；当我们为阴影加入某种色彩时，它主要会影响画面中亮度较低的区域。
可以看到，当为高光加入黄色的时候，天空（比较亮的区域）受到了较为明显的影响，但是地面（比较暗的区域）受到的影响则不大；
于此同时，当为阴影加入蓝色的时候，地面（比较暗的区域）受到的影响比较明显，但是天空（比较亮的区域）受到的影响则不大。
 暗角 是指因为镜头存在光学缺陷等原因导致相机进光不均匀，因此出现照片四周亮度较低的现象。
当为画面增添暗角时，可以让画面的视觉焦点更加集中；在后期中，我们不仅仅会为照片添加暗角，有时候也会为照片添加亮角，即照片四周亮度高于中间，这可以营造一种明亮、纯洁的画面氛围。在泼辣修图中，质感选项下的调整包括暗角程度、暗角羽化、暗角高光、暗角大小、暗角圆度。
 暗角程度 用于控制暗角的浓烈程度。数值为正值时，为画面加入白色边角；数值为负值时，为画面加入黑色边角；绝对值越大，效果越强烈。  暗角羽化 暗角羽化用于控制暗角的羽化程度（柔和程度），数值越大边缘越柔和。
 暗角高光 暗角高光：数值越大，画面中的高光部分受到暗角影响的程度就越小（营造不规则的暗角风格）。
 暗角大小 暗角大小：控制暗角的影响范围，数值越小不受暗角影响的区域就越小（当然受影响的区域就越大）。
 暗角圆度 暗角圆度：控制暗角的圆形程度。数值越大暗角越呈现出圆形，数值越小暗角越呈现出方形。
 </content>
    </entry>
    
     <entry>
        <title>泼辣修图后期术语1</title>
        <url>https://iihui.github.io/post/pixel-term1/</url>
        <categories>
          <category>后期</category>
        </categories>
        <tags>
          <tag>后期</tag><tag>泼辣</tag>
        </tags>
        <content type="html"> 对比度 维基百科对比度的解释为：画面黑与白的比值，即从黑到白的渐变层次。比值越大，从黑到白的渐变层次越多，从而色彩表现越丰富。对比度对于视觉的影响非常关键，一般说来对比度越大，图像越清晰越醒目，色彩也越鲜明亮丽；对比度小，则让整个画面灰蒙蒙的。
提高对比度可以让画面更加通透，但是会损失一些细节；降低对比度会让画面获得相对更加丰富的细节，但是会让画面灰蒙蒙的。
 饱和度 饱和度是指色彩的纯度，一种颜色的饱和度越高，它就越鲜艳；反之，一种颜色的饱和度越低，它就越接近于灰色。
一张照片的饱和度越高，越能引起人的注意，但是过高的饱和度有时候会让人产生反感的情绪：
一张照片的饱和度越低，画面就越平和，就越能给人安静、舒适的视觉感受，但是过低的饱和度有时候会让画面产生不通透感。
提高饱和度的数值时，画面会变得更加鲜艳，但是如果数值提高得过高，有时候会让画面出现色彩溢出等不正常现象。
降低饱和度的数值时，画面会变得更加偏灰，如果将数值降至最低，画面会变成黑白照片。
 自然饱和度 自然饱和度工具相当于智能饱和度工具，它可以控制画面的饱和度程度，不会让画面过于饱和。
相比于饱和度，自然饱和度会保护饱和度高的地方，比如说提升自然饱和度的时候，本来高饱和的区域提升幅度较弱，本来低饱和的区域提升幅度较强，而饱和度则是同等幅度提升所有颜色的饱和度。
因此，在进行后期的调整的时候，特别是调整风光类照片的时候，可以更多的采用自然饱和度工具去调整画面的色彩，这样不容易出现过度饱和的问题。
 增强画面表现力 有时候感觉画面有些沉闷，这时可以尝试提高画面的饱和度，让画面的色彩更加鲜艳，从而让画面拥有更强的色彩表现力。
 削弱色彩攻击性 画面饱和度过高会让色彩的攻击性增强，但是过高的饱和度容易让画面对人产生过度的刺激，有时候过高的饱和度还会让画面显得沉重，或者画面显得比较脏。这时就可以通过降低画面的饱和度削弱色彩的攻击性。
 变黑白照片 将画面的饱和度降到最低时，画面就可以变成黑白照片，如下图所示：
 调整局部色彩 可以利用HSL、笔刷等工具分别调整不同颜色或不同区域的饱和度，让画面形成高饱和和低饱和并存的局部色彩效果，更好的凸显画面主体、增强画面的视觉表现力。
利用HSL调整青色的饱和度，将其值调到-100可以得到下图：
 色相 色相（Hue）是指色彩的相貌名称，例如红色、橙色、紫色等。它是颜色的首要特征，是区别各种不同色彩最准确的标准。除了黑白灰以外的其他颜色都有色相属性。
当使用HSL工具去调整色相时，可以将一种颜色转变为另一种颜色。例如选中蓝色，调整蓝色的色相时：
画面中的树叶和向日葵并没有受到影响，这是因为树叶和向日葵的颜色并不是蓝色，因此我们在调整蓝色色相的时候，其他颜色并不会受到影响。
 明度 即是指一种颜色的明亮程度，明度越高，颜色越明亮（白一点），明度越小，颜色越深沉（暗一点）。同一种颜色有明暗之分，例如浅蓝色和深蓝色，不同颜色之间也有明暗之分，例如黄色的明度就相对比较高，紫色的明度就相对比较低。
可以看到在HSL工具中，当调整蓝色明度的时候，画面中蓝色（天空）发生了变化，其颜色更加明亮或深沉。但是画面中的绿色（树叶）、黄色（向日葵）则不受影响。
 亮度 亮度用于调整画面的灰色，相较于“曝光”，它的调整范围主要集中于中间调，可以用于修复画面的细节。提高亮度的效果近似于提高曝光&#43;降低对比度；降低亮度的效果近似于降低曝光&#43;提高对比度。
HSL HSL工具可以帮助我们来调整一种颜色的色相、饱和度、明度。例如当选中蓝色，然后调整蓝色的色相。可以看到，天空的颜色发生了改变，左边、中间和右边的天空颜色都明显不同，这是因为我们改变了蓝色的色相，而天空是蓝色的，所以受到了影响。
画面中的树叶和向日葵并没有受到影响，这是因为树叶和向日葵的颜色并不是蓝色，因此我们在调整蓝色色相的时候，其他颜色并不会受到影响。
 同理，选中蓝色，然后调整蓝色的饱和度。提高饱和度之后，天空的色彩变得更加鲜艳了；降低饱和度之后，天空的色彩更加偏向于灰色了：
与此同时，画面中的树叶和向日葵并没有受到影响，因为我们调整的是蓝色的饱和度，但是树叶和向日葵的颜色并不是蓝色，所以说饱和度并不会随之改变。
 利用HSL分区调整 分区调整，就是指把照片按照一定的标准划分为不同的区域，然后对这些区域分别调整。而HSL工具就可以把画面按照色彩进行划分，然后针对不同的色彩进行调整。在HSL工具里面，可以选择洋红色、紫色、蓝色、青色、红色、橙色、黄色、绿色这8种颜色进行分别调整。
 提高饱和度让天空更鲜艳 在调整天空颜色时，一般选择蓝色和青色，这是最为常见的天空颜色。在下图中，如果选择红色，然后调整红色的饱和度，天空将不会受到影响；而当选中蓝色，然后提高蓝色的饱和度时，则可以看到天空的颜色明显变得更加鲜艳了。
 利用明度调整天空的亮度 例如选中蓝色，当降低蓝色的明度时，可以看到第二张照片相对于第一张照片天空的亮度降低了；当提高蓝色的明度时，可以看到第三张照片中的天空变得更加明亮了。
因此，可以利用较高明度的天空去表达一种轻盈、通透的场景氛围，可以利用较低明度的天空去表达一种深沉、压抑的场景氛围。
 利用色相渲染天空色彩 不同色相对于人的心理存在不同的影响，我们可以利用色相的这一特性去渲染天空的色彩，使画面呈现出不同的场景氛围。
例如选中蓝色，然后提高蓝色的色相值，这时候天空一般会呈现出紫色，画面会给人一种晚霞的场景感；当降低蓝色的色相值，这时候天空一般会呈现出青色，能够给人一种微妙的离奇感，因为它不同于我们常见的天空色彩。
 利用HSL调整草地/树木 在下图中，草地显得有些枯黄，如果想要将它们变成蓝天绿草的效果，该如何处理呢？ 画面中的这些草地是黄色的，因此可以选中黄色，然后调整黄色的色相，使草地的颜色由黄色转换为绿色：
提高黄色的色相，使其有黄色转换为绿色，然后提高黄色的饱和度，使草地的颜色更加鲜艳，然后降低黄色的明度，使草地的颜色更加深沉。
 经过这样的调整之后，可以发现画面中还存在一些枯草，这些枯草对应的色彩是橙色，因此可以选中橙色，然后调整橙色的色相，将橙色转换为绿色：
提高橙色的色相，使画面中草地的颜色由橙色转变为绿色；然后提高橙色的饱和度，使得草地的颜色更加鲜艳；然后降低橙色的明度，让草地存在高明度与低明度的对比，从而让画面更加富有层次感。
 然后可以调整一下画面的天空，利用前面学习的调整天空的方法，这张照片中天空的色彩更加倾向于青色，因此我们选中青色，然后调整青色：
提高青色的饱和度，使得天空的颜色更加鲜艳，我们降低青色的明度，使得天空的亮度变低，从而呈现出更加丰富的细节。
 经过这样几步简单的调整，这张照片就呈现出蓝天绿草的景观了。利用HSL工具调整草地/树木的时候，我们的思维过程是这样的：
  确定最终色
  选择目标色
  色彩输出
  使用HSL工具之前，首先要思考的是我们最终想要呈现的效果是怎样的。例如，在上图中，我们最终想要的效果是让天空更蓝、草地变绿，这就是需要的最终色。
 例如看到下面这张枫叶时，可能想到调整画面中的黄色和橙色，因为这两个颜色比较接近，其他颜色都离画面中枫叶的颜色太远了。 但是当调整黄色的时候，发现画面基本上没有变化时，就可以确定调整橙色了。按下图右侧的数值，依次调整色相，饱和度，明度:  </content>
    </entry>
    
     <entry>
        <title>使用pixelmator pro修改证件照背景颜色</title>
        <url>https://iihui.github.io/post/pixel-background/</url>
        <categories>
          <category>后期</category>
        </categories>
        <tags>
          <tag>后期</tag><tag>mator</tag>
        </tags>
        <content type="html">  现有一张白底的证件照需要修改为蓝底的。使用pixelmator pro这款软件，自己摸索出了2种方法来实现这个需求。
 第一种方法 第一种方法的思路，首先将头像抠出来，然后新建一个同样大小的文件，再将抠出来图层粘贴到新建的图层，最后改变背景的颜色。可归纳为抠图$\to$新建$\to$换背景。
抠头像 首先使用pixelmator pro将原照片打开，然后使用快速选择中的快速选区，如下图所示：
然后移动圆圈，左键点击选中那只兔子,如下图所示黄色部分：
最后释放鼠标左键，表示选中对应区域，如下图虚线所示
 新建文件 选中兔子之后，将按住command&#43;c复制，然后新建一个新的文件，如下图所示，其中红色框中表示可以调整大小：
然后将之前抠出来的那只兔子，粘贴到新的文件中，就形成了如下所示的两个图层：
 填充背景颜色 然后选中上图的白色背景图层，在右边的工具栏中选中样式，如下图所示：
然后选择填充，填充的时候选择颜色，不要选渐变。然后选择喜欢的颜色，至此就完成了背景的更改：
 第二种方法 第二种方法的思路是先选中背景颜色的区域，然后对这个区域用另外一种颜色进行填充。可归纳为选择$\to$替换。
按颜色选择背景 首先在右侧的工具栏中选择快速选择，然后选择选择颜色，如下所示：
然后选择背景颜色区域对应的颜色，如下图虚线所示：
 填充背景颜色 选择好颜色区域之后，然后在右侧的工具栏中选择颜色填充，如下图所示：
然后选择相应的颜色在我们选定的区域内进行填充，如下图所示，但是在填充的时候要选择平滑边缘，至此背景色就已经改好了。
 </content>
    </entry>
    
     <entry>
        <title>Go 实现各种内排序算法</title>
        <url>https://iihui.github.io/post/go-sort/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>Go</tag>
        </tags>
        <content type="html"> 内排序是指在排序过程中，数据都能够放在内存中处理，排序时不涉及数据的内、外交换。
插入类排序 直接插入排序 func InsertSort(data []int) { var i, j, cur int length := len(data) //获得切片对应数组的长度  for i = 1; i &amp;lt; length; i&#43;&#43; { cur = data[i] for j = i - 1; j &amp;gt;= 0; j-- { if data[j] &amp;gt; cur { data[j&#43;1] = data[j] } else { break } } data[j&#43;1] = cur } }  二分直接插入排序 func BinInsertSort(data []int) { var cur, start, mid, end int length := len(data) for i := 1; i &amp;lt; length; i&#43;&#43; { cur = data[i] start = 0 end = i - 1 for start &amp;lt;= end { mid = start &#43; (end-start)/2 if data[mid] == cur { end = mid break } else if data[mid] &amp;gt; cur { end = mid - 1 } else { start = mid &#43; 1 } } for j := i - 1; j &amp;gt;= end&#43;1; j-- { data[j&#43;1] = data[j] } data[end&#43;1] = cur } }  shell排序 func shellCore(data [] int, step int) { var i, j, cur int length := len(data) for i = step; i &amp;lt; length; i&#43;&#43; { cur = data[i] for j = i - step; j &amp;gt;= 0; j -= step { if data[j] &amp;gt; cur { data[j&#43;step] = data[j] } else { break } } data[j&#43;step] = cur } } func ShellSort(data [] int) { step := len(data) / 2 for step &amp;gt; 0 { shellCore(data, step) step /= 2 } }  交换类排序 冒泡排序 func BubbleSortBig(data []int) { //大数沉底 	length := len(data) for i := 1; i &amp;lt; length; i&#43;&#43; { flag := false //标志本趟是否有交换 	for j := 0; j &amp;lt; length-i; j&#43;&#43; { if data[j] &amp;gt; data[j&#43;1] { data[j], data[j&#43;1] = data[j&#43;1], data[j] //并行赋值 	flag = true } } if !flag { break } } } func BubbleSortSmall(data [] int) { //小数上浮 	length := len(data) for i := 1; i &amp;lt; length; i&#43;&#43; { flag := false for j := length - 1; j &amp;gt;= i; j-- { if data[j] &amp;lt; data[j-1] { data[j], data[j-1] = data[j-1], data[j] //并行赋值 	flag = true } } if !flag { break } } }  快速排序 func partition(data [] int, start int, end int) int { small := start - 1 index := rand.Intn(end-start) &#43; start //找到随机的基准 	data[index], data[end] = data[end], data[index] //并行赋值  for i := start; i &amp;lt; end; i&#43;&#43; { if data[i] &amp;lt; data[end] { small&#43;&#43; if small &amp;lt; i { data[small], data[i] = data[i], data[small] //并行赋值 	} } } small&#43;&#43; data[small], data[end] = data[end], data[small] //并行赋值 	return small } func QuickSort(data []int, start int, end int) { if start &amp;lt; end { pivot := partition(data, start, end) if pivot &amp;gt; start { QuickSort(data, start, pivot-1) } if end &amp;gt; pivot { QuickSort(data, pivot&#43;1, end) } } }  选择类排序 简单选择排序 func SelectSort(data []int) { length := len(data) for i := 0; i &amp;lt; length-1; i&#43;&#43; { index := i for j := i &#43; 1; j &amp;lt; length; j&#43;&#43; { if data[j] &amp;lt; data[index] { index = j } } if index != i { data[i], data[index] = data[index], data[i] } } }  堆排序 func adjustHeap(data []int, start int, end int) { for parent, child := start, 2*start&#43;1; child &amp;lt;= end; child = 2*parent &#43; 1 { if child &amp;lt; end &amp;amp;&amp;amp; data[child] &amp;lt; data[child&#43;1] { //注意控制条件 	child&#43;&#43; } if data[parent] &amp;lt; data[child] { data[parent], data[child] = data[child], data[parent] parent = child } else { break } } } func HeapSort(data []int) { length := len(data) for i := (length - 2) / 2; i &amp;gt;= 0; i-- { adjustHeap(data, i, length-1) } for i := length - 1; i &amp;gt; 0; i-- { data[i], data[0] = data[0], data[i] adjustHeap(data, 0, i-1) } }  归并排序 func mergeCore(data, assist []int, start, end int) { if start == end { assist[start] = data[start] return } mid := start &#43; (end-start)/2 mergeCore(data, assist, start, mid) mergeCore(data, assist, mid&#43;1, end) i, j, k := start, mid&#43;1, start for i &amp;lt;= mid &amp;amp;&amp;amp; j &amp;lt;= end { if data[i] &amp;lt; data[j] { assist[k] = data[i] k&#43;&#43; i&#43;&#43; } else { assist[k] = data[j] k&#43;&#43; //Go中后置&#43;&#43;不能作为表达式，只能是语句 	j&#43;&#43; } } for i &amp;lt;= mid { assist[k] = data[i] k&#43;&#43; //Go中后置&#43;&#43;不能作为表达式，只能是语句 	i&#43;&#43; } for j &amp;lt;= end { assist[k] = data[j] k&#43;&#43; //Go中后置&#43;&#43;不能作为表达式，只能是语句 	j&#43;&#43; } for i := start; i &amp;lt;= end; i&#43;&#43; { data[i] = assist[i] } } func MergeSort(data [] int) { assist := make([]int, len(data)) //需要重新生成一个切片 	mergeCore(data, assist, 0, len(data)-1) }  计数排序 func CountSort(data []int, radix int) { length := len(data) count := make([]int, radix) assist := make([]int, length) for i := 0; i &amp;lt; length; i&#43;&#43; { count[data[i]]&#43;&#43; } for i := 1; i &amp;lt; radix; i&#43;&#43; { count[i] &#43;= count[i-1] } for i := length - 1; i &amp;gt;= 0; i-- { count[data[i]]-- //下标是从0开始的，因此先减1 	assist[count[data[i]]] = data[i] } for i := 0; i &amp;lt; length; i&#43;&#43; { data[i] = assist[i] } }  基数排序 func findMax(data []int) int { length, max := len(data), data[0] for i := 1; i &amp;lt; length; i&#43;&#43; { if data[i] &amp;gt; max { max = data[i] } } return max } func BucketSort(data []int, radix, exp int) { length, count, assist := len(data), make([]int, radix), make([]int, len(data)) for i := 0; i &amp;lt; length; i&#43;&#43; { count[(data[i]/exp)%radix]&#43;&#43; } for i := 1; i &amp;lt; radix; i&#43;&#43; { count[i] &#43;= count[i-1] } for i := length - 1; i &amp;gt;= 0; i-- { count[(data[i]/exp)%radix]-- assist[count[(data[i]/exp)%radix]] = data[i] } for i := 0; i &amp;lt; length; i&#43;&#43; { data[i] = assist[i] } } func RadixSort(data []int, radix int) { max := findMax(data) for exp := 1; exp &amp;lt;= max; exp *= radix { BucketSort(data, radix, exp) } }  </content>
    </entry>
    
     <entry>
        <title>VirtualBox 虚拟机扩容</title>
        <url>https://iihui.github.io/post/tool-vb-resize/</url>
        <categories>
          <category>QA</category>
        </categories>
        <tags>
          <tag>QA</tag>
        </tags>
        <content type="html"> 今天在使用VirtualBox安装win10虚拟机的时候，开始创建的虚拟磁盘空间有点小，安装了许多软件之后磁盘不够用了，需要进行扩容，接下来分三步来解决该问题。
加入到环境变量 首先将VirtualBox的安装目录添加到环境变量path中。首先将右键任务栏上的Windows图标：
 命令行下扩容 首先关闭虚拟机，然后以管理员身份打开命令行，输入VBoxManage list hdds查看已经安装的虚拟机的情况,找到对应的虚拟机的UUID：
然后以VBoxmanage modifyhd UUID --resize 重置后大小(以MB为单位)，其中--resize后面是重新分配空间的大小，单位为MB，上图是将24GB的空间重置为30GB
 扩展C盘 在虚拟机中首先打开磁盘管理，可以看到多了2GB的未分配空间，然后鼠标右键C盘，选择扩展卷： 然后点击下一步，设置将要扩展到C盘的容量： 最后可以看到C盘的容量如预期的那样变大了： 需要注意的是未分配的空间需要在C盘的紧邻的右侧才能按照如上所述的方式直接进行扩展。
 </content>
    </entry>
    
     <entry>
        <title>R 绘图中使用中文</title>
        <url>https://iihui.github.io/post/r-chinese/</url>
        <categories>
          <category>绘图</category>
        </categories>
        <tags>
          <tag>R</tag>
        </tags>
        <content type="html"> 默认情况下R中绘图不支持中文
绘制图2-1 首先，绘制图2-1(a),代码如下：
fiber.absorp=read.csv(&amp;#39;~/downloads/data/paper/absorp.csv&amp;#39;,sep=&amp;#39;,&amp;#39;,header = T) absorp.wool=spline(fiber.absorp$RH,fiber.absorp$wool,n=1000) absorp.PP=spline(fiber.absorp$RH,fiber.absorp$PP,n=1000) absorp.cotton=spline(fiber.absorp$RH,fiber.absorp$cotton,n=1000) plot(absorp.wool,col=&amp;#34;DarkTurquoise&amp;#34;,xlab=&amp;#34;Relative Humidity(%)&amp;#34;,ylab=&amp;#34;hygroscopicity(%)&amp;#34;,main=&amp;#34;Hygrosopic isotherms of various fibers&amp;#34;,type=&amp;#39;l&amp;#39;,lwd=2) lines(absorp.PP,type=&amp;#39;l&amp;#39;,lwd=2,col=&amp;#34;DeepPink&amp;#34;) lines(absorp.cotton,col=&amp;#34;RosyBrown&amp;#34;,type=&amp;#34;l&amp;#34;,lwd=2) text.legend=c(&amp;#34;wool&amp;#34;,&amp;#34;cotton&amp;#34;,&amp;#34;PP&amp;#34;) legend(&amp;#34;topleft&amp;#34;,legend=text.legend,col=c(&amp;#34;Darkturquoise&amp;#34;,&amp;#34;RosyBrown&amp;#34;,&amp;#34;DeepPink&amp;#34;),text.col=c(&amp;#34;Darkturquoise&amp;#34;,&amp;#34;RosyBrown&amp;#34;,&amp;#34;DeepPink&amp;#34;),lty=c(1,1,1)) RH,PP,cotton,wool 0,0,0,0 20,0.8,2.5,7.5 40,0.9,4.9,12.3 60,0.92,7.1,14.6 80,0.96,9.2,16.8 100,1.02,12.8,27.2  然后，绘制图2-1(b),代码如下：
fiber.temp=read.csv(&amp;#39;~/downloads/data/paper/temp.csv&amp;#39;,sep=&amp;#39;,&amp;#39;,header = T) temp.wool=spline(fiber.temp$time,fiber.temp$wool,n=1000) temp.PP=spline(fiber.temp$time,fiber.temp$PP,n=1000) temp.cotton=spline(fiber.temp$time,fiber.temp$cotton,n=1000) plot(temp.wool,col=&amp;#34;DarkTurquoise&amp;#34;,xlab=&amp;#34;Time(min)&amp;#34;,ylab=&amp;#34;Temperature(deg)&amp;#34;,main=&amp;#34;Temperature of various fibers&amp;#34;,type=&amp;#39;l&amp;#39;,lwd=2) lines(temp.PP,type=&amp;#39;l&amp;#39;,lwd=2,col=&amp;#34;DeepPink&amp;#34;) lines(temp.cotton,type=&amp;#39;l&amp;#39;,lwd=2,col=&amp;#34;RosyBrown&amp;#34;) text.legend=c(&amp;#34;wool&amp;#34;,&amp;#34;cotton&amp;#34;,&amp;#34;PP&amp;#34;) legend(&amp;#34;topright&amp;#34;,legend=text.legend,col=c(&amp;#34;Darkturquoise&amp;#34;,&amp;#34;RosyBrown&amp;#34;,&amp;#34;DeepPink&amp;#34;),text.col=c(&amp;#34;Darkturquoise&amp;#34;,&amp;#34;RosyBrown&amp;#34;,&amp;#34;DeepPink&amp;#34;),lty=c(1,1,1)) time,PP,cotton,wool 0,20.0,20.0,20.0 1,20.2,27.0,28.2 2,20.14,26.55,27.87 3,20.12,26.1,27.54 4,20.1,25.65,27.21 5,20.1,25.2,26.76 6,20.1,24.75,26.43 7,20.1,24.3,26.1 8,20.1,23.85,25.77 9,20.1,23.4,25.44 10,20.1,23,25.2 20,20.1,21.6,23.8 30,20.1,21.4,22.9 40,20.1,21.2,22.2 50,20.1,21.1,21.7 60,20.1,21.0,21.5 70,20.1,20.9,21.4 80,20.1,20.86,21.3 90,20.1,20.82,21.2  绘制图3-1 代码如下：
library(ggplot2) map.temp=read.csv(&amp;#34;~/downloads/screen/data/tmp-last.csv&amp;#34;) ggplot(map.temp,aes(x=reorder(part,-temp),y=temp,fill=temp-30.8))&#43;geom_bar(stat=&amp;#34;identity&amp;#34;,width=0.6)&#43;theme(axis.text.x = element_text(angle=90,colour = &amp;#34;black&amp;#34;,vjust = 1.0,hjust=0.6,size=11),axis.text.y=element_text(size=12))&#43;coord_cartesian(ylim=c(31,35))&#43;xlab(&amp;#34;Parts&amp;#34;)&#43;ylab(&amp;#34;Temperature(deg)&amp;#34;)&#43;scale_fill_gradient2(low=&amp;#39;#00BFFF&amp;#39;,high=&amp;#39;#00BF00&amp;#39;) part,temp,sweat Head,34.6,3.1 Upper back,34.16,2.91 Under arm,34.06,1.94 Chest,33.92,1.8 Abdomen,33.75,1.68 Lower back,33.21,3.02 Back thigh,33.19,1.31 Hand,33.10,1.61 Front High,32.8,1.62 Upper arm,32.68,1.79 Fossa,32.52,2.18 Forearm,32.2,1.41 Back calf,31.8,1.43 Front calf,31.78,1.56 Foot,30.9,1.74  绘制图3-2 代码如下：
library(ggplot2) map.temp=read.csv(&amp;#34;~/downloads/screen/data/tmp-last.csv&amp;#34;) ggplot(map.temp,aes(x=reorder(part,-sweat),y=sweat,fill=sweat))&#43;geom_bar(stat=&amp;#34;identity&amp;#34;,width=0.6)&#43;theme(axis.text.x = element_text(angle=90,colour = &amp;#34;black&amp;#34;,vjust = 1.0,hjust=0.6,size=11),axis.text.y=element_text(size=12))&#43;coord_cartesian(ylim=c(0.5,3.5))&#43;xlab(&amp;#34;Parts&amp;#34;)&#43;ylab(&amp;#34;Sweat evaporation(%)&amp;#34;)&#43;scale_fill_gradient2(low=&amp;#39;#649500&amp;#39;,high=&amp;#39;#6495ED&amp;#39;) part,temp,sweat Head,34.6,3.1 Upper back,34.16,2.91 Under arm,34.06,1.94 Chest,33.92,1.8 Abdomen,33.75,1.68 Lower back,33.21,3.02 Back thigh,33.19,1.31 Hand,33.10,1.61 Front High,32.8,1.62 Upper arm,32.68,1.79 Fossa,32.52,2.18 Forearm,32.2,1.41 Back calf,31.8,1.43 Front calf,31.78,1.56 Foot,30.9,1.74  绘制图4-5 首先，绘制图4-5(a),代码如下：
ex.skin=read.csv(&amp;#39;~/downloads/data/4-1-3.csv&amp;#39;,sep=&amp;#39;,&amp;#39;,header = T) ex.ex=spline(ex.skin$time,ex.skin$ex,n=1000) ex.pre=spline(ex.skin$time,ex.skin$pre,n=1000) ex.com=spline(ex.skin$time,ex.skin$tw,n=1000) plot(ex.com,col=&amp;#34;DarkTurquoise&amp;#34;,xlab=&amp;#34;Time(min)&amp;#34;,ylab=&amp;#34;Temperature(deg)&amp;#34;,type=&amp;#39;l&amp;#39;,lwd=2,xlim=c(0,20),ylim = c(33,37)) lines(ex.pre,col=&amp;#34;DeepPink&amp;#34;,type=&amp;#34;l&amp;#34;,lwd=2) lines(ex.ex,col=&amp;#34;RosyBrown&amp;#34;,type=&amp;#34;l&amp;#34;,lwd=2) text.legend=c(&amp;#34;25-node-model&amp;#34;,&amp;#34;Multi-element model&amp;#34;,&amp;#34;Experimental&amp;#34;) legend(&amp;#34;topleft&amp;#34;,legend=text.legend,col=c(&amp;#34;Darkturquoise&amp;#34;,&amp;#34;DeepPink&amp;#34;,&amp;#34;RosyBrown&amp;#34;),text.col =c(&amp;#34;Darkturquoise&amp;#34;,&amp;#34;DeepPink&amp;#34;,&amp;#34;RosyBrown&amp;#34;),lty=c(1,1,1),cex=0.8) arrows(ex.skin$time, ex.skin$ex-0.010*ex.skin$ex, ex.skin$time, ex.skin$ex&#43;0.016*ex.skin$ex, length=0.05, angle=90, code=3) //绘制误差线 time,ex,pre,tw 0,33.00,33.00,33.00 2,33.20,33.50,33.72 4,33.80,34.10,34.28 6,34.24,34.50,34.79 8,34.67,34.83,34.86 10,34.86,35.20,35.12 12,35.02,35.40,35.67 14,35.24,35.60,35.92 16,35.43,35.80,36.02 18,35.74,35.90,36.10 20,35.82,35.92,36.16  然后，绘制图4-5(b),代码如下：
ex4.5b=read.csv(&amp;#39;~/downloads/data/4-2-1.csv&amp;#39;,sep=&amp;#39;,&amp;#39;,header = T) //4-2-1  pre=spline(ex4.5b$time,ex4.5b$pre,n=2000) tw=spline(ex4.5b$time,ex4.5b$tw,n=2000) ex=spline(ex4.5b$time,ex4.5b$ex,n=2000) plot(tw,col=&amp;#34;DarkTurquoise&amp;#34;,xlab=&amp;#34;time(min)&amp;#34;,ylab=&amp;#34;Temperature(deg)&amp;#34;,type=&amp;#39;l&amp;#39;,lwd=2,ylim = c(30,37)) lines(pre,type=&amp;#39;l&amp;#39;,lwd=2,col=&amp;#34;DeepPink&amp;#34;) lines(ex,col=&amp;#34;RosyBrown&amp;#34;,type=&amp;#34;l&amp;#34;,lwd=2) arrows(ex4.5b$time, ex4.5b$ex-0.007*ex4.5b$ex,ex4.5b$time, ex4.5b$ex&#43;0.011*ex4.5b$ex, length=0.05, angle=90, code=3) legend(&amp;#34;bottomright&amp;#34;,legend=text.legend,col=c(&amp;#34;Darkturquoise&amp;#34;,&amp;#34;DeepPink&amp;#34;,&amp;#34;RosyBrown&amp;#34;),text.col=c(&amp;#34;Darkturquoise&amp;#34;,&amp;#34;DeepPink&amp;#34;,&amp;#34;RosyBrown&amp;#34;),lty=c(1,1,1)) //绘制右下角的提示  time,ex,pre,tw 0,30.00,29.92,29.92 2,35.60,35.65,35.82 4,36.42,36.35,36.62 6,36.54,36.58,36.79 8,36.42,36.54,36.80 10,36.36,36.54,36.72 12,36.20,36.48,36.70 14,36.18,36.40,36.62 16,36.12,36.32,36.58 18,36.06,36.20,36.48 20,36.02,36.11,36.42  绘制图4-6 首先，绘制图4-6(a),代码如下：
chest.tem=read.csv(&amp;#39;~/downloads/data/4-6-1-1.csv&amp;#39;,sep=&amp;#39;,&amp;#39;,header = T) //4-6-1-1  chest.cloA=spline(chest.tem$time,chest.tem$cloA,n=2000) chest.cloB=spline(chest.tem$time,chest.tem$cloB,n=2000) chest.cloC=spline(chest.tem$time,chest.tem$cloC,n=2000) plot(chest.cloA,col=&amp;#34;DarkTurquoise&amp;#34;,xlab=&amp;#34;Time(min)&amp;#34;,ylab=&amp;#34;Temperature(deg)&amp;#34;,type=&amp;#39;l&amp;#39;,lwd=2,xlim=c(0,90),ylim = c(29,35)) lines(chest.cloB,col=&amp;#34;RosyBrown&amp;#34;,type=&amp;#34;l&amp;#34;,lwd=2) text.legend=c(&amp;#34;Experimental&amp;#34;,&amp;#34;Predictions&amp;#34;) legend(&amp;#34;topright&amp;#34;,legend=text.legend,col=c(&amp;#34;Darkturquoise&amp;#34;,&amp;#34;RosyBrown&amp;#34;),text.col =c(&amp;#34;Darkturquoise&amp;#34;,&amp;#34;RosyBrown&amp;#34;),lty=c(1,1,1),cex=1.0) arrows(chest.tem$time, chest.tem$cloA-0.010*chest.tem$cloA,chest.tem$time, chest.tem$cloA&#43;0.010*chest.tem$cloA, length=0.05, angle=90, code=3) //添加误差线  time,cloA,cloB,cloC 0,33.40,33.40,33.40 5,33.70,33.58,33.50 10,34.05,33.90,33.78 15,34.15,34.10,33.92 20,34.30,34.20,34.00 25,34.38,34.27,34.05 30,34.46,34.38,34.20 35,33.78,33.68,33.68 40,33.06,33.12,33.00 45,31.72,31.80,31.60 50,31.04,31.10,31.40 55,32.30,32.02,31.70 60,31.60,31.20,31.30 65,31.40,31.02,31.31 70,31.36,31.00,31.15 75,31.00,30.90,30.95 80,30.95,30.92,30.92 85,30.20,30.10,30.50 90,30.20,30.10,30.80  然后，绘制图4-6(b),代码如下：
chest.tem=read.csv(&amp;#39;~/downloads/data/4-6-1-2.csv&amp;#39;,sep=&amp;#39;,&amp;#39;,header = T) //4-6-1-2  chest.cloA=spline(chest.tem$time,chest.tem$cloA,n=2000) chest.cloB=spline(chest.tem$time,chest.tem$cloB,n=2000) plot(chest.cloA,col=&amp;#34;DarkTurquoise&amp;#34;,xlab=&amp;#34;Time(min)&amp;#34;,ylab=&amp;#34;Temperature(deg)&amp;#34;,type=&amp;#39;l&amp;#39;,lwd=2,xlim=c(0,90),ylim = c(29,35)) lines(chest.cloB,col=&amp;#34;RosyBrown&amp;#34;,type=&amp;#34;l&amp;#34;,lwd=2) text.legend=c(&amp;#34;Experimental&amp;#34;,&amp;#34;Predictions&amp;#34;) legend(&amp;#34;topright&amp;#34;,legend=text.legend,col=c(&amp;#34;Darkturquoise&amp;#34;,&amp;#34;RosyBrown&amp;#34;),text.col =c(&amp;#34;Darkturquoise&amp;#34;,&amp;#34;RosyBrown&amp;#34;),lty=c(1,1,1),cex=1.0) arrows(chest.tem$time, chest.tem$cloA-0.008*chest.tem$cloA,chest.tem$time, chest.tem$cloA&#43;0.011*chest.tem$cloA, length=0.05, angle=90, code=3) //绘制误差线 time,cloA,cloB 0,33.40,33.40 5,33.50,33.42 10,33.78,33.63 15,33.92,33.76 20,34.00,33.82 25,34.05,34.10 30,34.20,34.12 35,33.68,33.57 40,33.00,33.23 45,31.60,31.46 50,31.40,31.32 55,31.70,31.50 60,31.30,31.29 65,31.31,31.27 70,31.15,31.06 75,30.95,30.82 80,30.92,30.62 85,30.50,30.38 90,30.80,30.46  绘制图4-7 首先，绘制图4-7a，代码如下：
chest.hr=read.csv(&amp;#39;~/downloads/data/4-6-2-1.csv&amp;#39;,sep=&amp;#39;,&amp;#39;,header = T) //4-6-2-1  chest.cloA=spline(chest.hr$time,chest.hr$cloA,n=2000) chest.cloB=spline(chest.hr$time,chest.hr$cloB,n=2000) plot(chest.cloA,col=&amp;#34;DarkTurquoise&amp;#34;,xlab=&amp;#34;Time(min)&amp;#34;,ylab=&amp;#34;Relative humidity(%)&amp;#34;,type=&amp;#39;l&amp;#39;,lwd=2,xlim=c(0,90),ylim = c(30,120)) //30-120  lines(chest.cloB,col=&amp;#34;RosyBrown&amp;#34;,type=&amp;#34;l&amp;#34;,lwd=2) text.legend=c(&amp;#34;Experimental&amp;#34;,&amp;#34;Predictions&amp;#34;) legend(&amp;#34;topleft&amp;#34;,legend=text.legend,col=c(&amp;#34;Darkturquoise&amp;#34;,&amp;#34;RosyBrown&amp;#34;),text.col =c(&amp;#34;Darkturquoise&amp;#34;,&amp;#34;RosyBrown&amp;#34;),lty=c(1,1,1),cex=1.0) arrows(chest.hr$time, chest.hr$cloA-0.05*chest.hr$cloA,chest.hr$time, chest.hr$cloA&#43;0.05*chest.hr$cloA, length=0.05, angle=90, code=3) //绘制误差线  time,cloA,cloB,cloC,CloD 0,47,47,47,47 5,48,47.5,47.8,47.8 10,46,48,49,49 15,47,47.4,48.2,48.2 20,45.8,48,48.0,48.0 25,48.6,51,51.6,51.6 30,47.2,48.6,50.8,50.8 35,48,47,50,50 40,54,55,55.8,55.8 45,70,76,78,78 50,80,86,90,90 55,87,90,92,92 60,91,96,97,97 65,92,93,98,98 70,91,94,97,97 75,92,96,98,99 80,96,100,99,99 85,97,100,96,96 90,97,100,96,96  然后，绘制图4-7b，代码如下：
chest.hr=read.csv(&amp;#39;~/downloads/data/4-6-2-2.csv&amp;#39;,sep=&amp;#39;,&amp;#39;,header = T) chest.cloA=spline(chest.hr$time,chest.hr$cloA,n=2000) chest.cloB=spline(chest.hr$time,chest.hr$cloB,n=2000) plot(chest.cloA,col=&amp;#34;DarkTurquoise&amp;#34;,xlab=&amp;#34;Time(min)&amp;#34;,ylab=&amp;#34;Relative Humidity(%)&amp;#34;,type=&amp;#39;l&amp;#39;,lwd=2,xlim=c(0,90),ylim = c(30,120)) //30-120 lines(chest.cloB,col=&amp;#34;RosyBrown&amp;#34;,type=&amp;#34;l&amp;#34;,lwd=2) text.legend=c(&amp;#34;Experimental&amp;#34;,&amp;#34;Predictions&amp;#34;) legend(&amp;#34;topleft&amp;#34;,legend=text.legend,col=c(&amp;#34;Darkturquoise&amp;#34;,&amp;#34;RosyBrown&amp;#34;),text.col =c(&amp;#34;Darkturquoise&amp;#34;,&amp;#34;RosyBrown&amp;#34;),lty=c(1,1,1),cex=1.0) arrows(chest.hr$time, chest.hr$cloA-0.05*chest.hr$cloA,chest.hr$time, chest.hr$cloA&#43;0.05*chest.hr$cloA, length=0.05, angle=90, code=3) //绘制误差线  time,cloA,cloB 0,47,47 5,47.8,47.2 10,49,50.6 15,48.2,50.0 20,48.0,49.3 25,51.6,50.2 30,50.8,50.6 35,50,50.4 40,55.8,54.2 45,78,79 50,90,83 55,96,89 60,97,96 65,98,98 70,97,99 75,98,100 80,99,100 85,100,102 90,100,104  绘制图4-8 然后，绘制图4-8(a),代码如下：
ex4.8a=read.csv(&amp;#39;~/downloads/screen/data/4-8-1-1.csv&amp;#39;,sep=&amp;#39;,&amp;#39;,header = T) layer1=spline(ex4.8a$time,ex4.8a$cloA,n=2000) layer2=spline(ex4.8a$time,ex4.8a$cloB,n=2000) plot(layer1,col=&amp;#34;Coral&amp;#34;,xlab=&amp;#34;time(min)&amp;#34;,ylab=&amp;#34;Temperature(deg)&amp;#34;,type=&amp;#39;l&amp;#39;,lwd=2,ylim = c(29,35)) lines(layer2,col=&amp;#34;DodgerBlue&amp;#34;,type=&amp;#34;l&amp;#34;,lwd=2) text.legend=c(&amp;#34;Clothing A&amp;#34;,&amp;#34;Clothing B&amp;#34;) legend(&amp;#34;topright&amp;#34;,legend=text.legend,col=c(&amp;#34;Coral&amp;#34;,&amp;#34;DodgerBlue&amp;#34;),text.col=c(&amp;#34;Coral&amp;#34;,&amp;#34;DodgerBlue&amp;#34;),lty=c(1,1,1)) time,cloA,cloB 0,33.4,33.4 5,33.42,33.62 10,33.6,33.9 15,33.72,34.1 20,33.82,34.2 25,33.9,34.27 30,34.15,33.68 35,34.20,33.12 40,33.23,31.8 45,31.46,31.1 50,31,31.52 55,31.5,31.25 60,31.29,31.02 65,31.27,31.00 70,31.06,30.90 75,30.82,30.72 80,30.62,30.52 85,30.38,30.39 90,30.46,30.50  然后，绘制图4-8(b),代码如下：
ex4.8b=read.csv(&amp;#39;~/downloads/screen/data/4-8-2-1.csv&amp;#39;,sep=&amp;#39;,&amp;#39;,header = T) layer1=spline(ex4.8b$time,ex4.8b$cloA,n=2000) layer2=spline(ex4.8b$time,ex4.8b$cloB,n=2000) plot(layer1,col=&amp;#34;Coral&amp;#34;,xlab=&amp;#34;time(min)&amp;#34;,ylab=&amp;#34;Relative Humidity(%)&amp;#34;,type=&amp;#39;l&amp;#39;,lwd=2,ylim = c(40,120)) lines(layer2,col=&amp;#34;DodgerBlue&amp;#34;,type=&amp;#34;l&amp;#34;,lwd=2) text.legend=c(&amp;#34;Clothing A&amp;#34;,&amp;#34;Clothing B&amp;#34;) legend(&amp;#34;topleft&amp;#34;,legend=text.legend,col=c(&amp;#34;Coral&amp;#34;,&amp;#34;DodgerBlue&amp;#34;),text.col=c(&amp;#34;Coral&amp;#34;,&amp;#34;DodgerBlue&amp;#34;),lty=c(1,1,1)) time,cloA,cloB 0,47,47 5,48,47.2 10,46,50.6 15,47,50 20,45.8,49.3 25,48.6,50.2 30,47.2,50.6 35,48,75 40,54,88 45,70,89 50,80,92.8 55,87,96 60,91,96 65,92,97 70,91,96 75,92,97 80,96,98 85,97,98.5 90,97,101.5  绘制图4-9 首先，绘制图4-9(a),代码如下：
ex4.9a=read.csv(&amp;#39;~/downloads/screen/data/4-9-1.csv&amp;#39;,sep=&amp;#39;,&amp;#39;,header = T) //4-9-1  layer1=spline(ex4.9a$time,ex4.9a$cloA,n=2000) layer2=spline(ex4.9a$time,ex4.9a$cloB,n=2000) plot(layer1,col=&amp;#34;Coral&amp;#34;,xlab=&amp;#34;time(min)&amp;#34;,ylab=&amp;#34;Temperature(deg)&amp;#34;,type=&amp;#39;l&amp;#39;,lwd=2,ylim = c(29,35)) lines(layer2,col=&amp;#34;DodgerBlue&amp;#34;,type=&amp;#34;l&amp;#34;,lwd=2) text.legend=c(&amp;#34;Clothing A&amp;#34;,&amp;#34;Clothing B&amp;#34;) legend(&amp;#34;topright&amp;#34;,legend=text.legend,col=c(&amp;#34;Coral&amp;#34;,&amp;#34;DodgerBlue&amp;#34;),text.col=c(&amp;#34;Coral&amp;#34;,&amp;#34;DodgerBlue&amp;#34;),lty=c(1,1,1)) time,cloA,cloB 0,33.4,33.40 5,33.55,33.56 10,33.72,33.82 15,33.89,34.02 20,34.00,33.84 25,33.84,33.76 30,33.76,33.68 35,33.68,33.61 40,33.58,33.36 45,33.20,33.12 50,33.00,32.80 55,32.80,32.75 60,32.75,32.78 65,32.78,32.80 70,32.80,32.67 75,32.67,32.58 80,32.58,32.46 85,32.46,32.30 90,32.30,32.28  然后，绘制图4-9(b),代码如下：
ex4.9b=read.csv(&amp;#39;~/downloads/screen/data/4-9-2.csv&amp;#39;,sep=&amp;#39;,&amp;#39;,header = T) //4-9-2  layer1=spline(ex4.9b$time,ex4.9b$cloA,n=2000) layer2=spline(ex4.9b$time,ex4.9b$cloB,n=2000) plot(layer1,col=&amp;#34;Coral&amp;#34;,xlab=&amp;#34;time(min)&amp;#34;,ylab=&amp;#34;Relative Humidity(%)&amp;#34;,type=&amp;#39;l&amp;#39;,lwd=2,ylim = c(40,90)) lines(layer2,col=&amp;#34;DodgerBlue&amp;#34;,type=&amp;#34;l&amp;#34;,lwd=2) text.legend=c(&amp;#34;Clothing A&amp;#34;,&amp;#34;Clothing B&amp;#34;) legend(&amp;#34;topleft&amp;#34;,legend=text.legend,col=c(&amp;#34;Coral&amp;#34;,&amp;#34;DodgerBlue&amp;#34;),text.col=c(&amp;#34;Coral&amp;#34;,&amp;#34;DodgerBlue&amp;#34;),lty=c(1,1,1)) time,cloA,cloB 0,47,47 5,47.6,47.9 10,46.8,46.4 15,46.4,47.2 20,46.8,46.9 25,46.6,46.8 30,46.8,47.6 35,54.2,56.8 40,67.2,69.8 45,73,75.6 50,77,78.2 55,79,79.9 60,78.8,79.6 65,79.6,80.6 70,80,80.9 75,80.1,81.1 80,80.2,81.5 85,80.3,81.9 90,80.4,82.4  绘制图4-10 首先，绘制图4-10(a),代码如下：
ex4.10a=read.csv(&amp;#39;~/downloads/screen/data/4-6-3-1-1.csv&amp;#39;,sep=&amp;#39;,&amp;#39;,header = T) layer1=spline(ex4.10a$time,ex4.10a$cloA,n=2000) layer2=spline(ex4.10a$time,ex4.10a$cloB,n=2000) plot(layer1,col=&amp;#34;Coral&amp;#34;,xlab=&amp;#34;time(min)&amp;#34;,ylab=&amp;#34;Temperature(deg)&amp;#34;,type=&amp;#39;l&amp;#39;,lwd=2,ylim = c(29,35)) lines(layer2,col=&amp;#34;DodgerBlue&amp;#34;,type=&amp;#34;l&amp;#34;,lwd=2) text.legend=c(&amp;#34;1-layer&amp;#34;,&amp;#34;2-layer&amp;#34;) legend(&amp;#34;topright&amp;#34;,legend=text.legend,col=c(&amp;#34;Coral&amp;#34;,&amp;#34;DodgerBlue&amp;#34;),text.col=c(&amp;#34;Coral&amp;#34;,&amp;#34;DodgerBlue&amp;#34;),lty=c(1,1,1)) time,cloA,cloB 0,33.4,33.4 5,33.42,33.58 10,33.6,33.72 15,33.72,33.9 20,33.82,34.1 25,33.9,34.18 30,34.15,34.3 35,34.18,33.4 40,33.23,32 45,31.46,31 50,31,31.52 55,31.5,31.30 60,31.29,31.18 65,31.27,31.12 70,31.06,30.96 75,30.82,30.78 80,30.62,30.56 85,30.38,30.40 90,30.46,30.52  然后，绘制图4-10(b),代码如下：
ex4.10b=read.csv(&amp;#39;~/downloads/screen/data/4-6-3-2-1.csv&amp;#39;,sep=&amp;#39;,&amp;#39;,header = T) layer1=spline(ex4.10b$time,ex4.10b$cloA,n=2000) layer2=spline(ex4.10b$time,ex4.10b$cloB,n=2000) plot(layer1,col=&amp;#34;Coral&amp;#34;,xlab=&amp;#34;time(min)&amp;#34;,ylab=&amp;#34;Relative Humidity(%)&amp;#34;,type=&amp;#39;l&amp;#39;,lwd=2,ylim = c(40,120)) lines(layer2,col=&amp;#34;DodgerBlue&amp;#34;,type=&amp;#34;l&amp;#34;,lwd=2) text.legend=c(&amp;#34;1-layer&amp;#34;,&amp;#34;2-layer&amp;#34;) legend(&amp;#34;topleft&amp;#34;,legend=text.legend,col=c(&amp;#34;Coral&amp;#34;,&amp;#34;DodgerBlue&amp;#34;),text.col=c(&amp;#34;Coral&amp;#34;,&amp;#34;DodgerBlue&amp;#34;),lty=c(1,1,1)) time,cloA,cloB 0,47,47 5,48,48.8 10,46,46.8 15,47,48.2 20,45.8,47 25,47.6,49.6 30,48.6,50.6 35,49.4,52.2 40,54,60 45,70,76 50,80,87 55,87,93 60,91,95 65,92,97 70,91,96.2 75,92,99 80,96,101 85,97,102 90,97,102  </content>
    </entry>
    
     <entry>
        <title>C&#43;&#43; 常见知识点</title>
        <url>https://iihui.github.io/post/cpp-base/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>C&#43;&#43;</tag>
        </tags>
        <content type="html"> static的作用   对普通函数和全局变量而言static具有隐藏作用：将其修饰的全局变量和函数的作用域限定在本文件中。不加static修饰的函数和全局变量具有全局可见性。
  普通局部变量而言
  未初始化的static普通局部变量，编译器会将其初始化为0，因为BSS段(未初始化数据段）中所有的字节都默认为0x00。
  使用static修饰的普通局部变量的生存期为整个源程序，即初始化一次便具有记忆性。但是，作用域只在定义该变量的函数中。
void testLocalStaticVar(){ static int x = 4; x&#43;&#43;; std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; std::endl; } int main(int argc, char **argv) { for (int i = 0; i &amp;lt; 3; &#43;&#43;i) { testLocalStaticVar(); } return 0; } // 5,6,7     成员变量：
  属于类的，只有一份，每个对象共享，可以使用类名直接调用。
  除了基本整型的const static整型可以在类的定义体中初始化，其他的必须在类外初始化。
  sizeof计算的时候不会计算静态数据成员，因为它不放在栈区，放在全局（静态）存储区。
    成员函数：
  不与任何对象实例关联，所以没有this指针，因此不能访问非静态成员变量和成员函数。
  static成员函数不能声明为const。毕竟将函数声明为const就承诺不会修改该函数所属对象，而static成员函数不属于任何对象实例。
  因为没有this指针的开销，所以静态成员函数与类的非静态成员函数相比速度上有少许增长。
     const的作用 对于普通变量而言const修饰符的目的为了替代宏定义，与宏定义对比，总共有5点区别：
  const常量有类型，编译器对其进行类型安全检查；而宏定义没有类型，编译器只对宏定义进行字符替换。
  #define是一个编译时概念，在预处理的时候展开，进行直接替换，存储在代码段，不分配内存，生命周期止于编译时期；而const常量存在于数据段，分配内存，属于运行时的概念。
  宏定义可以使用#undef来使之前的宏定义失效；const常量定义后将在定义域内永久有效。
  使用const常量可能比使用#define产生更小的目标代码（例如代码中使用100次同一个宏定义）。
  常量折叠（编译期间简化常量表达式&amp;ndash;对常量表达式求值,并将求得的值替换表达式，放入到常量表中)。
   普通变量与const修饰符需注意的3点：
  声明const变量时必须进行初始化
  const对象的动态数组：必须提供数组的初始化
  const全局变量：在全局作用域中声明的const变量是定义该对象的文件的局部变量，此变量只存在于那个文件中，不能被其他文件所访问。   指针变量和const修饰符：
  const指针：一旦初始化便不能再指向别的对象，但是可以通过解引用来改变所绑定对象的值。
  指向const对象的指针：不能通过解引用来改变所指的对象的值，但是可以更改所指向的对象，即解除绑定，重新再绑定。
  指向const对象的const指针：一旦初始化便不能再指向别的对象，也不能通过解引用来改变所指的对象的值。
   函数与const修饰符：
  函数的返回值和const修饰符：
 如果返回值是值类型(非指针、引用类型），对于内部数据类型来说，返回值是否是常量并没有关系。而对类类型如果返回值为某个对象的const或某个对象的引用const，则返回值具有const属性，只能访问返回值的公有(可能也可以保护成员）数据成员和const成员函数，并且不允许进行赋值操作。     如果返回值是指针类型，函数不能返回局部变量的指针，因为函数调用之后栈被清理，只能返回指向堆区的分配的存储空间的指针，或者指向静态存储区的指针，因为在函数返回后它们依然有效。   函数的参数和const修饰符：
  如果是传值：对函数调用者的约束不太大，可以传入一个const变量也可以传入一个普通变量，只能说明在函数中不会改变其值。
  如果是传指针：对于指向非const变量的指针参数，只能传入一个指向非const变量的指针，不能传入一个const指针，因为指明不能通过解引用来改变值。因此，若是传地址，则无论什么时候传递一个地址给函数，应该尽可能用const修饰它（除非此实参在函数内需要修改），如果不这么做，就使得指向const的指针不能做实参。
     函数参数为const引用时可以接收临时对象。   成员变量和const修饰符：
  对于类来说const变量是可变的，但是对于对象实例来说是不可变的。
  必须在构造函数的成初始化列表中初始化。   成员函数和const修饰符：
  this指针类型由obj * const 变为 const obj * const
  const对象实例、指向const对象的指针、指向const对象的引都只能调用const成员函数。const实施于成员函数的目的，确保该成员函数可作用于const对象实例。如果不存在const成员函数，则const对象实例无法调用任何成员函数。  对于非const对象而言可以调用const成员函数和非const成员函数。   C&#43;&#43;构造函数 构造函数的特点 构造函数是一种特殊的成员函数， 它具有如下特点：
  名字与类名相同。
  没有返回值。
  在对象创建时自动调用，但是不能被显式调用。
   构造函数的作用   给创建的对象建立一个标识符;
  为对象数据成员开辟内存空间;
  完成对象数据成员的初始化。
![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-05-02 上午8.27.52.png)
   构造函数的分类 构造函数可以分为普通的构造函数和拷贝(复制)构造函数：
  普通的构造函数
  拷贝构造函数: 对于一个构造函数的第一个参数为如下的几种，而且其他参数都有默认值，称为拷贝构造函数：
 A &amp;amp; const A &amp;amp; volatile A &amp;amp; 其中volatile（不稳定的）编译器访问该变量的代码不再进行优化 const volatile A &amp;amp;     防止默认拷贝发生：声明一个私有的拷贝构造函数  因此一个类其实可以有多个拷贝构造函数，拷贝构造函数又分为：
  浅拷贝：只对对象中的数据成员进行简单的赋值。
  深拷贝：对于对象中动态成员重新分配空间。
   malloc/free和new/delete的区别   malloc/free是标准库函数，而new/delete是C&#43;&#43;运算符。
  new自动计算需要分配的空间，而malloc需要手工计算字节数。
  new是类型安全的，因为new中内置了sizeof, 具有类型转换和类型安全检查功能，而malloc不是类型安全的。
int * p = new float[2]; //编译时指出错误 int *p = (int*)malloc(2*sizeof(double)); //编译时无法指出错误   new首先调用operator new标准库函数，分配足够大的原始的未类型化的空间。接下来调用相关对象的构造函数，以初始化对象。最后返回新分配并构造的对象的指针。而malloc不能调用构造函数；delete将调用该实例的析构函数，然后调用operator delete标准库函数以施放该实例占用的空间，free不能调用析构函数。 ![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-05-02 上午8.27.52.png)
  malloc/free需要头文件支持，而new/delete不需要。
  new操作自由存储区(free store)上为对象动态分配内存空间，而malloc函数从堆上动态分配内存。
  自由存储区是C&#43;&#43;基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。
  堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配，C语言使用malloc从堆上分配内存，使用free释放已分配的对应内存。
  那么自由存储区是否能够是堆（问题等价于new是否能在堆上动态分配内存），这取决于operator new的实现细节。自由存储区不仅可以是堆，还可以是静态存储区，这都看operator new在哪里为对象分配内存。
  特别地，new甚至可以不为对象分配内存。定位new的功能可以办到这一点： ![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-05-02 上午8.26.28.png)
    new内存分配失败时会抛出bad_alloc异常，它不会返回NULL；malloc分配内存失败时返回NULL。
  是否可以被重载 ![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-05-02 上午8.29.22.png)
  new与malloc是否可以相互调用：operator new /operator delete的实现可以基于malloc，而malloc的实现不可以去调用new。
  能够直观地重新分配内存：使用malloc分配的内存后，如果在使用过程中发现内存不足，可以使用realloc函数进行内存重新分配实现内存的扩充。realloc先判断当前的指针所指内存是否有足够的连续空间，如果有，原地扩大可分配的内存地址，并且返回原来的地址指针。如果空间不够，先按照新指定的大小分配空间，将原有数据从头到尾拷贝到新分配的内存区域，而后释放原来的内存区域。
  内存分配不足的处理：在operator new抛出异常以反映一个未获得满足的需求之前，它先调用一个用户指定的错误处理函数，这就是new-handler。![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-05-02 上午8.32.56.png) ![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-05-02 上午8.30.59.png)
   堆和栈的区别 堆和栈的区别，总共分为6点：  C&#43;&#43;空类默认生成的成员函数   构造函数
  拷贝构造函数
  赋值操作符
  析构函数
  取址运算符
  取址运算符const版本
   delete和delete[]的区别   针对基本数据类型：使用new分配后的不管是数组还是非数组形式内存空间用两种方式均可，原因是：分配简单类型内存时，内存大小已经确定，系统可以记忆并且进行管理，在析构时，系统并不会调用析构函数。  针对类类型：
  delete ptr;代表用来释放内存，且只用来释放ptr指向的内存。
  delete[] ptr; 用来释放ptr指向的内存，还逐一调用数组中每个对象的destructor。![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-05-01 下午2.51.46.png)
  delete a;仅释放了a指针指向的内存空间 , 也就是只调用了 a[0]对象的析构函数， 剩下的从a[1]到a[9]这9个用户自行分配的m_cBuffer对应内存空间将不能释放从而造成内存泄漏。
  delete [] a;释放了a指针指向的全部内存空间，也就是调用a[0]到a[9]对象的析构函数释放分配的内存空间。
     虚函数表 ![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-05-01 下午11.09.32.png)
![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-05-01 下午11.10.04.png)
 一般继承 ![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-05-01 下午11.10.31.png)
多重继承-无虚函数覆盖 多重继承时，有几个基类就有几个vptr![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-05-01 下午11.11.02.png)
这样做就是为了解决不同的父类类型的指针指向同一个子类实例，而能够调用到实际的函数。
 多重继承-有虚函数覆盖 ![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-05-01 下午11.11.54.png)
 哪些函数不能为虚函数   普通函数 ： 只能重载不能被重写,即不能被继承  静态成员函数: 不属于任何对象实例，因而没有动态绑定的
  构造函数
![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-05-01 下午11.07.52.png) 按照 动态绑定原理，此时B的构造函数会覆盖掉A的构造函数  友元函数： C&#43;&#43;不支持友元函数的继承
  内联函数：
  赋值操作符重载函数
![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-05-01 下午11.08.16.png)
   C&#43;&#43;对象布局   单一的一般继承   多重继承   重复继承   菱形继承 ![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-05-01 下午11.06.45.png)    内存溢出 内存溢出(out of memory）：是指程序在申请内存时，没有足够的内存空间供其使用。导致不够用的原因很多,泄漏只是其中一种。通常在运行大型软件或游戏时，软件或游戏所需要的内存远远超出了你主机内安装的内存所承受大小，就叫内存溢出。
内存溢出的几种情况：
  比如系统只有存放integer的空间，但你却申请了存放long，那就是内存溢出。
  比方定义了20个字节大小的内存空间，却写入了21个字节的数据。通俗的说，就是内存不够，没办法支持当前程序。（当发生内存溢出时，程序将无法进行，强制终止。）
   内存泄漏 内存泄漏是指你向系统申请分配内存进行使用(new)，可是使用完了以后却不归还(delete)，结果你申请到的那块内存你自己也不能再访问（也许你把它的地址给弄丢了），而系统也不能再次将它分配给需要的程序。一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光。
内存泄漏的分类：
  常发性内存泄漏。发生内存泄漏的代码会被多次执行到，每次被执行的时候都会导致一块内存泄漏。
  偶发性内存泄漏。发生内存泄漏的代码只有在某些特定环境或操作过程下才会发生。常发性和偶发性是相对的。对于特定的环境，偶发性的也许就变成了常发性的。所以测试环境和测试方法对检测内存泄漏至关重要。
  一次性内存泄漏。发生内存泄漏的代码只会被执行一次，或者由于算法上的缺陷，导致总会有一块仅且一块内存发生泄漏。比如，在类的构造函数中分配内存，在析构函数中却没有释放该内存，所以内存泄漏只会发生一次。
  隐式内存泄漏。程序在运行过程中不停的分配内存，但是直到结束的时候才释放内存。严格的说这里并没有发生内存泄漏，因为最终程序释放了所有申请的内存。但是对于一个服务器程序，需要运行几天，几周甚至几个月，不及时释放内存也可能导致最终耗尽系统的所有内存。所以，我们称这类内存泄漏为隐式内存泄漏。
   C&#43;&#43;中哪些操作符是不能重载的   .  （成员访问运算符)
  .* (成员指针访问运算符）
  :: （域运算符）
  sizeof
  ?: (条件运算符）
  typeid 域运算符和sizeof运算符的运算对象是类型而不是变量或者一般的表达式，不具备重载的特征   C&#43;&#43;强制类型转换 static_cast   static_cast也可以用在于基类与派生类指针或引用类型之间的转换。然而它不做运行时的检查，不如dynamic_cast安全。static_cast仅仅是依靠类型转换语句中提供的信息来进行转换，而dynamic_cast则会遍历整个类继承体系进行类型检查,因此dynamic_cast在执行效率上比static_cast要差一些。
  编译器隐式执行的任何类型转换都可以由static_cast来完成，比如int与float、double与char、enum与int之间的转换等。
![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-05-02 上午9.45.33.png)
   const_cast  将转换掉表达式的const性质。 ![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-05-02 上午9.39.34.png)  那既然const变量的值是肯定不会发生变化的，还需要这个const_cast类型转化有何用？这就引出了const_cast的最常用用法：
如果 有一个函数，它的形参是non-const类型变量，而且函数不会对实参的值进行改动，这时我们可以使用类型为const的变量来调用函数，此时const_cast就派上用场了。![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-05-02 上午9.41.33.png)
const_cast绝对不是为了改变const变量的值而设计的！在函数参数的传递上const_cast的作用才显现出来。 只有使用const_cast才能将const性质性质转化掉。试图使用其他三种形式的强制转换都会导致编译时的错误。（添加const还可以用其他转换符，如static_const）
  除了添加const或删除const特性，使用const_cast符来执行其他任何类型的转换都会引起编译错误。
   dynamic_cast   类型必须为类的指针，引用、void*  需要检查运行时类型信息，而这个信息存储在虚函数表中，所以只有定义了虚函数的类才可以使用，否则会出现编译错误
  如果绑定到引用或指针对象的类型不是目标类型，则dynamci_cast失败，指针会返回0，引用会抛出bad_cast异常。   reinterpret_cast 仅仅重新解释类型，但没有进行二进制的转换:
  转换的类型必须是一个指针、引用、算术类型、函数指针或者成员指针
  在比特位级别上进行转换。它可以把一个指针转换成一个整数，也可以把一个整数转换成一个指针（先把一个指针转换成一个整数，在把该整数转换成原类型的指针，还可以得到原先的指针值）
  最普通的用途就是在函数指针类型之间进行转换
   C&#43;&#43; 中的引用   引用是变量的别名，定义引用的时候必须先初始化  不能定义引用数组  不能定义引用的引用
  引用可以减少构造开销
  当函数返回引用类型时，没有复制返回值，返回的是对象本身，所以不要返回局部对象的引用  函数参数为const引用时可以接收临时对象   </content>
    </entry>
    
     <entry>
        <title>线性表</title>
        <url>https://iihui.github.io/post/arith-linear-list/</url>
        <categories>
          <category>算法</category>
        </categories>
        <tags>
          <tag>算法</tag>
        </tags>
        <content type="html">  线性表是由 $n$个具有相同特性的元素$(n \ge 0)$ 组成的一个有限序列，是一种逻辑结构。它的特征在于：①表中所有数据元素类型相同。②表由有限个数据元素构成。③表中数据元素是位置相关的（这一点表明线性表不同于集合)，并且每个元素都有一个对应的序号，表中元素可以重复出现。 逻辑结构 线性表是一种逻辑结构，其一般表示为: ($a_1,a_2,&amp;hellip;,a_{i-1},a_i,a_{i&#43;1},&amp;hellip;,a_n$)
  除了起始元素$a_1$没有前驱元素之外，其他元素$a_i$有且仅有一个前驱元素$a_{i-1}$。
  除了终端元素$a_n$没有后继元素外，其他元素$a_i$有且仅有一个后继元素$a_{i&#43;1}$。
  根据上面的表示，在线性表中，每个元素至多只有一个前驱元素，并且至多只有一个后继元素。
存储结构 线性表是一种逻辑结构，其存储结构有两种：
  顺序存储：顺序表
  链式存储：单链表
  顺序表 线性表的顺序存储是指一组地址连续的存储单元依次存储线性表中的各个元素，使得线性表中在逻辑结构上相邻的数据元素存储在相邻的物理存储单元中。即通过数据元素物理存储的相邻关系来反映数据元素之间逻辑上的相邻关系，采用顺序存储结构的线性表通常称为顺序表。
顺序表的特点 根据顺序表的定义，总结顺序表有以下的特征：
  属于直接映射——逻辑上相邻的元素，其物理位置也相邻。
  具有随机存取特性，通过首地址和元素序号可以在 $O(1)$ 时间内找到指定元素。
  存储密度高，其值为$1$。$存储密度=\frac{节点数据本身所占用的存储量}{节点结构占用的存储量}$
  删除和插入元素需要移动大量元素：
  插入元素移动的平均次数$=\frac{1}{n}\sum_{i=1}^{n}(n-i&#43;1)=\frac{n}{2}$, 因此时间复杂度为$O(n)$。
  删除元素移动的平均次数$=\frac{1}{n}\sum_{i=1}^{n}(n-i)=\frac{n-1}{2}$，因此时间复杂度为$O(n)$。
    描述顺序表的结构 为了描述顺序表，需要知道：① 顺序表的起始地址；② 顺序表的最大长度；③ 顺序表的当前长度。
#define MaxSize 1000typedef struct { int data[MaxSize]; int length; } SqList; 一些习题 最长平台 给定一个有$n$个元素的整型数组$data$,其中连续的相等元素构成的子序列称为平台，请设计一个算法求 $data$ 中最长平台的长度。
template&amp;lt;typename T&amp;gt; int linerArith&amp;lt;T&amp;gt;::maximumPlatform(T *data, int length) { int start = 0; int maxLen = 1; int curLen = 1; for (int i = 1; i &amp;lt; length; &#43;&#43;i) { if (data[i] == data[start]) { curLen&#43;&#43;; } else { if (curLen &amp;gt; maxLen) { maxLen = curLen; } curLen = 1; start = i; } } //可能最后一个连续的子序列为最大平台  if (curLen &amp;gt; maxLen) { maxLen = curLen; } return maxLen; } 以key为轴调整 设有一个数组 $data$ , 其元素为整型数据，设计一个算法将 $data$ 中所有小于 $key$ 的整数放在前半部分，大于等于 $key$ 的整数放在后半部分。
template&amp;lt;typename T&amp;gt; void linerArith&amp;lt;T&amp;gt;::rotate(T *data, int length, int key) { assert(length &amp;gt;= 0); int start = 0, end = length - 1; while (start &amp;lt; end) { while (start &amp;lt; end &amp;amp;&amp;amp; data[start] &amp;lt; key) { start&#43;&#43;; } while (start &amp;lt; end &amp;amp;&amp;amp; data[end] &amp;gt;= key) { end--; } if (start &amp;lt; end) { std::swap(data[start], data[end]); } } } 以第一个元素为轴调整 设有一个数组 $data$，其元素为整型。设计一个尽可能高效的算法，以第一个元素为分界线，将所有小于等于它的元素移到该元素前面，将所有大于它的元素移到该元素的后面。
template&amp;lt;typename T&amp;gt; void linerArith&amp;lt;T&amp;gt;::rotateByFirst(T *data, int length) { assert(length &amp;gt;= 0); int start = 0, end = length - 1; T pivot = data[0]; while (start &amp;lt; end) { while (start &amp;lt; end &amp;amp;&amp;amp; data[start] &amp;lt;= pivot) { start&#43;&#43;; } while (start &amp;lt; end &amp;amp;&amp;amp; data[end] &amp;gt; pivot) { end--; } if (start &amp;lt; end) { std::swap(data[start], data[end]); } } //因为忽略了第一个元素，因此这里需要检查最终位置的那个元素和第一个元素的大小关系  if (data[start] &amp;lt; pivot) { std::swap(data[start], data[0]); } } template&amp;lt;typename T&amp;gt; void linerArith&amp;lt;T&amp;gt;::rotateByFirstVersion2(T *data, int length) { assert(length &amp;gt;= 0); int start = 0, end = length - 1; int pivot = data[0]; while (start &amp;lt; end) { while (start &amp;lt; end &amp;amp;&amp;amp; data[end] &amp;gt; pivot) { end--; } if (start &amp;lt; end) { data[start&#43;&#43;] = data[end]; } while (start &amp;lt; end &amp;amp;&amp;amp; data[start] &amp;lt;= pivot) { start&#43;&#43;; } if (start &amp;lt; end) { data[end--] = data[start]; } } data[start] = pivot; //找到最终位置 } //剑指offer里快速排序的思路,该算法可以保持相对次序不变 template&amp;lt;typename T&amp;gt; void linerArith&amp;lt;T&amp;gt;::rotateByFirstVersion3(T *data, int length) { assert(length &amp;gt;= 0); int i = 0; T pivot = data[0]; for (int j = 1; j &amp;lt; length; &#43;&#43;j) { //是小于不是&amp;lt;=,因为第一个元素要被替换掉  if (data[j] &amp;lt; pivot) { i&#43;&#43;; if (i &amp;lt; j) { std::swap(data[i], data[j]); } } } //最后交换下标为0的元素和下标为i的元素  std::swap(data[0],data[i]); } void move1(SqList &amp;amp;L) { int i = 0; j = L.length - 1; int pivot = L.data[0]; int tmp; while (i &amp;lt; j) { while (i &amp;lt; j &amp;amp;&amp;amp; L.data[j] &amp;gt; pivot) j--; while (i &amp;lt; j &amp;amp;&amp;amp; L.data[i] &amp;lt;= pivot) //第一个元素肯定会被忽略掉  i&#43;&#43;; //此处可以添加一个 i &amp;lt; j 的判断，这里省略掉是因为前面已经判断i&amp;lt;j,  //所以到这里的时候最多也是i==j, 这时候直接交换也是没有副作用的  tmp = L.data[i]; L.data[i] = L.data[j]; L.data[j] = tmp; } if (L.data[i] &amp;lt; pivot)//因为忽略了第一个元素，因此这里需要检查最终位置的那个元素和第一个元素的大小关系  { tmp = L.data[0]; L.data[0] = L.data[i]; L.data[i] = tmp; } } void move2(SqList &amp;amp;L) { int i = 0, j = L.length - 1; int pivot = L.data[0]; while (i &amp;lt; j) { while (i &amp;lt; j &amp;amp;&amp;amp; L.data[j] &amp;gt; pivot) j--; //先从最后开始，因为第一个元素需要首先被替换  if (i &amp;lt; j) { L.data[i] = L.data[j]; i&#43;&#43;; } while (i &amp;lt; j &amp;amp;&amp;amp; L.data[i] &amp;lt;= pivot) i&#43;&#43;; if (i &amp;lt; j) { L.data[j] = L.data[i]; j--; } } L.data[i] = pivot; //最后找到最终的位置 } void move3(SqList &amp;amp;L) //剑指offer里快速排序的思路 { //该算法可以保持相对次序不变  int i = 0; int pivot = L.data[0]; int tmp; for (int j = 1; j &amp;lt; L.length; j&#43;&#43;) { if (data[j] &amp;lt; pivot) { i&#43;&#43;; if (i &amp;lt; j) //是小于不是&amp;lt;=,因为第一个元素要被替换掉  { tmp = L.data[i]; L.data[i] = L.data[j]; L.data[j] = tmp; } } } tmp = L.data[0]; //最后交换下标为0的元素和下标为i的元素  L.data[0] = L.data[i]; L.data[i] = tmp; } 删除元素 已知长度为$n$的数组$data$，编写一个时间复杂度为$O(n)$,空间复杂度为$O(1)$ 的算法，该算法删除线性表中所有值为$value$的元素。
template&amp;lt;typename T&amp;gt; int linerArith&amp;lt;T&amp;gt;::deleteSameElement(T *data, int length, int value) { assert(length &amp;gt;= 0); int base = 0; for (int i = 0; i &amp;lt; length; &#43;&#43;i) { if (data[i] != value) { data[base&#43;&#43;] = data[i]; } } return base; } template&amp;lt;typename T&amp;gt; int linerArith&amp;lt;T&amp;gt;::deleteSameElement(T *data, int length, int value) { assert(length &amp;gt;= 0); int count = 0; //不同的是记录目前等于value的元素个数  for (int i = 0; i &amp;lt; length; &#43;&#43;i) { if (data[i] == value) { count&#43;&#43;; } else { data[i - count] = data[i]; } } return length - count; } 一般类似的题目有：已知长度为 $n$ 的线性表 $L$ 采用顺序存储结构，试设计一个时间复杂度空间复杂度两方面都尽可能高效的算法，该算法删除线性表中元素值为$[x,y]$之间的所有数据元素。
单链表 单链表是任意一组存储单元存放线性表中的元素，每个节点通过一个指针指向其后继节点。这组存储单元可以是连续的也可以是不连续的。单链表具有如下的特点：
  通过首节点(带哨兵节点或不带哨兵节点)的指针来标识一个单链表。
  从一个已知节点出发，只能访问该节点和通过 $next$ 指针访问其后继节点，无法直接找到该节点之前的其他节点。
  在单链表中插入一个节点或者删除一个节点必须找到其前驱节点，插入和删除操作不需要移动节点。「删除一个节点也可以不用知道其前驱节点，只要将其后继节点的元素内容往前移到当前节点，并将当前节点的后继修改为其后继节点的后继节点，然后删除后继节点即可。但是要考虑该节点是否为最后一个节点，或者第一个节点」  typedef struct LinkedNode { T data; //T表示数据类型  struct LinkedNode *next; } LinkedList;  建立单链表 建立单链表有两种方式，一种是从头部插入；另一种是从尾部插入。从头部插入节点生成的单链表，最后节点元素顺序与插入元素的顺序相反，即成逆序排列了。void creatLinkedList(LinkedList *&amp;amp;L, int *a, int n) { LinkedList *cur; L = (LinkedList *) malloc(sizeof(LinkedList)); L-&amp;gt;next = NULL; for (int i = 0; i &amp;lt; n; i&#43;&#43;) { cur = (LinkedList *)(malloc(sizeof(LinkedList))); cur-&amp;gt;data = a[i]; cur-&amp;gt;next = L-&amp;gt;next; L-&amp;gt;next = cur; //当前节点成为哨兵节点的下一个节点  } } 尾插法是在单链表的尾部插入节点元素，最后生成的单链表的节点元素顺序和插入元素的顺序是相同的。
void creatLinkedList(LinkedList *&amp;amp;L, int *a, int n) { LinkedList *cur, *tail; L = (LinkedList *) malloc(sizeof(LinkedList)); tail = L; //tail始终指向最后的节点，开始时指向链表的头结点  for (int i = 0; i &amp;lt; n; i&#43;&#43;) { cur = (LinkedList *) malloc(sizeof(LinkedList)); cur-&amp;gt;data = a[i]; tail-&amp;gt;next = cur; tail = cur; } tail-&amp;gt;next = NULL; } 基本操作  按序号查找节点值算法  bool findNode(LinkedList *L,int i,int &amp;amp;result) { int j=0; LinkedList *cur=L; while(cur!=NULL &amp;amp;&amp;amp; j&amp;lt;i) { j&#43;&#43;; cur=cur-&amp;gt;next; } if(NULL==cur) return false; result=cur-&amp;gt;data; return true; } 按元素值查找序号算法  int findNode(LinkedList *L,int key) { LinkedList *cur=L-&amp;gt;next; int index=0; while(cur!=NULL &amp;amp;&amp;amp; cur-&amp;gt;data!=key) { index&#43;&#43;; cur=cur-&amp;gt;next; } if(cur!=NULL) return index; else return -1; //返回-1，表示没有找到该元素 }   插入元素：将值为$x$的元素的新节点插入到第$i$个节点的位置上，即先在单链表中找到插入节点的前驱节点，即第$i-1$个节点，再在其后插入新节点。
cur-&amp;gt;next=pre-&amp;gt;next; //cur表示将要插入到链表中的节点,插入的位置是节点pre之后  pre-&amp;gt;next=cur;   删除元素:将单链表中的第$i$个节点删除。
cur=pre-&amp;gt;next; //pre-&amp;gt;next是待删除的节点，cur是待删除节点的上一个节点  pre-&amp;gt;next=cur-&amp;gt;next; free (cur);    就地逆置 有一个线性表$(a_1,a_2,&amp;hellip;,a_n)$ 采用带哨兵节点的单链表$L$存储，设计一个就地算法将其就地逆置，所谓“就地”是指算法的辅助空间为$O(1)$。void reverse(LinkedList * &amp;amp; L) //传入引用 { LinkedList *cur=L-&amp;gt;next; LinkedList *next; L-&amp;gt;next=NULL; while(cur!=NULL) { next=ptr-&amp;gt;next; //先保存下一个节点，然后使用头插法进行逆置  cur-&amp;gt;next=L-&amp;gt;next; L-&amp;gt;next=cur; cur=next; } }  拆分链表 设$C={a_1,b_1,a_2,b_2,&amp;hellip;,a_n,b_n}$ 为一线性表，采用带哨兵节点的$hc$单链表存放，设计一个就地算法，将其拆分为两个线性表（它们都是用单链表存放）使得$A={a_1,a_2,&amp;hellip;,a_n},B={b_n,b_{n-1},&amp;hellip;,b_2,b_1}$，即$A$是正序排列，$B$是逆序排列。
//参数传入引用，ha存储是A，hb存储的是B void split(LinkedList *hc,LinkedList *&amp;amp;ha,LinkedList *&amp;amp; hb) { LinkedList *tail=ha; LinkedList *cur=hc-&amp;gt;next; LinkedList *next; hb-&amp;gt;next=NULL; while(cur != NULL) { tail-&amp;gt;next=cur; //尾插法  tail=cur; cur=cur-&amp;gt;next; next=cur-&amp;gt;next; cur-&amp;gt;next= hb-&amp;gt;next; //头插法  hb-&amp;gt;next= cur; cur=next; } tail-&amp;gt;next=NULL; //别忘了 } 递增排序 有一个带哨兵结点的单链表$L$,设计一个算法使其元素递增有序。最基本的想法是使用直接插入排序的思想，一个一个排，不同于数组排序，这里单链表只能从头开始查找。void sort（LinkedList * &amp;amp;L) { LinkedList *cur=L-&amp;gt;next; LinkedList *next=cur-&amp;gt;next; LinkedList *pre,*assist; //  cur-&amp;gt;next=NULL; //只含有一个元素的有序单链表  cur=next; while(cur!=NULL) { next=cur-&amp;gt;next; //首先保存下一个链表节点  pre=L; //单链表只能从头开始往后寻找节点  assist=pre-&amp;gt;next; //assist从头开始遍历  while(assist!=NULL &amp;amp;&amp;amp; assist-&amp;gt;data &amp;lt; cur-&amp;gt;data) { pre=assist; //pre记录插入位置的前一个节点  assist=assist-&amp;gt;next; } cur-&amp;gt;next=pre-&amp;gt;next; //pre的下一个节点就是要插入的位置  pre-&amp;gt;next=cur; //pre的下一个节点就是要插入的位置  cur=next; } }  公共节点 给定两个单链表，编写算法找出其公共的节点。第一种方法分析：从头到尾扫描单链表$A$，判断当前元素是否在单链表$B$中出现，若在则插入到单链表$C$中。
void findSameNode(LinkedList *A,LinkedList *B,LinkedList *&amp;amp;C) { LinkedList *curA=A-&amp;gt;next; LinkedList *curB=B-&amp;gt;next; LinkedList *tail; //尾插法构建新的单链表  C=(LinkedList*)malloc(sizeof(LinkedList)); //静态存储区分配内存  C-&amp;gt;next=NULL; tail=C; while(curA!=NULL) { curB=B-&amp;gt;next; while(curB!=NULL &amp;amp;&amp;amp; curB-&amp;gt;data!= curA-&amp;gt;data) curB=curB-&amp;gt;next; if(curB!=NULL) { tail-&amp;gt;next=curA; tail=curA; } curA=curA-&amp;gt;next; } tail-&amp;gt;next=NULL; //尾插法最后应该将尾巴的next域置空 } 第二种方法分析：借用两个辅助栈，分别存储两个链表遍历时的序列，然后同时将两个辅助栈中元素弹出，直到弹出的元素不相等，弹出时采用头插法进行构造新的单链表。
第三种方法分析：首先遍历两个链表，得到两个单链表的长度差$k$，然后长的单链表先走$k-1$步，然后短的和长的同时走，直到遇到相等的元素，即为新的单链表的首节点。
 精选习题 循环左移 将$n$个整数存放到一维数组$R$中。试设计一个在时间和空间尽可能高的算法。将$R$中保存的序列循环左移$p （0 \lt q\lt n)$个位置，即将$R$中的数据由$(X_0,X_1,...,X_{n-1})$变换为$(X_p,X_{p&#43;1},...,X_{n-1},X_0,X_1,....,X_{p-1})$
void reverse(int R[],int start,int end) { int i=start,j=end; int assist; while(i&amp;lt;j) { assist=R[i]; R[i]=R[j]; R[j]=assist; i&#43;&#43;; j--; } } void leftShift(int R[],int n,int p) { if(p&amp;gt;0 &amp;amp;&amp;amp;p&amp;lt;n) { reverse(R,0,n-1); reverse(R,0,n-p-1); reverse(R,n-p,n-1); } }  寻找中位数 给定两个数组$A$和$B$,数组的长度为$n$,两个数组都分别有序，求出两个数组中的所有数排序后的中位数「偶数序列中间两数的前一个为其中位数」。
解法一 因为数组$A$和$B$均有序，因此将两个数组排序后，第$n$个数就是题目中所要找的中位数。
int search(int A[], int B[], int n) { int i = 0, j = 0, k = 0; while (i &amp;lt; n &amp;amp;&amp;amp; j &amp;lt; n) { k&#43;&#43;; if (A[i] &amp;lt; B[j]) { if (k == n) return A[i]; i&#43;&#43;; } else { if (k == n) return B[j]; j&#43;&#43;; } } } 解法二 分别求出两个升序序列$A$，$B$的中位数，记为$a，b$。若$a=b$,则$a$或$b$即为所求，否则舍弃$a,b$中较小者所在序列的较小一半，同时舍弃较大者所在序列的较大一半，要求两次舍弃的元素个数相同（每次从左侧和右侧删除相同个数的元素后，新的两个数组，它们的中位数与原始数组的中位数是相同的）。重复上述过程，直到两个序列均只含一个元素为止，则较小的即为所求的中位数。
int searchMid(int A[], int B[], int n) { int startA, midA, endA; startA = 0; endA = n - 1; startB = 0; endB = n - 1; while (startA != endA || startB != endB) { midA = (startA &#43; endA) / 2; midB = (startB &#43; endB) / 2; if (A[midA] == B[midB]) return A[midA]; if (A[midA] &amp;lt; B[midB]) { if ((startA &#43; endA) % 2 == 0)//若元素个数为奇数时  { startA = midA; //舍弃A中间点以前的部分且保留中间点  endB = midB; //舍弃B中间点以后的部分且保留中间点  } else //若元素个数为偶数时  { startA = midA &#43; 1; //舍弃A的前半部分,每次舍弃的长度相同，可以保证同时到达  endB = midB; //舍弃B的后半部分  } } else if (A[midA] &amp;gt; B[midB]) { if ((startA &#43; endA) % 2 == 0)//若元素个数为奇数时  { endA = midA; //舍弃A中间点以后的部分且保留中间点  startB = midB;//舍弃B中间点以前的部分且保留中间点  } else //若元素个数为偶数时  { endA = midA; //舍弃A的后半部分  startB = midB &#43; 1; //舍弃B的前半部分  } } } return A[startA] &amp;lt; B[startB] ? A[startA] : B[startB]; //较小者即为所求 }   若$A$和$B$数组的长度为$2k&#43;1$，取$A$数组的中位数为$A[k]$，$B$数组的中位数为$B[k]$，$A$和$B$组合起来的中位数应该是第$2k&#43;1$大的那个数。如果$A[k]==B[k]$，则$A[k]$必定为第$2k&#43;1$大的数，是所有数字的中位数。如果$A[k]\gt B[k]$，则$A[k]$至少为第$2k&#43;2$大的数，$B[k]$至多为第$2k&#43;1$大的数，中位数介于$B[k]$和$A[k]$之间。
  若$A$和$B$数组的长度为$2k$，按照题目所述条件，则$A$的中位数为$A[k-1]$,则$B$的中位数为$B[k-1]$,$A$和$B$组合起来的中位数应该是第$2k$大的那个数，若$A[k-1]==B[k-1]$,则$B[k-1]$必为第$2k$大的那个数，即所有数字的中位数。如果$A[k-1]\gt B[k-1]$，则$A[k-1]$至少为第$2k$大的数，$B[k-1]$至多为第$2k-1$大的数，中位数介于$B[k-1]$和$A[k-1]$之间。   次数大于一半 已知一个整数序列$A=(a_0,a_1,...,a_{n-1})$，在这个序列中若存在「不要求连续的序列」$a_{p_1} = ... = a_{p_m} = x，0&amp;lt;= a_{i} &amp;lt; n, m &amp;gt; n/2 , (0 &amp;lt;= p_k &amp;lt; n, 1&amp;lt;=k&amp;lt;=m)$,则称 $x 为 A$ 的主元素，例如$A=(0,5,5,3,5,7,5,5)$,则$5$为主元素；又如$A=(0,5,5,3,5,1,5,7)$，则$A$中没有主元素。假设$A$中的 $n$ 个元素保存在一个一维数组中，请设一个尽可能高效的算法，找出$A$的主元素。若存在主元素，则输出该元素，否则输出$-1$。
解法一 主元素问题方法一：对数组中元素进行计数，然后查看出现次数最多的元素，若次数大于一半，则为主元素。这种方式只需要对数组扫描一遍，时间复杂度为$O(n)$,空间复杂度为$O(n)$。
int moreThanHalf(int A[],int n) { int *count=(int*)malloc(sizeof(int)*n); int index=0; for(int i=0;i&amp;lt;n;i&#43;&#43;) count[i]=0; for(int i=0;i&amp;lt;n;i&#43;&#43;) { count[A[i]]&#43;&#43;; if(count[A[i]) &amp;gt; count[A[index]]) index=A[i]; } if(count[index]&amp;gt;(n/2)) return index; else return -1; }  解法二 首先使用快速排序，将元素排好序，然后统计相同元素出现的最大次数。统计的时候可以使用求最长平台的算法。时间复杂度为$O(nlogn)$,空间复杂度为$O(n)$。
void quickSort(int A[],int start,int end) { int i=start,j=end; if(i&amp;lt;j) { while(i&amp;lt;j) { while(i&amp;lt;j &amp;amp;&amp;amp; A[j]&amp;gt;tmp) j--; A[i]=A[j]; if(i&amp;lt;j) { A[i]=A[j]; i&#43;&#43;; } while(i&amp;lt;j &amp;amp;&amp;amp; A[i]&amp;lt;=tmp) i&#43;&#43;; if(i&amp;lt;j) { A[j]=A[i]; j--; } } quickSort(A,start,i-1); quickSort(A, i&#43;1, end); } } //然后使用平台算法  解法三 数组中存在主元素时，所有的非主元素个数和必少于一半。如让主元素与一个非主元素&amp;quot;配对“，则最后多出来的元素（没有元素与之配对）就是主元素。从前往后扫描数组元素，假定遇到的当前值选定为主元素，再次遇到它时计数加1，遇到不等的值时，计数减1。当计数减为0后，将遇到的下一个值重新选定为主元素。扫描完毕，当前选定的元素（计数值大于0）可能是主元素，但未必是主元素。还需要对数组再进行一次扫描，记录它出现的实际个数，以判定它是否是主元素。时间复杂度为$O(n)$,空间复杂度为 $O(1)$。
void moreThanHalf(int A[],int n) { int pivot=A[0]; int count=1; int count2=0; for(int i=1;i&amp;lt;n;i&#43;&#43;) { if(A[i]==base) count&#43;&#43;; else { if(count&amp;gt;0) count--; else { pivot=A[i]; count=1; } } } if(count &amp;gt; 0) { count2=0; for(int i=0;i&amp;lt;n;i&#43;&#43;) { if(pivot==A[i]) count2&#43;&#43;; } if(count2 &amp;gt; n/2) return pivot; } return ERROR; //ERROR 代表不会在序列中出现的那个数 }  </content>
    </entry>
    
     <entry>
        <title>Go 标签</title>
        <url>https://iihui.github.io/post/go-label/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>Go</tag>
        </tags>
        <content type="html">  在for,switch或者select中都可以配合标签形式的标识符使用——某一行第一个以冒号结尾的单词（因为gofmt会自动将后续代码移动至下一行）。
 一个实例 package main import &amp;#34;fmt&amp;#34; func main() { LABEL1: for i := 0; i &amp;lt;= 5; i&#43;&#43; { for j := 0; j &amp;lt;= 5; j&#43;&#43; { if j == 4 { continue LABEL1 } fmt.Printf(&amp;#34;i is: %d, and j is: %d\n&amp;#34;, i, j) } } 注意事项   标签的名称是大小写敏感的，为了提升可读性，一般建议标签全部使用大写。
  使用逆向的go to语句容易产生意大利苗条似的代码，所以应该避免。逆向是指先使用go to语句，后定义标签。
  如果一定要使用标签，建议使用正向标签。但是，标签和go to 语句之间不能有变量定义，否则会出现编译错误。
  定义了标签，如果不使用标签会产生编译错误。
  正确使用标签的情形：发生错误时，跳出无限循环，并关闭某些东西。
   </content>
    </entry>
    
     <entry>
        <title>Go 中if语句</title>
        <url>https://iihui.github.io/post/go-if/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>Go</tag>
        </tags>
        <content type="html"> if是用于测试某个条件（布尔型，又被称为逻辑型）的语句，如果该条件成立，则会执行if后由大括号括起来的代码块，否则就忽略该代码块继续执行后续的代码。Go中if语句总共有三种形式，分别是：
  不带else的if；
  带一个else的if语句；
  带else if的if语句；
  包含初始化的if语句
   不带else的if 测试条件是布尔型的语句，如果该条件成立，则执行大括号中的内容。
if condition { //{ 与condition 须在同一行  //do something }  带else的if if condition { //do something }else{ //do something }  带else if的if if condition1 { // do something  } else if condition2 { // do something else } else { // catch-all or default }  带初始化的if if initialization; condition { // do something }   在if条件中声明的变量的作用域只存在于if结构中，即在if结构的大括号之间，如果使用if-else结构则在else代码块中变量也会存在。  如果变量在if结构之前就已经存在，那么在if结构中，该变量原来的值会被隐藏。
   注意事项   需要注意的是，即使代码块之间只有一条语句，大括号也不能被省略。
  关键字if和else之后的左大括号{必须和关键字在同一行，这是编译器强制规定的。
  如果使用了else-if结构，则前段代码块的右大括号}必须和else-if关键字在同一行，这是编译器强制规定的。
  使用gofmt格式化代码之后，每个分支内的代码都会缩进4个或8个空格，或者是1个 tab，并且右大括号与对应的if关键字垂直对齐。  当if结构内有break、continue、goto或者return语句时，Go 代码的常见写法是省略else部分。
   </content>
    </entry>
    
     <entry>
        <title>位运算算法</title>
        <url>https://iihui.github.io/post/arith-bits/</url>
        <categories>
          <category>算法</category>
        </categories>
        <tags>
          <tag>算法</tag>
        </tags>
        <content type="html"> 判断是否为2的n次方 对于整数数来说，如果一个数为$x=2^n$,那么必然有一位为1，右边其它位全为0。那么$(x-1)$在其对应为1的位置为0，对应位右边全部为1。因此，x&amp;amp;(x-1)的值则为0。
!(x&amp;amp;(x-1)) //正整数  位运算实现加法 对于二进制的加法，首先如果不考虑进位时：1&#43;1=0，0&#43;1=1，1&#43;0=1，0&#43;0=0，这是二进制的异或。然后，考虑进位1&#43;1=1，1&#43;0=0，0&#43;1=0，0&#43;0=0，这是二进制的与运算。
因此，二进制可以按照如下的方式进行：①首先不考虑进位的情况时，计算各位的累加得到值的累加a；②然后考虑有进位的情况，先计算进位并将其左移得到b，如果b的值为0，那么a的值就是最后的计算结果，如果b的值不为0，则a&#43;b是最后的结果。
非递归实现 int add(int x,int y) { int result=x,carray=y,tmp; while(carray!=0) { tmp = (result &amp;amp; carray) &amp;lt;&amp;lt;1; result ^= carray; carray = tmp; } return result; }  递归方式实现 int recAddNoArithm(int a, int b) { if (b == 0) return a; int sum = a ^ b; int carry = (a &amp;amp; b) &amp;lt;&amp;lt; 1; return recAddNoArithm(sum, carry); }  位运算实现减法 减法可以转换为加法，例如a-b可以写成a&#43;(-b)。因此，只要先通过b的值，求得-b的值，然后再利用上面的加法实现就可以得到a-b的值。由b求-b的快捷方式是按位取反，然后末位加1，因此位运算的减法如下所示：
int subNoArithm(int a, int b) { auto sub = nonRecAddNoArithm(~b, 1); return nonRecAddNoArithm(a, sub); }  交换两个数的值 在异或运算中，偶数个相同的数异或的结果为0；奇数个相同的数的异或的结果为还是当前数；某个数和0进行异或的结果仍为原数，并且异或运算是支持交换律的：
a = a ^ b; b = a ^ b; a = a ^ b; 上面是a在公式左边出现两次，或者b在公式左边出现两次，这两次是最开始和最后出现：
b = a ^ b; a = a ^ b; b = a ^ b;  两个数较大者 主要运用异或的特点：偶数个相同的数异或的结果为0；奇数个相同数异或结果还是当前数；某个数和0进行异或的结果仍为原数，并且异或运算是支持交换律的，对于-1来说其二进制位全部为1，
y ^ ((x ^ y) &amp;amp; (-(x &amp;gt;= y)) //快速记忆：y 在前则找较大者  两个数较小者 x ^ ((x ^ y) &amp;amp; (-( x &amp;gt;= y)) //快速记忆：x 在前则找较小者  两个数的平均值 (x &amp;amp; y) &#43; (x ^ y &amp;gt;&amp;gt; 1);  二进制中1的个数 利用n &amp;amp; (n-1) 第一种方式每次使用公式n&amp;amp;(n-1)可以去除二进制表示中的1位1，当所有位置的1都被去除之后，结果为0，这就是终止条件。
int getBinary1Bits1(int n) { int count = 0; while (n != 0) { n = n &amp;amp; (n - 1); //n &amp;amp; （n-1)每次可以去除二进制表示中的一个1  count&#43;&#43;; } return count; } //注意参数的变化 int getBinary1Bits2(unsigned int n) { int count = 0; while (n &amp;gt; 0) //终止条件是 n&amp;gt;0,因为 n 总是&amp;gt;=0  { n = n &amp;amp; (n - 1); count&#43;&#43;; } return count; }  利用标识位 第二种方式，使用一个标识数，其初始值设置为1。然后，使用这次标识数与当前数进行位与运算，便可得到当前位是否为1；接着，使标识数向左移动一位，然后重复上一步，最终得到1的个数。
int getBinary1Bits3(int n) { int count = 0; unsigned int flag = 1; //标识数应该声明为无符号数  while (flag != 0) { if (flag &amp;amp; n) { count&#43;&#43;; } flag = flag &amp;lt;&amp;lt; 1; } return count; } 利用汉明编码 第三种方式使用汉明：
typedef unsigned int64 uint64; //assume this gives 64-bits const uint64 m1 = 0x5555555555555555; //binary: 0101... const uint64 m2 = 0x3333333333333333; //binary: 00110011.. const uint64 m4 = 0x0f0f0f0f0f0f0f0f; //binary: 4 zeros, 4 ones ... const uint64 m8 = 0x00ff00ff00ff00ff; //binary: 8 zeros, 8 ones ... const uint64 m16 = 0x0000ffff0000ffff; //binary: 16 zeros, 16 ones ... const uint64 m32 = 0x00000000ffffffff; //binary: 32 zeros, 32 ones ... const uint64 hff = 0xffffffffffffffff; //binary: all ones const uint64 h01 = 0x0101010101010101; //the sum of 256 to the power of 0,1,2,3...  //This is a naive implementation, shown for comparison, //and to help in understanding the better functions. //It uses 24 arithmetic operations (shift, add, and). int popcount_1(uint64 x) { x = (x &amp;amp; m1 ) &#43; ((x &amp;gt;&amp;gt; 1) &amp;amp; m1 ); //put count of each 2 bits into those 2 bits  x = (x &amp;amp; m2 ) &#43; ((x &amp;gt;&amp;gt; 2) &amp;amp; m2 ); //put count of each 4 bits into those 4 bits  x = (x &amp;amp; m4 ) &#43; ((x &amp;gt;&amp;gt; 4) &amp;amp; m4 ); //put count of each 8 bits into those 8 bits  x = (x &amp;amp; m8 ) &#43; ((x &amp;gt;&amp;gt; 8) &amp;amp; m8 ); //put count of each 16 bits into those 16 bits  x = (x &amp;amp; m16) &#43; ((x &amp;gt;&amp;gt; 16) &amp;amp; m16); //put count of each 32 bits into those 32 bits  x = (x &amp;amp; m32) &#43; ((x &amp;gt;&amp;gt; 32) &amp;amp; m32); //put count of each 64 bits into those 64 bits  return x; } https://blog.csdn.net/gaomingyangc/article/details/54912633
 </content>
    </entry>
    
     <entry>
        <title>败者树</title>
        <url>https://iihui.github.io/post/arith-loser-tree/</url>
        <categories>
          <category>算法</category>
        </categories>
        <tags>
          <tag>算法</tag>
        </tags>
        <content type="html">  胜者树和败者树都是完全二叉树，是树形选择排序的一种变型。每个叶子结点相当于一个选手，每个中间结点相当于一场比赛，每一层相当于一轮比赛。不同的是，胜者树的中间结点记录的是胜者的标号；而败者树的中间结点记录的败者的标号。胜者树与败者树都可以在$log(n)$的时间内找到最值。任何一个叶子结点的值改变后，利用中间结点的信息，还是能够快速地找到最值，在k路归并排序中经常用到。
 胜者树 胜者树的父节点保存的是两两比较胜出者的下标，所以当重构时（一个选手的值发生改变时）只要找到其父节点然后与其兄弟节点比较，并将父节点更改为新的胜利节点的下标。
这是因为重构时覆盖原来叶子节点的下一个节点都比原叶子节点小，这里的小是指胜利的反方向，此时只要和败者比较就可以了，因为不清楚上一次的败者是谁，所以一定要和兄弟以及父节点比较。
因此，只要沿着发生改变的结点到根结点的路径修改这棵二叉树，而不必改变其他比赛的结果。在下面给出的例子的图示中都是数值越小表示胜利。
![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-09-29 下午9.29.49.png)
![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-09-29 下午9.32.04.png)
但是，胜者树每上升一次需要访问两个节点——父节点和兄弟节点。而对于败者树来说，它只要访问父节点，这是败者树的优势。
 败者树 对于胜者树来说，在节点上升的时候首先需要获得父节点，然后再获得兄弟节点，然后再比较。这时人们又想能否减少访存次数，于是就有了败者树。
在败者树中，用父结点记录其左右子结点进行比赛的败者，让胜者参加下一轮的比赛。败者树的根结点记录的是败者，因此，需要加一个结点来记录比赛的最终胜者。
![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-09-29 下午9.37.52.png)
败者树重构过程如下：①首先，将新进入败者树的新结点与其父结点进行比较，并将败者存放在父结点中；②然后，将第1步中比较后的胜者再与上一级的父结点比较。
因为重构时覆盖原来叶子节点的下一个节点都比原叶子节点小，这里的小是指胜利的反方向，所以只要和败者比即可。此时父节点记录的就是败者，因此，只要和父节点比较即可。所以说对于败者树来说，它只要访问父节点，这是败者树的优势。
![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-09-29 下午9.41.55.png)
 胜者树和败者树与堆的区别 相同点 胜者树、败者树和堆的相同点：空间和时间复杂度均相同——调整一次的时间复杂度都是 $O(logN)$，空间复杂度为$O(1)$。
 不同点 堆排序中每次取出当前最小值之后，把最后一个数换到堆顶。在调整堆的时候，每次都要选出父节点的两个孩子节点的最小值，然后再用孩子节点的最小值和父节点进行比较，所以每调整一次需要比较两次。
所以胜者树相对于堆来说减少了一次比较，败者树相对于胜者树来说减少了一个访存，但是并不能保证每次都可以减少一次访存。例如上题，假如$b_3$一开始是13，而不是6，那么$b_3$是败者，而此时$b_3$ 被替换为6时，由于此前 $b_3$ 为败者，因此此时就要和兄弟节点比较了，所以此时访存次数为2。
也就是说，堆排序中一定要和兄弟节点和父节点比较，即访存2次，比较2次；而胜者树只要和兄弟比较，但是需要访问兄弟节点和父节点，即访存2次，比较1次；而败者数一般和父节点比较，可能要和兄弟节点比较，因此访存此数可能比胜者树少1次，即访存是1次或者2次，比较1次。
 外排序 在外排序的K路归并的时候，由于需要访问外存，而对于计算来说此时访问外存是最主要的时间耗费。此时，常使用败者树来进行K路归并排序，归并的时候K个叶子节点保存的就是K个文件中的当前最小值。
所以对于K个有序段进行K路归并时的步骤为：
  取每个输入有序段的第一个数据作为败者树的叶子节点，建立初始败者树。然后，两两叶子节点进行比较，在双亲节点中记录比赛的败者，而让胜者去参加更高一层的比赛。最后，在根节点之上胜出的冠军是关键字最小者。
  胜出的记录写到输出归并段中，在对应的叶子节点处补充其输入有序段的下一个记录，若该段有序变空，则补充一个大关键字（比所有记录关键字都大，设为 $k_{max}$）。
  调整败者树，选择新的关键字最小的记录。从补充记录的叶子节点向上和双亲节点的关键字比较，败者留在该双亲节点，胜者继续向上，直到根节点，最后将胜者放到根节点的双亲节点中。
  若胜出的记录的关键字等于$k_{max}$,则归并结束，否则转到第2步。
   最佳归并树 若参加归并的初始归并段有m个，做k路平衡归并，最佳归并树是带权路径长度最短的k次哈夫曼树。则构造步骤如下：
  若 $(m-1),mod,(k-1) \neq 0$,则需要附加 $(k-1)-(m-1),mod,(k-1)$ 个长度为0的虚段，以使每次归并都可以对应$k$个段。
  按照哈夫曼树的构造规则构造最佳归并树。
  参考1 参考2 参考3
 </content>
    </entry>
    
     <entry>
        <title>剑指offer题集1</title>
        <url>https://iihui.github.io/post/arith-sword-1/</url>
        <categories>
          <category>算法</category>
        </categories>
        <tags>
          <tag>算法</tag>
        </tags>
        <content type="html"> 二维数组中查找 在一个二维数组中，每一行都按从左到右递增的顺序排序，每一列都按从上到下递增的顺序排列，试从该二维数组查找给定的元素。
首先应该从右上角的元素(记为cur)开始比较，如果当前要查找的元素key的值比cur大，那么就应该往cur所在行的下面开始寻找；如果key的值比cur小，那么应该往cur所在列的左边寻找，具体代码如下：
bool findKeyInMatrix(int *matrix, int rows, int colums, int key) { bool found = false; if (matrix != nullptr &amp;amp;&amp;amp; rows &amp;gt;= 0 &amp;amp;&amp;amp; colums &amp;gt;= 0) { int row = 0; int column = colums - 1; //row=0,column=colums-1表示定位到右上角的元素  int cur = 0; while (row &amp;lt; rows &amp;amp;&amp;amp; colums &amp;gt;= 0) { cur = matrix[row * colums &#43; column]; if (cur == key) { found = true; break; } else if (cur &amp;gt; key) { column--; } else { row&#43;&#43;; } }; } return found; }  字符串的赋值操作符重载 对于自定义的字符串类的赋值操作符的重载时，需要注意4点：①是否传入常引用const A &amp;amp;。②传入的引用是否是自身。 ③是否释放掉原来的空间。 ④是否返回*this。
class CMyString { private: char *pdata; public: CMyString(char *ptr = NULL); CMyString(const CMyString &amp;amp;str); CMyString &amp;amp;operator=(const CMyString &amp;amp;str); } ~CMyString() {} }; CMyString &amp;amp;CMyString::operator=(const CMyString &amp;amp;str) { if (this != &amp;amp;str) { CMyString tmp(str); char *ptmp = tmp.pdata; tmp.pdata = pdata; pdata = ptmp; } return *this; } 在这个赋值操作符重载函数中，首先创建了一个临时变量tmp，如果分配内存不成功的话，那么会抛出bad_alloc异常，此时也不会修改原来的对象实例。
如果正常分配的话，因为tmp是临时变量，所以在if的作用域结束之后，那么会自动调用析构函数，此时就会析构掉tmp.pdata所指向的内存。因为tmp.pdata已经和pdata交换了，所以这相当于自动调用析构函数释放实例的内存。
 从尾到头打印链表 从尾到头打印链表中的元素，有两种解决方法，一种是递归算法，另一种是利用栈来实现非递归算法。下面是递归算法的实现：
void recPrintLinkedList(LinkedNode *head) { if (head != nullptr) { recPrintLinkedList(head-&amp;gt;next); std::cout&amp;lt;&amp;lt;head-&amp;gt;data&amp;lt;&amp;lt;&amp;#34;\t&amp;#34;; } } 非递归算法是借助栈的后进先出的特性，首先遍历链表的所有元素，并将它们存入到栈中。当遍历完栈的时候就可以出栈：
void nonRecPrintLinkedList(LinkedNode *head) { if(head != nullptr) { stack&amp;lt;LinkedNode*&amp;gt; st; LinkedNode * cur = head; while(cur != nullptr) { st.push(cur); cur = cur-&amp;gt;next; } while(!st.empty()) { cur = st.top(); st.pop(); std::cout&amp;lt;&amp;lt;cur-&amp;gt;data&amp;lt;&amp;lt;&amp;#39;\t&amp;#39;; } } }  两个栈实现队列 将stack1作为入队使用， 将stack2作为出队使用。当stack2不空时，就从stack2直接弹出元素，否则将stack1里元素先全部弹出到stack2中，再从stack2中弹出，这样便实现了先进先出。
template &amp;lt;typename T&amp;gt; class stackQueue { public: stackQueue(void){}; ~stackQueue(){}; void push(const T &amp;amp;node); void pop(); T &amp;amp;top(); private: stack&amp;lt;T&amp;gt; stack1; stack&amp;lt;T&amp;gt; stack2; }; template &amp;lt;typename T&amp;gt; void stackQueue&amp;lt;T&amp;gt;::push(const T &amp;amp;node) { stack1.push(node); } template &amp;lt;typename T&amp;gt; void stackQueue&amp;lt;T&amp;gt;::pop() { if (stack2.empty()) { while (!stack1.empty()) { stack2.push(stack1.top()); stack1.pop(); } } if (stack2.empty()) throw string(&amp;#34;queue is empty!&amp;#34;); stack2.pop(); } template &amp;lt;typename T&amp;gt; T &amp;amp;stackQueue&amp;lt;T&amp;gt;::top() { return stack2.top(); }  两个队列实现一个栈 总是保持一个队列是空，出栈的时候将不空的那个队列的前$n-1$个元素都放到空的那个队列里，然后出剩下的那一个元素；入队的时候入到不空的那个队列里。
template &amp;lt;typename T&amp;gt; class queueStack { public: queueStack(void){}; ~queueStack(){}; void push(const T &amp;amp; node); T pop(); private: queue&amp;lt;T&amp;gt; queue1; queue&amp;lt;T&amp;gt; queue2; }; template &amp;lt;typename T&amp;gt;void queueStack&amp;lt;T&amp;gt;::push(const T &amp;amp;node) { if(queue1.empty() &amp;amp;&amp;amp; queue2.empty()) { queue1.push(node); } else if(queue1.empty()) { queue1.push(node); } else if(queue2.empty()) { queue2.push(node); } else throw string(&amp;#34;Error!&amp;#34;); } template &amp;lt;typename T&amp;gt;T queueStack&amp;lt;T&amp;gt;::pop() { if(!queue1.empty() &amp;amp;&amp;amp; queue2.empty()) { while(queue1.size() != 1) { queue2.push(queue1.front()); queue1.pop(); } T &amp;amp; data = queue1.front(); queue1.pop(); return data; } else if(queue1.empty() &amp;amp;&amp;amp; !queue2.empty()) { while(queue2.size() != 1) { queue1.push(queue2.front()); queue2.pop(); } T &amp;amp; data = queue2.front(); queue2.pop(); return data; } else throw string(&amp;#34;Error!&amp;#34;); }  快速排序 快速排序中，基准元素的选择有3种方式：①选择待排序区间左边的第一个元素。②选择待排序空间的中间元素。③随机从待排序区间中选择一个元素。下面的代码是随机选择基准元素：
int quickSortPartition(int *input, int length, int start, int end) { if (input == nullptr || start &amp;lt; 0 || length &amp;lt;= 0 || end &amp;gt;= length) { return -1; // 参数错误  } srand(time(NULL)); //C风格  int index = rand() % (end - start &#43; 1); int small = start - 1; swap(input[index], input[end]); for (int i = start; i &amp;lt; end; &#43;&#43;i) { if (input[i] &amp;lt; input[end]) { small&#43;&#43;; if (small &amp;lt; i) { swap(input[small], input[i]); } } } small&#43;&#43;; swap(input[small], input[end]); return small; } void quickSortMore(int *input, int length, int start, int end) { if (start == end) return; int index = quickSortPartition(input,length,start,end); if (index &amp;gt; start) quickSortMore(input,length,start,index-1); if (end &amp;gt; index) quickSortMore(input,length,index&#43;1,end); }  旋转数组中的最小值 把一个数组的最开始的若干元素移动到数组的末尾，称之为数组的旋转。输入一个递增的数组的一个旋转，找到数组中的最小元素。
最简单的方法是从头到尾遍历一遍数组，就可以找到最小的元素，但是这种方法没有用到旋转数组的前部和后部是有序这一特点。
int findSpinArrayMin(int *data, int length) { if (data == nullptr || length &amp;lt; 0) return -1; int start = 0; int end = length - 1; int mid, result = -1; while (data[start] &amp;gt;= data[end]) { if (end - start == 1) { mid = end; break; } mid = (start &#43; end) / 2; if (data[start] == data[mid] &amp;amp;&amp;amp; data[mid] == data[end]) { return minInOrder(data, start, end); } if (data[mid] &amp;gt;= data[end]) start = mid; else if (data[mid] &amp;lt;= data[end]) end = mid; } return data[mid]; } int minInOrder(int *data, int start, int end) { int result = data[start]; for (int i = start &#43; 1; i &amp;lt;= end; &#43;&#43;i) { if (result &amp;gt; data[i]) result = data[i]; } return result; }  斐波那契数列 首先根据定义很容易想到递归算法，但是递归算法会重复计算很多次，所以实际上浪费了很多资源
long long recFibonacci(unsigned int n) { if (n &amp;lt;= 1) return n; else return recFibonacci(n - 1) &#43; recFibonacci(n - 2); } 使用非递归解法，不必重复计算
long long nonRecFibonacci(unsigned int n) { if (n &amp;lt;= 1) return n; long long first = 0, second = 1, result = 0; for (int i = 2; i &amp;lt;= n; i&#43;&#43;) { result = first &#43; second; first = second; second = result; } return result; }  数组的整数次方 实现函数double power(double base,int exponent),求 base的expoent次方，不使用库函数，同时不考虑大数问题。但是在这个问题上需要考虑base接近于0的情况。
double power(double base, int exponent) { double result = 1.0; unsigned int absExponent = (unsigned int) (exponent); if (base &amp;gt; 0.000001 &amp;amp;&amp;amp; base &amp;lt; 0.000001 &amp;amp;&amp;amp; exponent &amp;lt; 0) return 0; if (exponent &amp;lt; 0) { absExponent = (unsigned int) (-exponent); } for (unsigned int i = 0; i &amp;lt; absExponent; &#43;&#43;i) { result *= base; } if (exponent &amp;lt; 0) result = 1.0 / result; return result; } 优化的方法，使用如下方法
![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-08-17 下午2.42.37.png)
double powerOptimize(double base, int exponent) { if (exponent == 0) return 1; if (exponent == 1) return base; double result = powerOptimize(base, exponent &amp;gt;&amp;gt; 1); result *= result; if ((exponent &amp;amp; 0x1) == 1) result *= base; return result; }  打印1到最大的n位数 输入数字 n，打印1到最大的 n 位十进制数
void printNdigits(unsigned int n) { auto *digits = new char[n &#43; 1]; memset(digits, &amp;#39;0&amp;#39;, (n &#43; 1) * sizeof(char)); digits[n] = &amp;#39;\0&amp;#39;; while (!incrementByone(digits)) { printNumber(digits); } delete[] digits; } bool incrementByone(char *digits) { int length = strlen(digits); bool isOverFlow = false; int takeOver = 0; int cur = 0; for (auto i = length-1; i &amp;gt;= 0; --i) { cur = digits[i]-&amp;#39;0&amp;#39;&#43;takeOver; if( i==length-1) cur &#43;&#43;; if(cur &amp;gt; 10) { if(i == 0) isOverFlow = true; else { cur -= 10; digits[i]=&amp;#39;0&amp;#39;&#43;cur; takeOver =1; } } else { digits[i]=&amp;#39;0&amp;#39;&#43;cur; break; } } return isOverFlow; } void printNumber(const char *digits) { if (digits != nullptr) { while (*digits == &amp;#39;0&amp;#39;) { digits&#43;&#43;; } cout &amp;lt;&amp;lt; digits &amp;lt;&amp;lt; endl; } } 递归方式，如果将前面的数字补0的话，就会发现n位所有十进制数其实就是n个从0开始到9的全排列，就是把数字从0到9排列一遍，就得到了十进制的全排列。
void newPrintNdigts(unsigned int n) { auto *digits = new char[n &#43; 1]; digits[n] = &amp;#39;\0&amp;#39;; for (int i = 0; i &amp;lt; 10; &#43;&#43;i) { digits[0] =char(i&#43;&amp;#39;0&amp;#39;); recPrintNdigits(digits,n,0); } delete[] digits; } void recPrintNdigits(char *digits, int length, int index) { if(index == length-1) { printNumber(digits); return; } for (int i = 0; i &amp;lt; 10; &#43;&#43;i) { digits[index&#43;1] = char(i&#43;&amp;#39;0&amp;#39;); recPrintNdigits(digits,length,index&#43;1); } }  在O(1)时间内删除节点 在 $O(1)$ 时间复杂度内删除某个节点,假设要删除的节点一定在链表中。如果删除的不是尾节点，则只要将它的下一个节点的数据移到该节点即可。
void deleteLinkedNode(LinkedNode * &amp;amp;root, LinkedNode * key) { if( root == nullptr || key == nullptr || !isNodeInLinkedList(root, key)) return; if(key-&amp;gt;next != nullptr) //删除的如果不是尾节点  { LinkedNode * next = key-&amp;gt;next; key-&amp;gt;data = next-&amp;gt;data; key-&amp;gt;next = next-&amp;gt;next; delete next; next = nullptr; } else if( root-&amp;gt;next == nullptr) //删除的是尾节点，而且链表只有一个节点  { delete root; root = nullptr; } else //删除的是尾节点，且链表不止一个节点  { LinkedNode * pre = root; LinkedNode * cur = root-&amp;gt;next; while(cur != nullptr ) { pre = cur; cur = cur-&amp;gt;next; } pre-&amp;gt;next = nullptr; delete cur; cur = nullptr; } }  链表中的倒数第 k 个节点 输入一个链表，输出该链表中的倒数第 k 个节点，其中链表的尾节点为倒数第1个节点
基本思路是用两个指针，其中第一个游标先向前走 k-1次，然后和另外一个游标一起往前走，如果第一个游标走到尾节点，那么第二个游标也就到了倒数第 k个节点。
LinkedNode *findLastKthNodeFaster(LinkedNode *root, int k) { if( root == nullptr || k &amp;lt;= 0) return nullptr; LinkedNode * cur = root; LinkedNode * result = root; for (int i = 0; i &amp;lt; k-1; &#43;&#43;i) { if (cur-&amp;gt;next != nullptr) //要考虑k的值是否超过了链表的总节点数目  cur = cur-&amp;gt;next; else return nullptr; } while (cur != nullptr) { cur = cur-&amp;gt;next; result = result-&amp;gt;next; } return result; }  反转链表 定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头结点。分为递归和非递归解法，非递归使用头插法即可
LinkedNode * reverseLinkedList(LinkedNode *pHead) { if (pHead == nullptr) return nullptr; LinkedNode *newHead = pHead; LinkedNode *cur = pHead-&amp;gt;next; newHead-&amp;gt;next = nullptr; LinkedNode *next = nullptr; while (cur != nullptr) { next = cur-&amp;gt;next; cur-&amp;gt;next = newHead; newHead = cur; cur = next; } return newHead; } 递归解法
LinkedNode *recurReversionLinkedList(LinkedNode *head) { LinkedNode *cur = nullptr; LinkedNode *tmp = nullptr; LinkedNode *recurHead = nullptr; if(head == nullptr) { return nullptr; } if(head-&amp;gt;next == nullptr) return head; else { cur = head; tmp = head-&amp;gt;next; recurHead = recurReversionLinkedList(tmp); //得到反转之后的头节点  tmp-&amp;gt;next = cur; //此时tmp就是最后一个节点了,应该将cur放到此时的最后一个节点tmp的后面  cur-&amp;gt;next = nullptr; return recurHead; } }  压缩字符串 给定一段字符串，仅压缩连续重复出现的字符，例如字符串abcbc压缩后为1a1b1c，xxxyyyyzz压缩后为3x4y2z
void compressString(const char *src) { assert(src != nullptr); auto length = strlen(src); auto *result = new char[2 * length &#43; 1]; //当字符都不相同时，压缩后的字符串长度变为原来的2倍  int i = 0, j = 0, k = 0; char cur; while (src[i] != &amp;#39;\0&amp;#39;) { cur = src[i]; j = i &#43; 1; while (src[j] == cur) { j&#43;&#43;; } result[k&#43;&#43;] = (char) (j - i &#43; &amp;#39;0&amp;#39;); result[k&#43;&#43;] = cur; i = j; } result[k] = &amp;#39;\0&amp;#39;; cout &amp;lt;&amp;lt; result &amp;lt;&amp;lt; endl; delete[] result; }  删除多余空格 在不开辟额外空间的情况下删除开始和结尾处的空格，并将中间的多个连续的空格合成一个。
void deleteSpaces2(char *str) { auto length = strlen(str); auto i = length - 1; int j =0; while (str[i] == &amp;#39;&amp;#39;) i--; str[i&#43;1] = &amp;#39;\0&amp;#39;; i = 0; while (str[i] == &amp;#39;&amp;#39;) i&#43;&#43;; while(str[i] != &amp;#39;\0&amp;#39;) { str[j&#43;&#43;] = str[i&#43;&#43;]; if(str[i] == &amp;#39;&amp;#39;) { while(str[i] == &amp;#39;&amp;#39;) i&#43;&#43;; str[j&#43;&#43;] = &amp;#39;&amp;#39;; } } str[j] = &amp;#39;\0&amp;#39;; cout&amp;lt;&amp;lt;&amp;#34;***&amp;#34;&amp;lt;&amp;lt;str&amp;lt;&amp;lt;&amp;#34;***&amp;#34;&amp;lt;&amp;lt;endl; }  合并两个有序的链表 当得到两个链表中值较小的头节点并把它链接到已经合并的链表之后，两个链表剩余的节点依然是有序的，因此合并的步骤和之前的步骤一样。
LinkedNode *mergeOrderLinkedList(LinkedNode *head1, LinkedNode *head2) { if (head1 == nullptr) return head2; else if (head2 == nullptr) return head1; LinkedNode *mergeHead = nullptr; if (head1-&amp;gt;data &amp;lt;= head2-&amp;gt;data) { mergeHead = head1; mergeHead-&amp;gt;next = mergeOrderLinkedList(head1-&amp;gt;next, head2); } else { mergeHead = head2; mergeHead-&amp;gt;next = mergeOrderLinkedList(head1, head2-&amp;gt;next); } return mergeHead; }  树的子结构 输入两棵二叉树 A 和 B，判断 B 是不是 A 的子树
bool hasSubTree(BinTreeNode *root1, BinTreeNode *root2) { bool result = false; if(root1 != nullptr &amp;amp;&amp;amp; root2 != nullptr ) { if(root1-&amp;gt;data == root2-&amp;gt;data) result = DoesTree1HasTree2(root1,root2); if(false == result) { result = hasSubTree(root1-&amp;gt;leftChild,root2); } if(false == result) { result = hasSubTree(root1-&amp;gt;rightChild,root2); } } return result; } bool DoesTree1HasTree2(BinTreeNode *root1, BinTreeNode *root2) { if(root2 == nullptr) return true; else if(root1 == nullptr) return false; if(root1-&amp;gt;data != root2-&amp;gt;data) return false; return DoesTree1HasTree2(root1-&amp;gt;rightChild,root2-&amp;gt;leftChild) &amp;amp;&amp;amp; DoesTree1HasTree2(root1-&amp;gt;rightChild,root2-&amp;gt;rightChild); }  树的镜像 先前序遍历这棵树的每一个节点，如果遍历到的节点有子节点则交换它们，当交换完所有的非叶子节点的左右子节点之后，就得到了树的镜像
void changeToMirror(BinTreeNode *root) { if (root == nullptr) return; if (root-&amp;gt;leftChild == nullptr &amp;amp;&amp;amp; root-&amp;gt;rightChild == nullptr) return; BinTreeNode *tmp; tmp = root-&amp;gt;leftChild; root-&amp;gt;leftChild = root-&amp;gt;rightChild; root-&amp;gt;rightChild = tmp; if(nullptr != root-&amp;gt;leftChild) changeToMirror(root-&amp;gt;leftChild); if(nullptr != root-&amp;gt;rightChild) changeToMirror(root-&amp;gt;rightChild); }  顺时针打印矩阵 void clockwisePrintMatrix(int **input, int columns, int rows) { if (input == nullptr || columns &amp;lt; 0) return; int start = 0; while (columns &amp;gt; start * 2 &amp;amp;&amp;amp; rows &amp;gt; start * 2) //打印进行的条件  { printMatrixInCircle(input, columns, rows, start); start&#43;&#43;; } } void printMatrixInCircle(int **input, int rows, int columns, int start) { int endX = columns - 1 - start; //记录行的最右边  int endY = rows - 1 - start; //记录列的最下边  //从左往右打印一行  for (int i = start; i &amp;lt;= endX ; &#43;&#43;i) { cout&amp;lt;&amp;lt;input[start][i]&amp;lt;&amp;lt;&amp;#34;\t&amp;#34;; } //从上往下打印一列  for (int i = start&#43;1; i&amp;lt;= endY; &#43;&#43;i) { cout&amp;lt;&amp;lt;input[i][endX]&amp;lt;&amp;lt;&amp;#34;\t&amp;#34;; } for (int i = endX-1; i &amp;gt;=start ; --i) { cout&amp;lt;&amp;lt;input[endY][i]&amp;lt;&amp;lt;&amp;#34;\t&amp;#34;; } for (int i = endY-1; i &amp;gt; start ; --i) { cout&amp;lt;&amp;lt;input[i][start]&amp;lt;&amp;lt;&amp;#34;\t&amp;#34;; } cout&amp;lt;&amp;lt;endl; }  包含min函数的栈 定义栈的数据结构，在该类型中实现一个能够得到栈的最小元素的min函数。
利用一个辅助栈，每次将最小的元素（当前最小和入栈压入的新元素比较）都保存在这个辅助栈中。当弹出元素时，辅助栈中的元素也弹出一个。
 判断正确的出栈序列 输入两个整数序列，第一个表示栈的压入顺序，第二个表示弹出序列，判断弹出序列是否是第一个压入序列的有效弹出序列。
使用一个辅助栈来保存压入序列，如果下一个弹出的数字刚好是栈顶数字，那么直接弹出，如果下一个弹出的数字不在栈顶，则把压栈序列中还未压入的数字压入到栈中，直到把下一个需要弹出的数字压入到栈顶为止，如果所有数字都压入到栈中了还未找到下一个弹出的数字，那么该序列就不是合法的弹出序列。
下面这个是针对与栈中元素是整型变量的：
bool isPopOrder(const int *pushOrder, const int *popOrder, int length) { bool result = false; const int *nextPush = pushOrder; const int *nextPop = popOrder; stack&amp;lt;int&amp;gt; st; if (pushOrder != nullptr &amp;amp;&amp;amp; popOrder != nullptr &amp;amp;&amp;amp; length &amp;gt; 0) { while ((nextPop - popOrder) &amp;lt; length) { while (st.empty() || *nextPop != st.top()) { if ((nextPush - pushOrder) == length) break; st.push(*nextPush); nextPush&#43;&#43;; } if (st.top() != *nextPush) break; nextPop&#43;&#43;; st.pop(); } if (st.empty() &amp;amp;&amp;amp; (nextPop - popOrder == length)) result = true; } return result; } 这个是针对于栈中元素是字符型
bool isPopOrder(const char *pushOrder, const char *popOrder) { bool result = false; auto length = strlen(pushOrder); if(popOrder != nullptr &amp;amp;&amp;amp; pushOrder != nullptr &amp;amp;&amp;amp; length == strlen(popOrder)) { stack&amp;lt;char&amp;gt; st; const char * nextPush = pushOrder; const char * nextPop = popOrder; while(*nextPop != &amp;#39;\0&amp;#39;) { while(st.empty() || *nextPop != st.top()) { if(*nextPush == &amp;#39;\0&amp;#39;) break; st.push(*nextPush); nextPush&#43;&#43;; } if(*nextPop != st.top()) break; nextPop&#43;&#43;; st.pop(); } if(st.empty() &amp;amp;&amp;amp; *nextPop == &amp;#39;\0&amp;#39;) result = true; } return result; }  二叉搜索树的后序遍历序列 输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果，如果是则返回true，不是则返回false
bool verifySquenceOfBST(int *input, int length) { bool result = false; if (input == nullptr || length &amp;lt;= 0) return result; int cur = input[length - 1]; //根节点  int index = 0; int mid = 0; while (index &amp;lt; length &amp;amp;&amp;amp; input[index] &amp;lt; cur) { index&#43;&#43;; } mid = index; while (index &amp;lt; length &amp;amp;&amp;amp; input[index] &amp;gt; cur) { index&#43;&#43;; } if (index == length - 1) //注意边界判断  { bool left = false, right = false; if (mid &amp;gt; 0) left = verifySquenceOfBST(input, mid); if (mid &amp;lt; length - 1) right = verifySquenceOfBST(input &#43; mid, length - mid - 1); result = left &amp;amp;&amp;amp; right; } return result; }  二叉树中从根开始和为某一值的路径 输入一棵二叉树和一个整数，打印二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到某一节点所经过的节点形成一条路径。
void findPath(BinTreeNode *root, int sum) { if (root == nullptr) return; vector&amp;lt;char&amp;gt; path; int currentSum = 0; findPath(root, path, sum, currentSum); } void findPath(BinTreeNode *root, vector&amp;lt;char&amp;gt; &amp;amp;path, int sum, int currentsum) { currentsum &#43;= root-&amp;gt;data; path.push_back(root-&amp;gt;data); if (sum == currentsum) { for (auto it = path.begin(); it != path.end(); it&#43;&#43;) { cout &amp;lt;&amp;lt; *it &amp;lt;&amp;lt; &amp;#39;\t&amp;#39;; } cout &amp;lt;&amp;lt; endl; } if (root-&amp;gt;leftChild != nullptr) { findPath(root-&amp;gt;leftChild, path, currentsum, sum); } if (root-&amp;gt;rightChild != nullptr) { findPath(root-&amp;gt;rightChild, path, currentsum, sum); } path.pop_back(); } 不用vector算法的写法：
void printSumPath(BinTreeNode *root, char *path, int length, int sum) { if (root == nullptr) return; path[length] = root-&amp;gt;data; sum -= root-&amp;gt;data; length&#43;&#43;; if (0 == sum) { for (int i = 0; i &amp;lt;= length; &#43;&#43;i) { cout &amp;lt;&amp;lt; path[i]; } cout &amp;lt;&amp;lt; endl; } if (root-&amp;gt;leftChild != nullptr) { printSumPath(root-&amp;gt;leftChild, path, length, sum); } if (root-&amp;gt;rightChild != nullptr) { printSumPath(root-&amp;gt;rightChild, path, length, sum); } length--; //减不减其实无所谓 }  二叉树中和为某一值的路径 一棵二叉树每个节点包含一个整数，设计一个算法输出所有满足条件的路径：在此路径上所有给定的节点之和为给定值，不必从根节点开始void printSumPath(BinTreeNode *root, vector&amp;lt;char&amp;gt; &amp;amp;path, int sum, int level) { if(root != nullptr) { path.push_back(root-&amp;gt;data); int currentSum = sum; for (int i = level; i &amp;gt;=0; &#43;&#43;i) { currentSum-=path[i]; if(currentSum == 0) printSumPath(path,i,level); } level&#43;&#43;; if(root-&amp;gt;leftChild != nullptr) printSumPath(root-&amp;gt;leftChild,path,sum,level); if(root-&amp;gt;rightChild != nullptr) printSumPath(root-&amp;gt;rightChild,path,sum,level); path.pop_back(); } } void printSumPath(vector&amp;lt;char&amp;gt; path, int start, int end) { for (int i = start; i &amp;lt;= end; &#43;&#43;i) { cout&amp;lt;&amp;lt;path[i]&amp;lt;&amp;lt;&amp;#39;\t&amp;#39;; } cout&amp;lt;&amp;lt;endl; }  </content>
    </entry>
    
     <entry>
        <title>C&#43;&#43;智能指针</title>
        <url>https://iihui.github.io/post/cpp-smart-pointer/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>C&#43;&#43;</tag>
        </tags>
        <content type="html">  智能指针是一个类，它对普通指针进行封装，使智能指针类对象具有普通指针类型一样的操作。具体而言，复制对象时，副本和原对象都指向同一存储区域，如果通过一个副本改变其所指的值，则通过另一对象访问的值也会改变。与普通指针所不同的是，智能指针能够对内存进行进行自动管理，避免出现悬垂指针等情况。
 普通指针 对于普通指针，当有多个指针指向同一个基础对象时，如果某个指针delete了该基础对象，对这个指针来说已经明确说明它所指的对象被释放掉了，所以它不会再对所指对象进行操作。但是，对于剩下的指向同一个基础对象的指针来说，它们依然指向已经被删除的基础对象并随时准备对它进行操作，于是悬垂指针就形成了。
int * ptr1 = new int (1); int * ptr2 = ptr1; int * ptr3 = prt2; cout &amp;lt;&amp;lt; *ptr1 &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; *ptr2 &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; *ptr3 &amp;lt;&amp;lt; endl; delete ptr1; cout &amp;lt;&amp;lt; *ptr2 &amp;lt;&amp;lt; endl; ![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-08-13 下午4.12.02.png)
![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-08-13 下午4.12.12.png)
![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-08-13 下午4.12.32.png)
从图可以看出，错误的产生来自于ptr1的“无知”：它并不知道还有其他指针共享着它指向的对象。如果有个办法让ptr1知道，除了它自己外还有两个指针指向基础对象，而它不应该删除基础对象，那么悬垂指针的问题就得以解决了。
![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-08-13 下午4.14.30.png)
 引用计数 如何来让指针知道还有其他指针的存在呢？这个时候该引入引用计数的概念了。引用计数是这样一个技巧，它允许有多个相同值的对象共享这个值的实现。引用计数的使用常有两个目的：
  一旦一个对象通过调用new被分配出来，记录谁拥有这个对象是很重要的，因为其所有者要负责对它进行delete。但是对象所有者可以有多个，且所有权能够被传递，这就使得内存跟踪变得困难。引用计数可以跟踪对象所有权，并能够自动销毁对象。可以说引用计数是个简单的垃圾回收体系。
  节省内存，提高程序运行效率。如果很多对象有相同的值，为这多个相同的值存储多个副本是很浪费空间的，所以最好做法是让左右对象都共享同一个值的实现。C&#43;&#43;标准库中string类采取一种称为“写时复制”的技术，使得只有当字符串被修改的时候才创建各自的拷贝，否则可能（标准库允许使用但没强制要求）采用引用计数技术来管理共享对象的多个对象。
   智能指针实现 智能指针的实现策略有两种：辅助类与句柄类，这里介绍辅助类实现
基础类 class Point { public: Point(int xVal = 0, int yVal = 0) :x(xVal), y(yVal) { } int getX() const { return x; } int getY() const { return y; } void setX(int xVal) { x = xVal; } void setY(int yVal) { y = yVal; } private: int x, y; };  辅助类 在创建智能指针类之前，我们先创建一个辅助类。这个类的所有成员皆为私有类型，因为它不被普通用户所使用。为了只为智能指针使用，还需要把智能指针类声明为辅助类的友元。这个辅助类含有两个数据成员：计数count与基础对象指针。也即辅助类用以封装使用计数与基础对象指针。
class U_Ptr { private: friend class SmartPtr; U_Ptr(Point *ptr) :p(ptr), count(1) { } ~U_Ptr() { delete p; } int count; Point *p; };  智能指针类 引用计数是实现智能指针的一种通用方法。智能指针将一个计数器与类指向的对象相关联，引用计数跟踪共有多少个类对象共享同一指针。它的具体做法如下：
  当创建类的新对象时，初始化指针，并将引用计数设置为1
  当对象作为另一个对象的副本时，复制构造函数复制副本指针，并增加与指针相应的引用计数（加1）
  使用赋值操作符对一个对象进行赋值时，处理复杂一点：先使左操作数的指针的引用计数减1（因为指针已经指向别的地方），如果减1后引用计数为0，则释放指针所指对象内存。然后增加右操作数所指对象的引用计数（为何增加：因为此时做操作数指向对象即右操作数指向对象）。
  析构函数：调用析构函数时，析构函数先使引用计数减1，如果减至0则delete对象。
  class SmartPtr { public: SmartPtr(Point *ptr) : rp(new U_Ptr(ptr)) {} SmartPtr(const SmartPtr &amp;amp;sp) : rp(sp.rp) { &#43;&#43;rp-&amp;gt;count; } SmartPtr &amp;amp;operator=(const SmartPtr &amp;amp;rhs) { &#43;&#43;rhs.rp-&amp;gt;count; if (--rp-&amp;gt;count == 0) delete rp; rp = rhs.rp; return *this; } ~SmartPtr() { if (--rp-&amp;gt;count == 0) delete rp; else cout &amp;lt;&amp;lt; &amp;#34;还有&amp;#34; &amp;lt;&amp;lt; rp-&amp;gt;count &amp;lt;&amp;lt; &amp;#34;个指针指向基础对象&amp;#34; &amp;lt;&amp;lt; endl; } private: U_Ptr *rp; };  使用与测试 int main() { Point *pa = new Point(10, 20); //定义一个基础对象类指针  //定义三个智能指针类对象，对象都指向基础类对象pa  //使用花括号控制三个指针指针的生命期，观察计数的变化  { SmartPtr sptr1(pa); //此时计数count=1  { SmartPtr sptr2(sptr1); //调用复制构造函数，此时计数为count=2  { SmartPtr sptr3 = sptr1; //调用赋值操作符，此时计数为conut=3  } //此时count=2  } //此时count=1；  } //此时count=0；pa对象被delete掉  cout &amp;lt;&amp;lt; pa-&amp;gt;getX() &amp;lt;&amp;lt; endl; return 0; }  改进一 虽然此时的SmartPtr类称为智能指针，但它目前并不能像真正的指针那样有-&amp;gt;、*等操作符，为了使它看起来更像一个指针，我们来为它重载这些操作符。代码如下所示：
class SmartPtr { public: SmartPtr(Point *ptr) :rp(new U_Ptr(ptr)) { } SmartPtr(const SmartPtr &amp;amp;sp) :rp(sp.rp) { &#43;&#43;rp-&amp;gt;count; } SmartPtr&amp;amp; operator=(const SmartPtr&amp;amp; rhs) { &#43;&#43;rhs.rp-&amp;gt;count; if (--rp-&amp;gt;count == 0) delete rp; rp = rhs.rp; return *this; } ~SmartPtr() { if (--rp-&amp;gt;count == 0) delete rp; else cout &amp;lt;&amp;lt; &amp;#34;还有&amp;#34; &amp;lt;&amp;lt; rp-&amp;gt;count &amp;lt;&amp;lt; &amp;#34;个指针指向基础对象&amp;#34; &amp;lt;&amp;lt; endl; } Point &amp;amp; operator *() //重载*操作符  { return *(rp-&amp;gt;p); } Point* operator -&amp;gt;() //重载-&amp;gt;操作符  { return rp-&amp;gt;p; } private: U_Ptr *rp; };  改进二 目前这个智能指针智能用于管理Point类的基础对象，如果此时定义了个矩阵的基础对象类，那不是还得重新写一个属于矩阵类的智能指针类吗？但是矩阵类的智能指针类设计思想和Point类一样啊，就不能借用吗？答案当然是能，那就是使用模板技术。
//模板类作为友元时要先有声明 template &amp;lt;typename T&amp;gt; class SmartPtr; template &amp;lt;typename T&amp;gt; class U_Ptr //辅助类 { private: //该类成员访问权限全部为private，因为不想让用户直接使用该类  friend class SmartPtr&amp;lt; T&amp;gt;; //定义智能指针类为友元，因为智能指针类需要直接操纵辅助类  //构造函数的参数为基础对象的指针  U_Ptr(T *ptr) : p(ptr), count(1) {} //析构函数  ~U_Ptr() { delete p; } //引用计数  int count; //基础对象指针  T *p; }; template &amp;lt;typename T&amp;gt; class SmartPtr //智能指针类 { public: SmartPtr(T *ptr) : rp(new U_Ptr&amp;lt;T&amp;gt;(ptr)) {} //构造函数  SmartPtr(const SmartPtr&amp;lt;T&amp;gt; &amp;amp;sp) : rp(sp.rp) { &#43;&#43;rp-&amp;gt;count; } //复制构造函数  SmartPtr &amp;amp;operator=(const SmartPtr&amp;lt;T&amp;gt; &amp;amp;rhs) { //重载赋值操作符  &#43;&#43;rhs.rp-&amp;gt;count; //首先将右操作数引用计数加1，  if (--rp-&amp;gt;count == 0) //然后将引用计数减1，可以应对自赋值  delete rp; rp = rhs.rp; return *this; } T &amp;amp;operator*() //重载*操作符  { return *(rp-&amp;gt;p); } T *operator-&amp;gt;() //重载-&amp;gt;操作符  { return rp-&amp;gt;p; } ~SmartPtr() { //析构函数  if (--rp-&amp;gt;count == 0) //当引用计数减为0时，删除辅助类对象指针，从而删除基础对象  delete rp; else cout &amp;lt;&amp;lt; &amp;#34;还有&amp;#34; &amp;lt;&amp;lt; rp-&amp;gt;count &amp;lt;&amp;lt; &amp;#34;个指针指向基础对象&amp;#34; &amp;lt;&amp;lt; endl; } private: U_Ptr&amp;lt;T&amp;gt; *rp; //辅助类对象指针 };  </content>
    </entry>
    
     <entry>
        <title>Go 中映射(字典）</title>
        <url>https://iihui.github.io/post/go-map/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>Go</tag>
        </tags>
        <content type="html">  映射(或称为字典)是一种数据结构，用于存储一系列无序的键值对，它是基于键来存储值。映射的键可以是任何值，只要这个值可以使用==运算符做比较即可。切片、函数以及包含切片的结构类型这些类型由于具有引用语义， 不能作为映射的键。
  创建和初始化 使用make函数 //创建一个映射，键的类型是 string，值的类型是 int dict1 := make(map[string]int) dict2 := make(map[string]int,5) //长度为5  使用字面量 // 创建一个映射，键和值的类型都是 string，使用两个键值对初始化映射 dict2 := map[string]string{&amp;#34;Red&amp;#34;: &amp;#34;#da1337&amp;#34;, &amp;#34;Orange&amp;#34;: &amp;#34;#e95a22&amp;#34;} 需要注意的是，直接使用var m map[string][int]这种方式定义的map变量的初始值为nil,并且这个变量是只能读不能写的，也就是说可以按照键来读值，读出来是类型的默认零值，但是不可以往里面添加键值对，否则会产生一个运行时错误。
// 通过声明映射创建一个 nil 映射 var colors map[string]string // 将 Red 的代码加入到映射 colors[&amp;#34;Red&amp;#34;] = &amp;#34;#da1337&amp;#34; //产生运行时错误  //Runtime Error: //panic: runtime error: assignment to entry in nil map 相比于值为nil的映射，空映射有初始化过程，但是映射此时的容量为0，此时的映射是可以用来存储键值对的：
// 创建一个空映射，用来存储颜色以及颜色对应的十六进制代码 colors := map[string]string{} //空映射 // 将 Red 的代码加入到映射 colors[&amp;#34;Red&amp;#34;] = &amp;#34;#da1337&amp;#34; 内容为空的映射与nil是不同的，空映射可以添加键值，nil字典不可以添加键值：
var m1 map[string]int //nil映射 m2 := map[string]int{} //空映射  println(m1==nil,m2==nil)//true false  使用映射 映射的使用包括：①根据键来取值——通常要通过ok-idiom模式来判断给定的键是否有值； ②作为函数参数——因为是引用类型，因此函数中做的更改可以影响被调函数中原引用的值。
根据键取值 value, exists := colors[&amp;#34;Blue&amp;#34;] // 这个键存在吗？，这就是ok-idiom模式  if exists { fmt.Println(value) } // 创建一个映射，存储颜色以及颜色对应的十六进制代码 colors := map[string]string{ &amp;#34;AliceBlue&amp;#34;: &amp;#34;#f0f8ff&amp;#34;, &amp;#34;Coral&amp;#34;: &amp;#34;#ff7F50&amp;#34;, &amp;#34;DarkGray&amp;#34;: &amp;#34;#a9a9a9&amp;#34;, &amp;#34;ForestGreen&amp;#34;: &amp;#34;#228b22&amp;#34;, } // 显示映射里的所有颜色 for key, value := range colors { fmt.Printf(&amp;#34;Key: %s Value: %s\n&amp;#34;, key, value) } 作为函数参数 因为映射是引用类型，在函数间传递映射并不会制造出该映射的一个副本。实际上，当传递映射给一个函数，并对这个映射做了修改时，所有对这个映射的引用都会察觉到这个修改。
colors := map[string]string{ &amp;#34;AliceBlue&amp;#34;:&amp;#34;#f0f8ff&amp;#34;, &amp;#34;Coral&amp;#34;:&amp;#34;#ff7F50&amp;#34;, &amp;#34;DarkGray&amp;#34;:&amp;#34;#a9a9a9&amp;#34;, &amp;#34;ForestGreen&amp;#34;: &amp;#34;#228b22&amp;#34;, } // 显示映射里的所有颜色 for key, value := range colors { fmt.Printf(&amp;#34;Key: %s Value: %s\n&amp;#34;, key, value) } // 调用函数来移除指定的键 removeColor(colors, &amp;#34;Coral&amp;#34;) // 显示映射里的所有颜色  for key, value := range colors { fmt.Printf(&amp;#34;Key: %s Value: %s\n&amp;#34;, key, value) } func removeColor(colors map[string]string, key string) { delete(colors, key) }  注意事项 字典map是无序的，每次打印出来的结果都会不一样，不能通过index获取（下标获取）只能通过key获取字典要求key必须支持相等运算符==,!=的数据类型，所以切片以及包含切片的结构体不能为key。键的值，可以是数字、字符串、指针、数组、结构体以及接口类型。
内置的len函数返回key的数量，不可以使用cap（即cap不接受字典类型，因为它没有容量的概念）。
map的初始化可以通过key:val的方式初始化：
rating := map[string]float32{&amp;#34;C&amp;#34;: 5, &amp;#34;Go&amp;#34;: 1.83} fmt.Println(rating) //map[C:5 Go:1.83] map是一种引用类型，如果两个map同时指向同一个底层，那么一个改变，另一个也改变。
m := make(map[string]string) m[&amp;#34;Hello&amp;#34;] = &amp;#34;hello&amp;#34; m1 := m m1[&amp;#34;Hello&amp;#34;] = &amp;#34;world&amp;#34; fmt.Println(m, m1) //map[Hello:world] map[Hello:world] 访问不存在的键值，默认返回的是value的默认零值，不会引发错误，但推荐使用ok-idiom模式。
m := make(map[string]bool) m[&amp;#34;chen&amp;#34;] = true fmt.Println(m[&amp;#34;xiao&amp;#34;]) //默认零值false 当value是结构体或者数组时，不能直接修改value中的成员，正确的做法是返回整个value，待修改后再设置字典键值，或直接用指针类型。
type user struct { name string age byte } m := map[int]user{ 1: {&amp;#34;Tom&amp;#34;, 19}, } m[1].age = 20 //错误,结构体的value不能直接修改  u := m[1] //先取出来，在改变value的值，然后再根据索引改变map中value的值 u.age = 20 m[1] = u 不能对nil字典进行写操作，但却能读，读出来的value是其类型对应的零值。
println(m[&amp;#34;a&amp;#34;]) m[&amp;#34;a&amp;#34;] = 1 //错误 内容为空的字典与nil是不同的，内容为空的字典可以添加键值，但是nil字典不可以。
var m1 map[string]int m2 := map[string]int{} println(m1 == nil, m2 == nil) //true false 在迭代期间(for range)删除或者新增键值是安全的，但是在运行时会对字典并发操作作出检测，如果某个任务正在对字典进行写操作，那么其他任务就不能对该字典进行并发操作（读，写，删除）否则会导致进程崩溃，即是所谓的线程不安全的。
应该使用make来创建map，永远不要使用new来创建map，因为map是引用类型，需要初始化某些东西，而new是将内存清0。
map中的value可以是任意类型，包括函数：
a6 := map[int]func() int{ 1: func() int { return 1 }, 2: func() int { return 2 }, 3: func() int { return 3 }, } fmt.Println(a6) //map[1:0x10982f0 2:0x1098300 3:0x1098310] map的长度是不固定的，可以根据key-value动态的伸缩，因此不存在固定长度和最大长度「但受内存限制」。如果提前能预估key-value的个数，可以在使用make指定长度，这样可以减少因为动态增长key-value带来的性能消耗问题。m:=make(map[string]int,10)
如果一个key要对应多个value，这时候建议将slice作为value。例如，当要处理unix机器上的所有进程，以父进程（pid为整型变量）作为 key，所有的子进程（以所有子进程的pid组成的切片）作为value。
使用delete(map1, key1)从map中删除键值对，如果key1不存在，该操作不会产生错误。
假设我们想获取一个map类型的切片，我们必须使用两次make函数，第一次分配切片，第二次分配切片中每个map元素。
items := make([]map[int]int, 5) //注意写法 for i := range items { items[i] = make(map[int]int, 1) items[i][1] = 2 } fmt.Printf(&amp;#34;Version A: Value of items: %v\n&amp;#34;, items) map默认是无序的，不管是按照key还是按照value默认都不排序；这与C&#43;&#43;中的map有很大区别。
 </content>
    </entry>
    
     <entry>
        <title>Go 切片</title>
        <url>https://iihui.github.io/post/go-slice/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>Go</tag>
        </tags>
        <content type="html"> 定义 切片是围绕动态数组的概念来构建的，但是本身并非动态数组或数组指针，它通过内部指针引用底层数组，设定相关属性，将数据读写操作限定到指定区域。切片这个名字来自于——创建一个新的切片就是把底层数组切出一部分。
type slice struct{ array unsafe.Pointer // slice中指向底层数组指定位置的的指针  len int // slice 的长度  cap int //slice 容量，即最大长度，就是slice开始位置到数组的最后位置的长度 } ![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-08-03 下午3.38.29.png)
 声明和初始化 使用make 一种创建切片的方法是使用内置的切片的长度，如下所示使用make函数。当使用make时，需要传入一个参数，指定长度：
slice1 := make([]string, 5) //只指定长度，切片的长度和容量相等，均为5 slice2 := make([]int, 3, 5) //分别指定长度和容量，长度为3，容量为5 make在创建切片的时候，可以指定两个长度信息，分别表示切片的当前长度和容量大小「概念参考C&#43;&#43;标准库中的vector。不允许创建容量小于长度的切片，否则会出现编译错误。
 利用字面量 另一种常用的创建切片的方法是使用切片字面量。这种方法和创建数组类似，只是不需要指定[]运算符里的值。初始的长度和容量会基于初始化时提供的元素的个数确定。
// 创建字符串切片，其长度和容量都是 5 个元素 slice1 := []string{&amp;#34;Red&amp;#34;, &amp;#34;Blue&amp;#34;, &amp;#34;Green&amp;#34;, &amp;#34;Yellow&amp;#34;, &amp;#34;Pink&amp;#34;} // 创建一个整型切片，其长度和容量都是 3 个元素 slice2 := []int{10, 20, 30} 如果在 [] 运算符里指定了一个值，那么创建的就是数组而不是切片。
// 创建有 3 个元素的整型数组 array := [3]int{10, 20, 30} // 创建长度和容量都是 3 的整型切片 slice := []int{10, 20, 30} 当使用切片字面量时， 可以设置初始长度和容量，即在就是在初始化时给出所需的长度和容量作为索引：// 创建字符串切片，使用空字符串初始化第 100 个元素 slice := []string{99: &amp;#34;&amp;#34;} //最大的索引是99，因此长度为99&#43;1 fmt.Println(len(slice1),cap(slice1)) //长度为100，容量也为100   从已知切片创建 切片可以从一个数组中获取，前提是这个数组必须是可寻址的。切片通过array[i:j]来获取，表示的区间是[i,j)即前闭后开区间，长度为j-i，对于底层数组容量为k的数组来说，切片slice[i:j]的容量为k-i。
var arr =[10]byte{&amp;#39;a&amp;#39;,&amp;#39;b&amp;#39;,&amp;#39;c&amp;#39;,&amp;#39;d&amp;#39;} //array 声明长度 var a,b []byte //slice，方括号里不声明长度 a = arr[1:3] //前闭后开,长度为2,容量为9 b = arr[2:4] //前闭后开，长度为2，容量为8 fmt.Println(a,b) //[98 99] [99 100] 或者从一个已经存在的的切片中再次声明，即将原切片看成是[cap]slice,据此创建的新切片对象不能超出cap。
// 创建一个整型切片，其长度和容量都是 5 slice := []int{10, 20, 30, 40, 50} // 创建一个新切片，其长度为 2 个元素，容量为 4 newSlice := slice[1:3] ![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-08-03 下午4.41.43.png)
 nil切片 在声明切片时不做任何初始化，就会创建一个nil切片，nil切片无底层数组，因此不可按下标访问。nil切片变为正常的切片有两种方式：①利用赋值。 ②使用append函数。
var slice []int //不做任何初始化，创建的为nil切片 fmt.Println(slice==nil) //true ![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-08-03 下午4.27.26.png)
 空切片 空切片相对于nil切片而言，已经完成了初始化——即其内部指针已经被赋值为非0，而nil切片内部的指针为nil。但是，空切片的len(s)和cap(s)的值都为0。
// 使用 make 创建空的整型切片 slice1 := make([]int, 0) //空切片 // 使用切片字面量创建空的整型切片 slice2 := []int{} //nil切片 fmt.Println(slice1==nil,slice2==nil)//false false ![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-08-03 下午4.29.26.png)
 注意 切片是引用类型 切片是引用类型，所以当引用改变其中元素的值时，其他所有引用都会改变该值：
var arr =[10]byte{81,82,83,84,85,86} //array var a,b,c [] byte //nil slice  a = arr[1:3] b = arr[2:4] fmt.Println(a,b) //[98 99] [99 100]  c = a[0:2] //c切片来自于切片a，切片a发生变化时，c就会跟着变化 fmt.Println(c) //[82,83]  a = arr[1:5] fmt.Println(a,c) //[82 83 84 85] [82 83]  slice := []int{10, 20, 30, 40, 50} newSlice := slice[1:3] fmt.Println(slice,newSlice)//[10 20 30 40 50] [20 30] // 修改newSlice索引为1的元素，同时也修改了原来的 slice 的索引为 2 的元素 newSlice[1] = 35 fmt.Println(slice,newSlice) //[10 20 35 40 50] [35 88]  ![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-08-03 下午4.42.59.png)
 索引越界 索引越界会引发运行时错误：
// 创建一个整型切片，其长度和容量都是 5 个元素 slice := []int{10, 20, 30, 40, 50} // 创建一个新切片，其长度为 2 个元素，容量为 4 个元素 newSlice := slice[1:3] // 修改newSlice索引为3的元素，这个元素对于newSlice来说并不存在 newSlice[3] = 45 //因为newSlice的长度为2，因此索引只包括0，1 // 这个切片操作试图设置容量为4，这比可用的容量大 source := []string{&amp;#34;Apple&amp;#34;, &amp;#34;Orange&amp;#34;, &amp;#34;Plum&amp;#34;, &amp;#34;Banana&amp;#34;, &amp;#34;Grape&amp;#34;} slice := source[2:3:6] //容量大于已有容量，因为包括2在内的索引为2，3，4，只有3个元素了  切片增长 使用append向slice里面追加一个或者多个元素，总是会增加新切片的长度，而容量有可能会改变，这取决于被操作的切片的可用容量。
使用append会返回一个和原slice一样类型的slice。并且会改变slice所引用的数组的内容，从而影响到引用同一数组的其他slice。因此使用append函数可能会影响之前的切片。
// 创建一个整型切片，其长度和容量都是 5 个元素 slice := []int{10, 20, 30, 40, 50} // 创建一个新切片，其长度为 2 个元素，容量为 4 个元素 newSlice := slice[1:3] //[20 30] fmt.Println(slice,newSlice)//[10 20 30 40 50] [20 30]  // 使用原有的容量来分配一个新元素，将新元素赋值为 60 newSlice = append(newSlice, 60) //替换 slice 中 40 为 60 fmt.Println(slice,newSlice) //[10 20 30 60 50] [20 30 60] ![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-08-03 下午5.04.54.png)
如果切片的底层数组没有足够的可用容量——是指超出切片的cap限制，而非底层数组长度限制，因为数组长度len可小于数组容量cap。此时，append 函数会创建一个新的底层数组，将被引用的现有的值复制到新数组里，再追加新的值：
// 创建一个整型切片其长度和容量都是 4 个元素 slice := []int{10, 20, 30, 40} // 向切片追加一个新元素 fmt.Println(slice) //[10 20 30 40] newSlice := append(slice, 50)// 将新元素赋值为 50 fmt.Println(slice,newSlice)//[10 20 30 40] [10 20 30 40 50] 当这个append操作完成后， 拥有一个全新的底层数组，这个数组的容量是原来的两倍「新分配的底层数组是原cap的2倍，而非原数组的2倍」，此外新分配时并非总是2倍，对于较大的切片，会尝试扩容1/4，以节约内存。
![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-08-03 下午5.34.08.png)
在切片的容量小于1000个元素时，总是会成倍地增加容量。一旦元素个数超过1000，容量的增长因子会设为1.25，也就是会每次增加25%的容量。随着语言的演化，这种增长算法可能会有所改变。因此在对切片使用append函数时，要特别注意是否超出了容量，如果超出了容量，则会创建一个新的底层数组
 迭代切片 当迭代切片时，关键字range会返回两个值。第一个值是当前迭代到的索引位置(下标），第二个值是该位置对应元素值的一份副本。
slice := []int{10, 20, 30, 40} // 迭代每一个元素，并显示其值 for index, value := range slice { fmt.Printf(&amp;#34;Index: %d Value: %d\n&amp;#34;, index, value) } ![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-08-03 下午5.45.17.png)
使用for-range迭代数组和切片有很重要的区别，如下所示：
data :=[3] int{10,20,30} for i,x := range data { //更新数组的值之后,x的值不起作用,猜测是另外使用了一个数组来复制原数组，因为数组不是引用类型 	if i == 0{ data[0] &#43;= 100 data[1] &#43;= 200 data[2] &#43;= 300 } fmt.Println(x,data[i]) }//10 110 20 220 30 330  for i,x := range data[:] { //更新引用中的值之后,x的值在下一轮立即起作用 	if i == 0{ data[0] &#43;= 100 data[1] &#43;= 200 data[2] &#43;= 300 } fmt.Println(x,data[i]) }//110 210 420 420 630 630  函数参数为切片 由于与切片关联的数据包含在底层数组里，不属于切片本身，所以将切片复制到任意函数的时候，对底层数组大小都不会有影响，复制时只会复制切片本身，不会涉及底层数组，但是操作时可能改变顶层数组。
// 分配包含 100 万个整型值的切片 slice := make([]int, 1e6) // 将 slice 传递到函数 foo slice = foo(slice) // 函数 foo 接收一个整型切片，并返回这个切片 func foo(slice []int) []int { ... return slice } ![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-08-03 下午5.54.25.png)
在函数间传递24字节（64位机器）的数据会非常快速、简单。这也是切片效率高的地方。不需要传递指针和处理复杂的语法，只需要复制切片，按想要的方式修改数据，然后传递回一份新的切片副本。
 </content>
    </entry>
    
     <entry>
        <title>Go 数组</title>
        <url>https://iihui.github.io/post/go-array/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>Go</tag>
        </tags>
        <content type="html"> 定义 在Go语言里，数组是一个长度固定的数据类型，用于连续存储多个具有相同的类型的元素。数组存储的类型可以是内置类型，如整型或者字符串，也可以是某种结构类型。
![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-08-03 下午3.13.38.png)
 声明和初始化 声明 声明数组时需要指定内部存储的数据的类型，以及需要存储的元素的数量，这个数量也称为数组的长度。数组长度必须是一个常量表达式，并且是一个非负数，数组长度最大为2Gb。
var a [5]int //[5]与int紧贴 一旦声明，数组里存储的数据类型和数组长度就都不能改变了。如果需要存储更多的元素， 就需要先创建一个更长的数组，再把原来数组里的值复制到新数组里。
在Go语言中声明变量时，总会使用对应类型的零值来对变量进行初始化。数组也不例外。 当数组初始化时，数组内每个元素都初始化为对应类型的零值。
![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-08-03 下午3.16.38.png)
 初始化 如果使用... 替代数组的长度，Go语言会根据初始化时数组元素的数量来确定该数组的长度。
array1 := [5]int{10,20,30,40,50} //前面的数字5来确定数组的长度 array2 := [...]int{1,2,3,4,5} //后面的数据元素来确定数组的长度 // var array3 [...]int =[...]int{12,35.89}这种方式是不行的， //也就是说[...]int 声明数组的时候，[...]int只能出现在=的右边，不能在左边出现 如果知道数组的长度，并且准备给每个值都指定具体值，就可以使用如下的形式来声明数组：
array :=[5]int{1:10,2:20} //数组长度已知，给数组中某些元素赋予特殊的值 ![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-08-03 下午3.21.09.png)
array := [4][2]int{1: {20, 21}, 3: {40, 41}}  注意事项   使用下标来访问数组时，因为会检测下标的大小，所以一旦超出了数组的长度，那么会给出提示；如果没有检测到超出范围而实际上超出了数组长度，则运行时会panic。
  数组变量的类型包括数组长度和每个元素的类型。只有这两部分都相同的数组，才是类型相同的数组，才能相互赋值。
  多维数组的类型包括每一维度的长度以及数据的类型。
  在函数之间传递变量时，总是以值的方式传递的。如果这个变量是一个数组，意味着整个数组，不管有多长都会完整复制，并传递给函数。如果数组长度很大的话，会影响性能，此时建议使用切片。
var array [1e6]int // 将数组传递给函数 foo foo(array) // 函数 foo 接受一个 100 万个整型值的数组 func foo(array [1e6]int) { ... }   定义数组时，数组长度必须是非负整型常量表达式，长度是类型的组成部分，也就是说元素类型相同，但长度不同的数组不属于同一类型。
var d1 [3] int var d2 [4] int d1 = d2 //错误， d1 和 d2 不属于同一类型，不能赋值，不能比较   未提供初始化值的元素自动初始化为类型零值。
var d1 [3] int //初始化为[0 0 0] var d2 [4] int //初始化为[0 0 0 0] d3 := [5]int{2,3,4} //初始化为 [2 3 4 0 0] fmt.Println(d1,d2,d3) //[0 0 0] [0 0 0 0] [2 3 4 0 0]   数组初始化时，可指定位置进行初始化，只要不超出数组的长度范围即可。
d4 := [4]int{5,3:10} //[5 0 0 10]   编译器可以按照初始化值的数量确定数组长度，数组在声明的时候使用[...]即可
d5 := [...]int{34,8,9} //长度为3 d6 := [...]int{5,3:10} //长度为4，内容为[5 0 0 10]   在定义多维数组时，仅第一维可以允许使用...，即省略第1维的长度。
  内置函数len和cap可以返回第一维长度d7 :=[3][4]int {{2},{3}} fmt.Println(len(d7),cap(d7)) //3,3 返回的是第一维的长度   如果数组中的元素支持==，！= 等操作符，那么数组也支持该操作。var d1 [4] int //d1数组中元素全部为0 var d2 [4] int //d2数组中元素全部为0 d3 := [4]int{2,3,4} d4 := [4]int{5,3:10} fmt.Println(d1==d2,d3==d4) //true false   分清指针数组和数组指针：数组的地址为数组指针，而数组中的元素类型为指针则为数组指针。
d11,d12:=20,10 d13:=[...]*int{&amp;amp;d11,&amp;amp;d12} //指针数组 d14:=&amp;amp;d13 //数组指针 fmt.Println(d13,d14) //[0xc420072250 0xc420072258] &amp;amp;[0xc420072250 0xc420072258]   可以获取数组中任意元素的地址，只要在数组元素前加&amp;amp;即可。
d4 := [4]int{5,3:10} fmt.Println(&amp;amp;d4,&amp;amp;d4[0],&amp;amp;d4[3])//&amp;amp;[5 0 0 10] 0xc4200680e0 0xc4200680f8    </content>
    </entry>
    
     <entry>
        <title>Go 未命名类型</title>
        <url>https://iihui.github.io/post/go-undef-type/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>Go</tag>
        </tags>
        <content type="html"> 未命名类型 在Go中数组、切片、字典、通道类型与具体元素类型或长度属性相关，故被称为未命名类型。具有相同声明的未命名类型被称为同一类型，在 Go 中未命名类型共有8类。
  具有相同基础类型的指针
  具有相同元素类型和长度的数组array
  具有相同元素类型的切片slice
  具有相同键和值类型的字典map
  具有相同数据类型以及操作方向的通道channel
  具有相同字段序列（字段名、字段类型、标签以及字段顺序）的结构体struct
  具有相同签名的（参数和返回值列表，不包括参数名）的函数func，其中函数的参数顺序也属于签名的组成部分
  具有相同方法集（方法名，方法签名，不包括顺序）的接口interface
  容易被忽略的是struct tag它属于类型组成的一部分，而不仅仅是元数据描述
  var a struct{ x int `x` s string `s` } var b struct{ x int s string } b=a //cannot use a (type struct { x int &amp;#34;x&amp;#34;; s string &amp;#34;s&amp;#34; })  //as type struct { x int; s string } in assignment fmt.Println(b)  未命名类型的转换规则   所属类型完全相同
  基础类型相同，其中一个是未命名类型
  数据类型相同，将双向通道赋值给单向通道，且其中一个是未命名类型
type data [2]int //data是使用数组新定义的类型  var d data =[2]int{1,2} //基础类型相同，其中一个是未命名类型 	doubleChan := make(chan int,3) //双向通道  var singleChan chan&amp;lt;- int = doubleChan //双向通道赋值给单向通道     </content>
    </entry>
    
     <entry>
        <title>Go 接口</title>
        <url>https://iihui.github.io/post/go-interface/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>Go</tag>
        </tags>
        <content type="html"> 接口定义 接口代表一种调用契约，是多个方法声明的集合。在某些动态语言中接口(interface)也被称为协议(protocol)。准备交互的双方，共同遵守事先的约定规则，使得在无须知道对方身份的情况下进行协作。接口关心的是做什么，而不关心怎么做，谁来做。接口解除了类型依赖，有助于减少用户可视方法，屏蔽内部结构和实现细节。但这并不意味着可以滥用接口，因为实现接口会有运行时开销。接口最常见的使用场景是对包外提供访问，或预留扩展空间。接口定义了一组方法，但是这些方法不包括实现代码，接口中也不包含变量「我的理解是不包含普通变量，但可以有接口变量」。
在Go中只要目标类型方法集内包含接口声明的全部方法，就被当作实现了该接口，不需要做显式的声明。显然这是一种非侵入式的设计方法，这种设计方法的好处是，在前期开发时设计出合理的接口并不容易，等后期代码重构时，模块分拆时再分离出接口时比较容易。
 注意事项 按照约定，接口名字首选以er或者r结尾，其次为able为后缀，最次以I开头。在定义接口时需要注意的事项：
  接口的本质可以认为是一个指针，但和指针又不完全相同——指向接口变量的指针是非法的，如下是var ai namer在内存中的布局： ![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-12-18 上午8.54.39.png)
  接口定义中，不能出现变量定义。「我的理解是不可以有普通变量，但是可以嵌入其他接口」
  Go中接口都很简短，一般0到3个方法。
  接口定义中只能声明方法，不能包含方法的具体实现。
  接口定义中，不能定义接口自己的方法。
  编译器会根据目标类型的方法集来确定该类型是否实现了该接口，如果目标类型的方法集中没有完全实现接口中声明的方法，那么该目标类型就不可以赋值给该接口变量。
  即使接口在类型之后才定义，二者处于不同的包中，被单独编译。但是，只要类型实现了接口中的方法，它就实现了此接口。
  一个接口可以包含一个或多个其他接口，这相当于直接将这些内嵌接口的方法列举在外层接口中一样。  可以像嵌入匿名字段那样，嵌入其他接口类型。此时目标类型方法集中必须包含嵌入的接口方法在内的全部方法，才能算实现了该接口。也就是说嵌入其他接口类型，相当于将嵌入的接口声明的全部方法导入。这就要求嵌入接口中的方法与本接口中不能有同名的方法，因为Go不支持重载。  在接口中嵌入接口时，超集接口变量可以隐式转换为嵌入的接口变量。反过来不行——因为信息不完整了。
  在嵌入接口类型时，不能嵌入自身或循环嵌入，那会导致递归错误。
  支持匿名接口类型：①可以直接用于变量定义 ②可用于结构体字段类型。
  多个类型可以实现同一个接口，实现某个接口的类型（除了实现接口方法外）可以有其他的方法，这就说明一个类型可以实现多个接口。
  接口变量的默认值是nil(因为接口也是一种引用类型)。
  对于两个接口变量对应的目标类型支持判等运算，那么这两个变量就可以做相等运算。
  如果接口没有任何方法声明，那么就是一个空接口，它的用途和Java中的Object一样，可以被赋值为任何类型的对象。
   接口嵌套接口 一个接口可以包含一个或多个其他的接口，这相当于直接将这些内嵌接口的方法列举在外层接口中一样。type ReadWrite interface{ Read(b buffer) bool Write(b buffer) bool } type Lock interface{ Lock() Unlock() } type File interface{ ReadWrite //嵌入接口  Lock Close() //自己的方法 }  检测和转换接口变量 一个接口变量可以被任何实现了该接口的类型的变量赋值，即接口变量在运行时存在多态行为。因此需要一种方法来检测某个时刻一个接口变量是否是某个类型T。
v:=x.(T) //未检测类型断言  if v,ok := x.(T); ok{ //检测类型断言  do something return } 其中x表示接口类型的变量，且必须是接口类型变量，否则编译器会报错。而T表示需要被检测的目标类型。在检测类型断言中，如果转换合法，那么v是x转换到T类型的值，ok为true，否则v是T类型的零值，ok的值为false，此时不会有运行时错误发生。
当需要检测的类型较多时，建议使用type-switch，但是在type-switch不允许有fallthrough。switch t := areaIntf.(type) { case *Square: fmt.Printf(&amp;#34;Type Square %T with value %v\n&amp;#34;, t, t) case *Circle: fmt.Printf(&amp;#34;Type Circle %T with value %v\n&amp;#34;, t, t) case nil: fmt.Printf(&amp;#34;nil value: nothing to check?\n&amp;#34;) default: fmt.Printf(&amp;#34;Unexpected type %T\n&amp;#34;, t) } 但是所有的case语句中列举的类型(nil除外)都必须实现对应的接口，如果被检测类型没有匹配case语句列举的类型，就会执行default语句。
 空接口 空接口是不包含任何方法，它对实现不做任何要求。任何类型都实现了空接口，any或Any是空接口一个很好的别名或者缩写。
type any interface{} 可以给一个空接口类型的变量var val interface{} 赋任何类型的值。
每个空接口变量在内存中占据两个字节，一个用来存储它包含的类型，另一个用来存储它包含的数据或者指向数据的指针。
 执行机制 接口是一种契约，实现类型必须满足它，它描述了类型的行为，规定类型可以做什么。接口将类型能做什么和如何做分离开来，使得相同接口变量在不同时刻表现出不同的行为，这就是多态的本质。
从内部实现上来看，接口自身也是一种结构体，只是编译器会对其作出很多限制。接口使用一个名为itab的结构体存储运行期所需的相关类型信息。
![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-12-18 上午8.54.39.png)
type iface struct{ tab * itab //类型信息  data unsafe.Pointer //实际对象指针 } type itab struct{ inter *interfacetype //接口类型  _type *_type //实际对象类型  fun [1]uintptr //实际对象方法地址 } 接口有一个重要的特性：将对象赋值给接口变量时，会复制该对象。我们甚至无法修改接口存储的复制品，因为它是unaddreable，即使将其复制出来，使用本地变量修改后，依然无法对iface.data赋值。解决的方法是将对象指针赋值给接口，那么接口内存储的就是指针的复制品。只有当接口变量的内部的两个指针(itab,data)都为nil时，接口才等于nil。因此造成的错误并不少见，尤其是在函数返回error时，详见Go学习笔记P149。
var a interface{}=nil var b interface{}=(*int)(nil) println(a==nil,b==nil) //true false 类型推断可将接口变量还原为原始类型，或者用来判断是否实现了某个更具体的接口类型
type data int func (d data) String() string{ return fmt.Sprintf(&amp;#34;data:&amp;#34;%d&amp;#34;,d) } var d data=16 if n,ok:=x.(fmt.Stringer); ok{ //转换为更具体的接口类型  fmt.Println(n) } if d2,ok:=x.(data); ok{ //转换为原始类型  fmt.Println(d2) } e:=x.(error) //错误，main.data is not error fmt.Println(e) 使用ok-idiom模式，即使转换失败也不会引发panic。还可以用switch语句在多种类型间作出推断匹配，这样接口就能有更多的发挥空间。
var x interface{}=func(x int)string{ return fmt.Sprintf(&amp;#34;d:%d&amp;#34;,x) } switch v := x.type{ case nil: println(&amp;#34;nil&amp;#34;) case *int: println(*v) case func(int)string: println(v(100) case fmt.Stringer: fmt.println(v) default: fmt.println(&amp;#34;unknown&amp;#34;) } 如上所示的type switch中不支持fallthrought。
 </content>
    </entry>
    
     <entry>
        <title>Go 定义类型</title>
        <url>https://iihui.github.io/post/go-struct/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>Go</tag>
        </tags>
        <content type="html">  值的类型给编译器提供两部分信息：①需要分配多少内存给这个值；②这段内存表示什么。Go语言允许用户定义类型，当用户声明一个新类型时，这个声明就给编译器提供一个框架，告知必要的内存大小和表示信息。
 结构体 Go语言中声明用户定义的类型有两种方法，①最常用的方法是使用关键字struct，它可以让用户创建一个结构类型；②另一种是使用根据已有类型来定义新的类型。
结构体的定义 结构体类型通过组合一系列固定且唯一的字段来声明，结构体中每个字段都会用一个已知类型声明。结构体声明以关键字type开始，之后是新类型的名字，最后是关键字struct。
type user struct { name string email string ext int privileged bool } var bill user //像声明内置类型变量一样声明  结构体的初始化 当声明结构体变量时，这个变量对应的值总是会被初始化。这个值要么用指定的值初始化，要么使用类型零值做初始化。
既然要创建初始化一个结构类型，可以使用结构体字面量来完成这个初始化。结构体字面量使用一对大括号括住内部字段的初始值，结构字面量可以对结构类型变量初始化可以采用两种形式。
一种是顺序字面量，另一种是命名字面量。初始化的时候，使用顺序字面量对结构体变量进行初始化称为顺序初始化，而使用命名字面量进行初始化称为命名初始化。推荐使用命名初始化，这样在扩充结构体的字段时就不会导致初始化错误。
user{ //命名字面量  name : &amp;#34;Lisa&amp;#34;, email : &amp;#34;Lisa@gmail.com&amp;#34;, ext : 123, privileged : true, } //顺序字面量进行顺序初始化，必须要和结构声明中的字段的顺序一致 lisa := user{&amp;#34;Lisa&amp;#34;,&amp;#34;Lisa@gmail.com&amp;#34;,123,true} //顺序方式 u1 ：= user{&amp;#34;Andy&amp;#34;,&amp;#34;Andy@gmail.com&amp;#34;} //错误，顺序初始化时参数不够 使用命名字面量进行初始化称为命名初始化：
type node struct { _ int id int next * node } n1 := node{ id:1, //逗号不可以省略，未初始化的为类型默认零值 } n2 := node{ id:2, next: &amp;amp;n1, //即使是结构体的最后一个变量，逗号不可以省略 } fmt.Println(n1,n2)//{0 1 &amp;lt;nil&amp;gt;} {0 2 0xc4200be4e0}  匿名结构体 可直接定义匿名结构体类型变量，或用做结构体的命名字段类型「不能是匿名字段类型，因为类型已经没有名字」。匿名结构体在作为结构体的字段值时因其缺少类型标识，无法进行直接初始化，前面的两种方式的字面量都需要结构体类型名字：
u := struct { // 直接定义匿名结构体  name string age byte }{ name : &amp;#34;Tom&amp;#34;, age : 12, } type file struct{ name string attr struct { //匿名结构体字段  owner int perm int } f := file { name: &amp;#34;test.dat&amp;#34; // attr: { //错误 // owner: 1, // perm: 0755, //}, } f.attr.owner = 1 //也可以在初始化语句中再次定义，但那样看上去会非常丑陋 f.attr.perm = 0755  注意事项 只有在所有字段类全部支持判等操作时，才可以做相等操作:
type data struct { x int y map[string]int } d1 := data{ //命名初始化  x: 100, } d2 := data{ //命名初始化  x: 100, } println(d1 == d2) 可以使用指针直接操作结构字段，但不能是多级指针。
type user struct { name string age int } p := &amp;amp; user{ name : &amp;#34;Tom&amp;#34; age : 12 } p.name = &amp;#34;Mary&amp;#34; //指针直接操作结构体字段 p.age &#43;&#43; //指针直接操作结构体字段  p2 := &amp;amp; p *p2.name = &amp;#34;Jack&amp;#34; //错误，不能使用多级指针直接操作结构体字段  空结构体 空结构体struct {}是指没有字段的结构类型，它比较特殊，因为无论是其自身，还是作为数组元素类型，其长度均为0。
var a struct{} var b [100] struct{} println(unsafe.Sizeof(a),unsafe.Sizeof(b))//0 0 对于空结构体来说，尽管没有分配数组内存，但依然可以操作元素，对应切片len,cap属性也正常。
var d[100] struct{} s := d[:] d[1] = struct{}{} d[2] = struct{}{} fmt.Println(s[3],len(s),cap(s)) //{} 100 100 实际上，这类长度为0的空结构体对象通常指向runtime.zerobase变量。 空结构体可作为通道元素类型，用于事件通知。
a := [10]struct{}{} b := a[:] c := [0]int{} fmt.Println(&amp;amp;a,&amp;amp;b,&amp;amp;c)  结构体的匿名字段 所谓匿名字段，是指没有名字，仅有类型的字段，也称作嵌入字段或嵌入类型。
type attr struct { perm int } type file struct { name string attr //匿名字段,但不是匿名结构体，注意区别 } 从编译器的角度看，这只是隐式的以类型作为字段名字。可直接引用匿名字段的成员，但初始化时须当作独立字段。f := file{ name : &amp;#34;test.data&amp;#34;, attr : attr{ //显式初始化匿名字段，注意于匿名结构体那一小结的区别  perm : 0755, }, //分号不能少 } f.perm = 0644 //直接设置匿名字段成员 println(f.perm) 如果嵌入其他包中的类型，则隐式字段名字「不是匿名字段，是匿名字段的名字」不包括包名：
type data stuct { os.File //匿名字段，包括包名 } func main{ d := data { File : os.File{} //匿名字段初始化时，字段名字不包括包名 } 不仅仅是结构体，除接口指针和多级指针以外任何命名类型都可以作为结构体的匿名字段：
type data stuct { * int string } x := 100 d := data { int: &amp;amp;x, //指针作为匿名字段时，其隐式名字为基础类型的名字  string: &amp;#34;abc&amp;#34;, } 需要注意的是，不能将基础类型和其指针类型同时嵌入，因为两者隐式名字相同。
type data stuct { * int //指针类型 int //基础类型 }  虽然可以像普通字段那样访问匿名字段成员，但会存在重名问题。默认情况下，编译器从当前显式名字字段开始，逐步向内查找匿名字段成员。如匿名字段成员被外层同名字段遮蔽，那么必须使用显式字段名。
type file struct { name string } type data struct{ file name string } d := data { name : &amp;#34;data&amp;#34; file : file{&amp;#34;file&amp;#34;} //匿名字段初始化 } d.name = &amp;#34;data2&amp;#34; d.file.name = &amp;#34;file2&amp;#34; //同名字段，使用显式字段名访问 data.file.name 如果多个相同层级的匿名字段成员重名，就只能使用显式字段名，因为编译器无法确定目标：
type file struct { name string } type log struct { name string } type data struct { file log } func main(){ d := data{} d.name = &amp;#34;name&amp;#34; //错误，必须使用显式字段名  d.file.name = &amp;#34;file&amp;#34; d.log.name = &amp;#34;log&amp;#34; }  字段标签 字段标签并不是注释，而是用来对字段进行描述的元数据。尽管它不属于数据成员，但却是类型的组成部分。在运行期，可用反射获取标签信息，它常被用作格式校验，数据库关系映射等。
type user struct{ name string `昵称` sex type `性别` }  内存布局 在Go中不管结构体包含多少个字段，其内存总是一次性分配的，各字段在相邻的地址空间按定义顺序排列。当然，引用类型、字符串和指针，结构内存中只包含其基本(头部)数据。在分配内存时，字段须做对齐处理，通常以所有字段中最长的基础类型宽度为标准。
比较特殊的空结构体类型。如果它是最后一个字段，那么编译器将其当作长度为1的类型做对齐处理，以便其地址不会越界，避免引发垃圾回收错误。
如果仅有一个空结构体字段，那么同样按1对齐，只不过长度为0，且指向runtime.zerobase变量。
 根据已有类型定义新类型 另一种声明用户定义的类型的方法是，基于一个已有的类型，将其作为新类型的类型说明。当需要一个可以用已有类型表示的新类型的时候，这种方法会非常有用。
type Duration int64 给不同类型的变量赋值会产生编译错误
package main type Duration int64 func main(){ var dur Duration dur = int64(1000) //会出现编译错误 }  </content>
    </entry>
    
     <entry>
        <title>Go 延迟调用</title>
        <url>https://iihui.github.io/post/go-defer/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>Go</tag>
        </tags>
        <content type="html">  关键字defer允许我们推迟到函数返回前一刻(或任意位置执行return语句之后)才执行某个语句或函数。
 为什么要在返回之后才执行这些语句？因为return语句同样可以包含一些操作，而不是单纯地返回某个值，实际上此时return语句要做三件事：①如果有命名参数，将返回值赋给命名返回值;②执行defer语句或函数;③结束函数的执行。
语句defer向当前函数注册稍后执行的函数调用，这些函数被称为延迟调用，因为它们直到当前函数执行结束之后才被执行，常用于资源释放，解除锁定，以及错误处理等操作。
执行顺序 同一函数中注册多个defer语句时，执行时将会按照注册顺序先进后出的顺序执行即FILO的次序执行。
如果遇到panic语句，那么和遇到return语句一样，会触发延迟调用，并且延迟调用会先于panic中的打印语句。func main() { defer_call() } func defer_call() { defer func() { fmt.Println(&amp;#34;打印前&amp;#34;) }() //最后调用 	defer func() { fmt.Println(&amp;#34;打印中&amp;#34;) }() //中间调用 	defer func() { fmt.Println(&amp;#34;打印后&amp;#34;) }() //最先调用  panic(&amp;#34;触发异常&amp;#34;) //在defer之后执行 } //打印后 //打印中 //打印前 //panic: 触发异常 编译器通过插入额外的指令来实现延迟调用执行，而return和panic语句都会终止当前函数流程，引发延迟调用。此外，return语句不是ret汇编指令，它会更新返回值，如下例所示：
func TestDefer() (z int) { defer func() { println(&amp;#34;defer&amp;#34;, z) //100 	z &#43;= 100 }() return 100 //最后z的值为200，实际执行次序为z=100， call defer，ret }  使用场景 延迟调用一般用于做一些收尾工作，例如：①关闭文件流；②关闭数据库连接；③解锁一个加锁的资源；④打印最终的报告。
一个基础但十分实用的实现代码执行追踪的方案就是在进入和离开某个函数打印相关的消息，即可以提炼为下面两个函数
func trace(s string) { fmt.Println(&amp;#34;entering:&amp;#34;, s) } func untrace(s string) { fmt.Println(&amp;#34;leaving:&amp;#34;, s) }  注意事项 延迟调用注册的是调用，必须提供执行所需要的参数（哪怕为空），参数在注册的时候被复制并缓存起来，如对状态敏感，可改用指针或闭包。
func TestDeferRegister(){ x, y := 1,2 defer func(a int){ //传给参数a的值被缓存起来 	println(&amp;#34;defer x,y =&amp;#34;,a,y) //y是在延迟调用时读取被改变之后的值 	}(x) x &#43;= 100 y &#43;= 200 println(x,y) //y对于defer函数来说是外部变量  } //101 202  //defer x,y = 1 202  如果在延迟函数中使用外部变量，就应该通过参数传入。具体实例见下面代码：
func printNumber() { for i := 0; i &amp;lt; 5; i&#43;&#43; { defer func () { fmt.Printf(&amp;#34;%d\t&amp;#34;,i) } } }//输出为5 5 5 5 5 func printNumber() { for i := 0; i &amp;lt; 5; i&#43;&#43; { defer func (n int) { fmt.Printf(&amp;#34;%d\t&amp;#34;,i)	}(i) } } //输出为4 3 2 1 0 第一个函数的输出为5 5 5 5 5，是因为使用了外部变量i，当触发延迟调用的时候，i的值已经变成了5。
第二个函数的输出为4 3 2 1 0，是因为匿名函数被传入了一个参数，每次注册的时候，会将传入的参数缓存起来。
 </content>
    </entry>
    
     <entry>
        <title>Go 方法</title>
        <url>https://iihui.github.io/post/go-method/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>Go</tag>
        </tags>
        <content type="html"> 方法 在Go中结构体就像是类的一种简化形式，方法就像类中的方法。方法是与对象实例绑定的特殊函数，方法和函数定义语法区别在于:方法有前置实例接收参数receiver，编译器以此确定方法所属类型。
接收者类型几乎可以是任何类型，不仅仅是结构体类型，甚至可以是函数类型。但是，有两种类型不可以有方法：
  接收者不能是一个接口类型， 因为接口是一个抽象定义，但是方法需要具体实现。
  接收者的类型不能是本身类型是指针的类型，例如type TP *int,那么TP就不可以定义方法。
  一个类型加上它的方法等价于面向对象中的一个类。在Go中，类型的代码和绑定在它上面的方法的代码可以不放置在一起，它们可以存在于不同的源文件，唯一的要求——它们必须在同一个包中。
 使用 package main import ( &amp;#34;fmt&amp;#34; ) type user struct { name string email string } // 使用user值类型作为接收者 func (u user) notify() { fmt.Printf(&amp;#34;Sending User Email To %s&amp;lt;%s&amp;gt;\n&amp;#34;, u.name, u.email) } // 使用指针类型作为接收者 func (u *user) changeEmail(email string) { u.email = email } // func main() { bill := user{&amp;#34;Bill&amp;#34;, &amp;#34;bill@email.com&amp;#34;} bill.notify() //值类型来调用方法  lisa := &amp;amp;user{&amp;#34;Lisa&amp;#34;, &amp;#34;lisa@email.com&amp;#34;} lisa.notify() //指向user类型值的指针也可以调用使用值类型作为接收者的方法  bill.changeEmail(&amp;#34;bill@newdomain.com&amp;#34;) bill.notify() //使用值来调用以指针作为接收者的类型  lisa.changeEmail(&amp;#34;Lisa@newdomain.com&amp;#34;) lisa.notify() //指针类调用以指针类型作为接收者的类型 }  注意事项   方法是一种特殊的函数，因此方法是不支持重载的，即一个类型的方法集中的所有方法是不能够有同名的方法。
  如果方法内部不引用实例，可省略参数名，仅保留类型。
  接收者receiver类型可以是基础类型或指针类型，区别在于调用时对象实例是否被复制。值接收者使用值的副本来调用方法，而指针接受者使用实际值来调用方法。
type N int func TestMethod() { var a N = 25 //println(a.toString())  a.value() fmt.Printf(&amp;#34;a: %p,%v\n&amp;#34;, &amp;amp;a, a) a.pointer() fmt.Printf(&amp;#34;a: %p,%v\n&amp;#34;, &amp;amp;a, a) } func (n N) value() { //值类型的接受者，调用的时候会复制，所以n的值的更改不会体现到接收者的类型上来  n&#43;&#43; fmt.Printf(&amp;#34;v: %p,%v\n&amp;#34;, &amp;amp;n, n) } func (n *N) pointer() { (*n)&#43;&#43; fmt.Printf(&amp;#34;p: %p, %v\n&amp;#34;, n, *n) }   可使用实例值或者指针调用方法，编译器会根据方法receiver类型自动在基础类型和指针类型间转换。
var a N = 25 p := &amp;amp;a a.value() a.pointer() p.value() p.pointer()   只能使用一级指针调用方法，不能使用多级指针调用方法。
var a N = 25 p := &amp;amp;a p2 := &amp;amp;p p2.value() //错误，使用多级指针 p2.pointer() //错误，使用多级指针调用   指针类型的receiver必须是合法地址（包括nil），或能获取实例的地址，否则会出现运行时错误。
var b * N b.value() //b 相当于nil,可以调用，但是会出现运行时错误，因为没有指向具体实例，所以在传参数时出现错误 //N{}.pointer()   别名类型能定义方法的前提是其原始类型没有定义过该方法。
  在Go中类型和作用在它上面的方法必须在同一个包里定义，这就是为什么不能在int、float或类似这样的标准类型上定义方法。有一个比较曲折的绕过这种规定的方式：可以先定义该类型（比如int或float）的别名类型，然后再为别名类型定义方法。
   receiver建议 选择方法的receiver的建议
  要修改实例状态，用 * T
  无须修改的小对象或固定值，建议用T
  大对象建议使用 *T，以减少复制成本
  引用类型，字符串，函数等指针包装对象，直接用T
  若包含 Mutex 等同步字段，用*T，避免因复制造成锁操作无效
  其他无法确定的情况，都用 *T
  可以像访问匿名字段那样调用其方法，由编译器负责查找，尽管可以直接访问匿名字段的成员和方法，但它们仍不属于继承关系
type data struct { sync.Mutex } d := data{} d.Lock() defer d.Unlock()  方法集 类型有一个与之对应的方法集，这决定了它是否实现某个接口。当一个匿名类型被内嵌在结构体中时，匿名类型的可见方法也同样被内嵌。这在效果上等同于外层类型继承了这些方法。这个机制提供了一种简单的方式来模拟经典面向对象语言中的子类和继承相关的效果。
  类型T的方法集包含了所有的receiver T方法
  类型*T包含了所有receiver T&#43;*T方法
  匿名嵌入S，T的方法集中包含所有receiver S方法
  匿名嵌入*S，T的方法集中包含所有receiver S&#43;*S方法
  匿名嵌入S或*S，*T的方法集中包含所有receiver S &#43; *S方法
  和内嵌类型方法具有同样名字的外层类型的方法会覆写内嵌类型对应的方法。
func (S) sVal() {} func (*S) sPtr() {} func (T) tVale() {} func (*T) tPtr() {} func MethodSet(a interface{}) { t := reflect.TypeOf(a) for i, n := 0, t.NumMethod(); i &amp;lt; n; i&#43;&#43; { m := t.Method(i) fmt.Println(m.Name, m.Type) } }  方法表达式 方法和函数一样，除直接调用外，还可赋值变量，作为参数传递，依照具体的引用方法不同，分为 expression 和 value 两种。
Method Expression 通过类型引用的Method Expression会被还原成普通函数样式,receiver是第一参数，调用时须显式传参，可以是T或*T，只要该方法存在于该类型方法集中即可。
type N int func (n N) test() { fmt.Printf(&amp;#34;test.n:,%p,%d\n&amp;#34;, &amp;amp;n, n) } var n N = 25 fmt.Printf(&amp;#34;main.n:,%p,%d\n&amp;#34;, &amp;amp;n, n) f1 := N.test f1(n) f2 := (*N).test //尽管*N方法集包装test方法receiver类型不同，但编译器会保证按原定义类型拷贝传值 f2(&amp;amp;n) //main.n:,0xc42006e1a8,25 //test.n:,0xc42006e1c8,25 //test.n:,0xc42006e1d8,25 还可以直接以表达式的方式调用
N.test(n) (*N).test(&amp;amp;n) //test.n:,0xc42006e1c8,25 //test.n:,0xc42006e1d8,25  Method Value 基于实例或指针引用的method value，参数签名不会改变，依旧按正常方式调用，但当method value被赋值给变量或作为参数传递时，会立即计算并复制该方法执行所需的receiver对象与其绑定，以便在稍后的执行时，能隐式传入receiver参数。
var n N = 25 p := &amp;amp;n n&#43;&#43; t1 := n.test n&#43;&#43; t2 := p.test n&#43;&#43; fmt.Printf(&amp;#34;main.n:,%p,%d\n&amp;#34;, &amp;amp;n, n) t1() t2() //main.n:,0xc42000e258,28 //test.n:,0xc42000e278,26 //test.n:,0xc42000e288,27 当method value作为参数时，会复制含receiver在内的整个method value
func call(m func()){ m() } var n N = 25 p := &amp;amp;n fmt.Printf(&amp;#34;main.n:,%p,%d\n&amp;#34;, &amp;amp;n, n) n&#43;&#43; call(n.test) n&#43;&#43; call(p.test) //main.n:,0xc42006e1a8,25 //test.n:,0xc42006e1c8,26 //test.n:,0xc42006e1d8,27 如果目标方法的receiver是指针类型，那么被复制的仅是指针
只要receiver参数类型正确，使用nil同样可以执行
type N int func (n N) value(){} func (n *N) pointer(){} var ptr *N ptr.pointer() (*N)(nil).pointer() (*N).pointer(nil)  </content>
    </entry>
    
     <entry>
        <title>Go 包</title>
        <url>https://iihui.github.io/post/go-package/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>Go</tag>
        </tags>
        <content type="html">  包是结构化的一种方式,所有Go语言的程序都会组织成若干组文件，每组文件被称为一个包。每个文件都属于且仅属于一个包，一个包中可以包含许多以.go为扩展名的源文件。
 包中源文件 源文件都使用UTF-8编码，每个源文件都属于包的一部分，在文件头部用package声明所属包。
每一个可独立运行的Go语言程序必定包含一个main包，在这个main包中必定包含一个入口函数main，这个函数没有参数也没有返回值。
入口函数main没有参数，必须放到main包中，如果 main函数没有放到main包中，构建工具就不会生成可执行文件。
如果一个源文件被声明属于main代码包，且该文件代码中包含无参数声明和无返回值声明的main函数，则它是命令源码文件。命令源文件可以通过go run命令直接启动运行。
同一个代码包中可以有多个命令源文件，可通过go run命令分别运行，但这会使go build和go install命令无法编译和安装该代码包，因此不应该把多个命令源文件放入到同一个包中。
库源码文件声明的包名会和它所属的目录名一致（建议这样做），且库源码文件中不包含无参数声明和无返回值声明的main函数。
 工作空间 Go的工作空间就是一个对应于特定工程的目录，它包含3个目录，分别是src、bin、pkg目录。
  src目录用以代码包的形式组织并保存Go源码文件。
  pkg目录用以保存使用go install命令安装后的代码包的归档文件。归档文件是指那些以.a结尾的文件。该目录与GOROOT目录下的pkg目录的功能类似，区别在于工作区下的pkg目录保存的用户代码的归档文件。
  bin目录，与pkg目录类似，在通过go install命令完成安装后，保存由Go命令源码文件生成的可执行文件。
  通常需要将工作空间的路径添加GOPATH环境变量列表中，工作空间可以有一个或者多个。
  GOPATH中不要包含Go语言的根目录，以便将Go语言本身的工作空间同用户的工作区严格分开。
  通过go install命令获取的源码，将会下载到GOPATH中设定的第一个工作空间中，并在其中完成编译和安装。
  只有当环境变量GOPATH中只包含一个工作区的目录路径时，go install命令才会把命令的源码文件安装到当前工作区的bin目录下。否则执行go install就会出错，此时需要设置环境变量GOBIN，用于存放所有因安装Go命令源码文件而产生的可执行文件。
  在工作空间里，包括子包在内的所有源码文件都保存在src目录下。至于bin、pkg两个目录，其主要影响go install/get 命令，它们将编译结果安装到两个目录下，以实现增量编译。使用标准库或第三方包前，须用import导入，参数是工作空间中以src为起始的绝对路径。
对于一个导入的包，编译器首先从标准库开始搜索，如果未找到然后就依次搜索GOPATH列表中的各个工作空间。一旦找到了导入的包，即刻停止搜索。
编译器等相关工具按GOPATH设置的路径搜索目标，导入目标库时，排在列表前面的路径比当前工作空间的优先级别更高。其中go get默认将下载的第三方包保存到列表中的第一个工作空间内。
环境变量GOROOT用于指示工具链和标准库的存放路径。环境变量PATH中也应该添加一项GOROOT/bin，这样就可以在任意目录中使用Go的命令了。
 4种方式导入 使用标准库或第三方包，须用import导入，参数是工作空间中以src目录为起始的绝对路径。
import语句告诉编译器到磁盘的哪里去找想要导入的包，编译器会使用Go环境变量设置的路径，通过引入的相对路径来查找磁盘上的包。
编译器首先会查找Go的安装目录，然后才会按顺序查找GOPATH变量中列出的目录。包的导入，总共有四种方式：
import &amp;#34;study/test&amp;#34; //默认方式： test.A import X &amp;#34;study/test&amp;#34; //别名方式： X.A import . &amp;#34;study/test&amp;#34; //简便方式：A import _ &amp;#34;study/test&amp;#34; //初始化方式，无法引用，仅用来初始化目标包，即调用init函数 在Go中未使用的导入(不包括初始化方式)会被编译器视为错误，这与C&#43;&#43;有很大的区别。
 注意事项 一个应用程序可以包含不同的包，按照惯例所有的包名都应该使用小写字母。在Go的安装文件中包含了一些可以直接使用的包——标准库。
属于同一包的源文件必须全部一起被编译，一个包就是编译时的一个单元。如果对一个包进行了重新编译，那么使用了这个包的客户端程序必须全部重新编译。
按照惯例，每个目录只包含一个包，包名一般和目录的名字相同，但这不是强制规定，包名和目录名可以不一样。
除了标识符_,包中所有的代码对象的标识符必须是唯一的，以避免名称冲突，但是相同的标识符可以在不同的包中使用，因为可以使用包名来区分它们。
当标识符以一个大写字母开头，那么它就可以被外部包的代码所使用，这种方式称之为包的导出。标识符如果以小写字母开头，则对外部包是不可见的，但是它们在内部包中是可见可用的。
  处于同一文件夹下的代码文件，必须使用同一个包名。
  在Go中按照惯例包和文件夹同名。实际上，包名和目录名并无关系，不要求保持一致。
  程序中每个代码文件中的init函数都会在main函数之前被执行。执行顺序为全局变量的初始化、init函数的执行，main函数的执行。
  以下几个包被保留，有特殊含义
  main： 可执行入口（入口函数main.main)。
  all: 标准库以及GOPATH中能找到的所有包。
  std,cmd: 标准库以及工具链。
  documentation: 存储文档信息，无法导入（和目录名无关）。
    所有成员在包内均可访问，无论是否在同一源码文件中；但只有名称首字母大写的为可导出成员，在包外是可见的。
  包内每个源码文件可定义一到多个初始化init函数，但编译器不保证执行次序，实际上所有这些初始化函数（包括标准库和导入第三方包）都由编译器自动生成的一个包装函数进行调用，因此可保证在单一线程上执行，且执行一次。
  编译器首先①确保完成所有全局变量初始化，然后②才执行初始化函数。直到这些全部结束后，运行时才正式③进入到main.main入口函数。
  使用import导入标准库或第三方包，必须删除未使用的导入，否则编译器会将其当作错误处理。
   </content>
    </entry>
    
     <entry>
        <title>Go 数据</title>
        <url>https://iihui.github.io/post/go-data/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>Go</tag>
        </tags>
        <content type="html"> 数据类型 Go 中数据分为基本类型，数组，引用，字典（映射)，通道，函数，结构体，接口等等。
  切片slice可实现类似动态数组的功能y := make([]int, 0, 5); append(y,7)。
  将字典map类型内置，可以直接从运行层面获得性能优化。
  所谓ok-idiom模式，就是在返回值中用一个名为ok的布尔值来标识操作是否成功，因为很多操作默认返回零值，所以需要额外说明。
m := make(map[string]int) m[&amp;#34;a&amp;#34;]=1 z,ok:=m[&amp;#34;b&amp;#34;] fmt.Println(z,ok)   可以为任意类型定义方法
type X int func (x * X) inc() { *x&#43;&#43; }    字符串 字符串是用一对双引号&amp;quot;&amp;quot;或者反引号括起来定义的，均采用UTF-8编码，并且是不可变的。
  字符串是一个不可变(byte）字节序列，本身是一个复合序列。头部指针指向字节数组，但没有nullptr结尾，默认以UTF-8存储字符，字面量里允许16进制，8进制以及UTF编码。
type stringStruct struct{ //字符串的底层结构  str unsafe.Pointer len int }   字符串的默认值是&amp;quot;&amp;quot;而不是 nil。
  使用$`$定义不做转义处理的原始字符串, 并且支持跨行。
s := `line\r\n, //`开始定义不做转义的字符串 line 2` fmt.Println(s)   支持==、!=、&amp;lt;、&amp;gt;、&#43;、&#43;= 操作符，使用加法操作符跨行时，加法操作符必须接在上一行的结尾。
s：=&amp;#34;ab&amp;#34;&#43; &amp;#34;cd&amp;#34; fmt.Println(s==&amp;#34;abcd&amp;#34;, s &amp;gt; &amp;#34;abc&amp;#34;) //true true   允许以索引号访问字节数组（非字符），但不能获取元素地址，因为字符串是不可变的。
s：=&amp;#34;hello&amp;#34; fmt.Println(s[0]) //但是不可以使用 &amp;amp;s[0]   以切片语法（起始和结束索引号）返回子串时，其内部依旧指向原字节数组。
s := &amp;#34;abcdefg&amp;#34; s1 := s[:3] //abc，前闭后开 s2:=s[1:4] //bcd s3:=s[2:] //cdefg  fmt.Println(s1,s2,s3) fmt.Printf(&amp;#34;%#v\n&amp;#34;,(*reflect.StringHeader)(unsafe.Pointer(&amp;amp;s))) //&amp;amp;reflect.StringHeader{Data:0x10b4007, Len:7} fmt.Printf(&amp;#34;%#v\n&amp;#34;,(*reflect.StringHeader)(unsafe.Pointer(&amp;amp;s1)))//&amp;amp;reflect.StringHeader{Data:0x10b4007, Len:3}   使用for遍历字符串时，分为byte 和 rune两种方式。因为字符串是UTF-8编码的，而UTF-8是变长编码，因此不难理解会有这两种形式。
s := &amp;#34;吉林&amp;#34; for i:=0;i&amp;lt;len(s) ;i&#43;&#43; { //byte形式  fmt.Printf(&amp;#34;%d:[%c]\n&amp;#34;,i,s[i]) //0:[å]1:[]2:[]3:[æ]4:[]5:[] } for i,c:=range s { //rune形式  fmt.Printf(&amp;#34;%d:[%c]\n&amp;#34;,i,c) //0:[吉]3:[林]  }   要修改字符串，必须将其转换为可变类型[]byte 或[]rune,待完成后再转换回来，但是不管如何转换，都必须重新分配内存，并复制数据。
  使用加法操作符拼接字符串时，每次都必须重新分配内存，因为字符串是不变的。
  字符串操作通常在堆上分配内存，这会对Web高并发应用造成较大影响，会有大量字符串对象要做垃圾回收，建议使用[]byte缓存池。
  使用单引号的字面量，其默认是rune（专门用来存储unicode码点，它是uint32的别名）。
  不能使用索引的方式修改字符串的值，但是可以使用使用赋值的方式修改整个字符串的值，类比与C&#43;&#43;中字符指针指向字符串常量时，不能以索引的形式修改单个字符，但是能够改变字符指针的指向。
s := &amp;#34;abcdef&amp;#34; fmt.Println(s,&amp;amp;s) //abcdef 0xc42000e3c0 s =&amp;#34;hello&amp;#34; //重新指向 fmt.Println(s,&amp;amp;s) //hello 0xc42000e3c0 s[1]=&amp;#39;c&amp;#39; //这是错误的,因为字符串的内部指针指向的是不可变字节，不能获取地址    数组   定义数组时，数组长度必须是非负整型常量表达式，长度是类型的组成部分，也就是说元素类型相同，但长度不同的数组不属于同一类型。
var d1 [3] int var d2 [4] int d1 = d2 // d1 和 d2 不属于同一类型，不能赋值，不能比较   未提供初始化值的元素自动初始化为类型零值（不同类型的零值不一样的）。
var d1 [3] int var d2 [4] int d3 := [5]int{2,3,4} fmt.Println(d1,d2,d3) //[0 0 0] [0 0 0 0] [2 3 4 0 0]   数组初始化时，可指定位置进行初始化。
d4 := [4]int{5,3:10} //[5 0 0 10]   编译器可以按照初始化值的数量确定数组长度。其中声明时的...一定不可以被省略。
d5 := [...]int{34,8,9} //长度为3 d6 := [...]int{5,3:10} //长度为4，内容为[5 0 0 10]   在定义多维数组时，仅第一维可以允许使用...，即省略第1维的长度。
  内置函数len和cap可以返回数组的第一维长度。
d7 :=[3][4]int {{2},{3}} fmt.Println(len(d7),cap(d7)) //3,3   如元素支持==，！= 等操作符，那么数组也支持该操作，这与C和C&#43;&#43;有很大的区别。
var d1 [4] int var d2 [4] int d3 := [4]int{2,3,4} d4 := [4]int{5,3:10} fmt.Println(d1==d2,d3==d4) //true false   分清指针数组和数组指针，这个概念和C与C&#43;&#43;是一样的。
d11,d12:=20,10 d13:=[]*int{&amp;amp;d11,&amp;amp;d12} //指针数组 d14:=&amp;amp;d13 //数组指针 fmt.Println(d13,d14) //[0xc420072250 0xc420072258] &amp;amp;[0xc420072250 0xc420072258]   可以获取任意元素的地址；而对于字符串来说，是不可以获取单个字符的地址。
d4 := [4]int{5,3:10} fmt.Println(&amp;amp;d4,&amp;amp;d4[0],&amp;amp;d4[3])//&amp;amp;[5 0 0 10] 0xc4200680e0 0xc4200680f8   数组的赋值和传参都会复制整个数组，为了避免数据复制，可以改用指针或切片。
   切片 切片本身并非动态数组或数组指针，它通过内部指针引用底层数组，设定相关属性，将数据读写操作限定到指定区域。
type slice struct{ array unsafe.Pointer // 指向数组中slice中指定的开始位置  len int // slice 的长度  cap int //最大长度，就是slice开始位置到数组的最后位置的长度 } 切片可以从一个数组或一个已经存在的的切片中再次声明。切片通过 array[i:j] 来获取，表示的区间是[i,j)即前闭后开区间，长度为j-i。
var arr =[10]byte{&amp;#39;a&amp;#39;,&amp;#39;b&amp;#39;,&amp;#39;c&amp;#39;,&amp;#39;d&amp;#39;} //array 声明长度 var a,b[] byte //slice，方括号里不声明长度  a = arr[1:3] b = arr[2:4] fmt.Println(a,b) //[98 99] [99 100] 切片是引用类型，所以当指向相同的底层结构的切片改变元素的值时，其他所有引用该底层数组的切片都会改变该值。
var arr =[10]byte{81,82,83,84,85,86} //array  var a,b,c [] byte //slice  a = arr[1:3] b = arr[2:4] fmt.Println(a,b) //[98 99] [99 100]  c = a[0:2] fmt.Println(c) //[82,83]  a = arr[1:5] fmt.Println(a,c) //[82 83 84 85] [82 83] 函数append向slice里面追加一个或者多个元素，然后返回一个和 slice一样类型的slice。并且会改变slice所引用的数组的内容，从而影响到引用同一数组的其他slice。
 字典 map是引用类型，应该使用make来分配空间。在声明的时候不需要知道map的长度，因为map是动态增长的。
未初始化的map的值是nil,此时不能对nil字典进行写操作，但是可以进行读操作。
  key可以是任意使用==或者!=操作符比较的类型，所以切片不能作为key(只包含内建类型的struct可以作为key，即不包含切片的数组)，指针和接口类型都可以作为key。
  value可以是任意类型，通过空接口可以存储任意类型的值，map也可以使用函数作为自己的值。
  字典map是无序的（因为key是无序的，导致value也是无序的），所以每次打印出来的结果都会不一样。
  value不能通过下标获取，只能通过key获取，此时的索引是key而不是下标。
  map的长度可以动态增长，当map增加到容量上限的时候，如果再增加新的Key-value对，map的大小会自动加1。出于性能考虑，对于大的map或者会快速扩张的map，即使只是大概知道容量，也最好预先标明容量。
  内置的len函数返回key的数量，不支持cap；而数组和切片中都可以使用len和cap函数。
  map的初始化可以通过key:val的方式初始化：
rating :=map[string]float32{&amp;#34;C&amp;#34;:5,&amp;#34;Go&amp;#34;:1.83} fmt.Println(rating) //map[C:5 Go:1.83]   map是一种引用类型，如果两个map同时指向同一个底层，那么一个改变，另一个也改变：
m := make(map[string]string) m [&amp;#34;Hello&amp;#34;] = &amp;#34;hello&amp;#34; m1 := m m1[&amp;#34;Hello&amp;#34;] = &amp;#34;world&amp;#34; fmt.Println(m,m1) //map[Hello:world] map[Hello:world]   访问不存在的键值，默认返回的是value的类型零值，不会引发错误，因此推荐使用ok-idiom模式，确定是否正确返回。
m := make(map[string]bool) m[&amp;#34;chen&amp;#34;] = true fmt.Println(m[&amp;#34;xiao&amp;#34;]) //false   当value是数组或者结构体成员时，不能直接修改value成员，正确的做法是返回整个value，待修改后再设置字典键值，或直接用指针类型。
  不能对nil字典进行写操作，但却能读。
var m map[string] int println(m[&amp;#34;a&amp;#34;]) m[&amp;#34;a&amp;#34;]=1 //错误   内容为空的字典与nil是不同的，内容为空的字典是可以写的，而nil字典不可以写。
var m1 map[string]int m2 := map[string]int{} println(m1==nil,m2==nil)//true false   在迭代期间删除或者新增键值是安全的。
  运行时会对字典并发操作作出检测，如果某个任务正在对字典进行写操作，那么其他任务就不能对该字典进行并发操作（读，写，删除）否则会导致进程崩溃。
  map默认是无序的，不管是按照key还是按照value默认都不排序，如果想要为map排序，必须将key拷贝到一个切片，再对切片进行排序，然后使用切片的for-range的方法打印出所有的key和value。
   </content>
    </entry>
    
     <entry>
        <title>Go 函数</title>
        <url>https://iihui.github.io/post/go-func/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>Go</tag>
        </tags>
        <content type="html"> Go中有3种类型的函数，第一种是普通带名字的函数，第二种是匿名函数(或者被称为lambda函数)，第三种是方法（含有接收者的特殊函数）。
特点 在Go中关键字func用于定义函数，相比于其他语言，Go中函数有以下的特点：
  函数是一等公民，即可作为参数或者返回值，可以存入变量，与变量的地位是等同的。
  函数可定义多个返回值，也可以对返回值命名。
  Go 中函数无需前置说明，即可以先使用后定义。
  Go中函数不支持同名重载，主要是因为函数重载需要匹配多余的类型而影响性能。因此，对于参数类型不同的功能相似的函数要取不同的名字。
  Go中不支持默认参数。
  Go函数中不支持命名嵌套定义(nested)——即在函数中再定义有名函数，但在函数中使可以定义匿名函数，而且可以将匿名函数赋值给变量，然后使用该变量来调用相应的函数。
  Go中函数支持不定长参数，但是必须放在末尾。
  Go中支持匿名函数和闭包。
  函数中的左花括号不可以另起一行。
   定义 每个普通函数的声明都包含一个名字，一个形参列表，一个可选的返回列表以及函数体。
func name(parameter-list)(result-list){ body } 函数的类型称之为函数签名。当两个函数拥有相同的形参列表和返回值列表时，认为两个函数的类型或签名是相同的。下面四种方式声明一个含有两个形参和一个返回值的函数：
func add(x int, y int)int{ return x&#43;y} func sub(x,y int)(z int) { z=x-y; return } func first(x int, _ int) int {return x} func zero(int, int) int {return 0} 函数形参以及命名返回值都属于函数最外层作用域的局部变量；实参是按值传递的，所以函数接收到的是每个实参的副本，修改函数的形参并不会影响到调用者提供的实参。但是，如果提供的实参包含引用类型，例如指针，slice，map、函数或者通道，那么当函数使用形参变量时就会可能间接地修改实参变量。
函数只能判断是否为nil，不支持其他比较操作可以认为函数是一种引用类型。
func A() {} func B() {} func main() { fmt.Println(hellolib.A == nil) //可以比较，结果为false } 从函数返回局部变量指针是安全的，编译器会通过逃逸分析(escape analysis）对函数中的指针进行扫描，查看它的作用域是否在函数内，来决定是否在堆上分配内存。
func LocalPtr() *int { x := 0x100 return &amp;amp;x } fmt.Println(hellolib.LocalPtr()) //变成了堆内存,0xc42007a078  参数与返回值 参数   不支持有默认值的参数。
  不支持命名实参调用（即根据参数的名字打乱顺序调用，R语言支持这种方式）。
  调用时必须按照签名顺序传递指定类型和数量的实参，就算以_命名的参数也不能被忽略。
  在参数列表中，相邻的同类型参数可合并，这样写更方便一点：
func f(a, b int) { fmt.Println(&amp;#34;Test&amp;#34;) }   参数可视作局部变量，因此不能在相同层次定义同名变量。
  不管是指针，引用类型还是其他类型参数，都是值拷贝，区别在于是拷贝目标对象还是拷贝指针。
  在函数调用前，会为形参和返回值分配内存空间，并将实参拷贝到形参内存中。
  变参（不定长）本质上是一个切片，只能接收0到多个同类型参数，且必须放到列表尾部。变参的长度可以为0，也就是说不传入参数。
func tt1(a ...int) { fmt.Println(a) } func main() { tt1() //可以不带参数调用 }   如果不定长参数的值都存储在切片中（不能是数组，如果是数组必须先转为切片），则使用slice...（3个点不能少）的方式进行展开，以传递参数。
  不定长参数可以作为对应类型的切片（不做任何修改）进行二次传递，而反过来不行，如上一条所示，必须在切片后面加...才能传递给不定长的参数。
  如果想传递类型不同的变长参数，一种方法是使用结构体，一种方式使用空接口。
  在函数调用中，切片、字典、通道以及接口都是按引用类型传递。
   返回值 有返回值的函数，必须有明确的return终止语句。除非有panic或者无break的死循环，才可以没有return语句。
func TestReturn(x int) int { for { break } } 命名返回值和参数一样，可当作函数局部变量使用，最后由return隐式返回。但是，这些特殊的“局部变量”可能会被不同层级的同名变量遮蔽，此时需要显式return返回。
func Add(x, y int) (z int) { { z := x &#43; y //重新定义新的变量 	return z //因为有遮蔽作用，所有不可以直接使用隐式return，而需要显式的返回一个值，这相当于将新的z赋值给旧的z 	} return }  匿名函数 匿名函数如其名字一样，表示没有名字的函数。在定义匿名函数时，参数列表的第一对括号必须紧挨着关键字func，因为匿名函数没有名字，花括号{}涵盖着函数体，所以最后的一对圆括号()表示对该匿名函数的调用。
可以在函数内部定义匿名函数，形成类似嵌套的效果，①匿名函数可以直接调用;②或者保存到变量，作为参数或返回值。func main() { func() { //匿名函数开始 	sum = 0.0 for i := 1; i &amp;lt;= 1e6; i&#43;&#43; { sum &#43;= i } }() //表示调用 } 将匿名函数赋值给变量，与为普通函数提供名字标识符有着本质区别，编译器会为匿名函数生成一个随机符号名。
add := func(x, y int) int { return x &#43; y } println(add(23, 34)) 匿名函数可以作为参数。如下所示，相当于给匿名函数取了一个名字。
func add(f func()) { f() } func main() { add(func() { println(&amp;#34;hello,world!&amp;#34;) }) } 在Go中不使用的匿名函数会被编译器当作错误。
在Go中普通函数和匿名函数都可作为结构体字段，或经通道传递，因为函数是一等公民。
 闭包 匿名函数同样被称之为闭包（函数式编程语言的术语）：它们被允许调用定义在其它环境下的变量。闭包可使得某个函数捕捉到一些外部状态，例如：函数被创建时的状态。另一种表示方式为：一个闭包继承了函数所声明时的作用域。这种状态（作用域内的变量）都被共享到闭包的环境中，因此这些变量可以在闭包中被操作，直到被销毁。
在Go中闭包函数保存并积累其中的变量的值，不管外部函数退出与否，它都能够继续操作外部函数中的局部变量。
func main() { var f = Adder() fmt.Print(f(1), &amp;#34; - &amp;#34;) fmt.Print(f(20), &amp;#34; - &amp;#34;) fmt.Print(f(300)) //输出结果为：1-21-321 } func Adder() func(int) int { var x int return func(delta int) int { x &#43;= delta return x } } 在闭包中使用到的变量可以是在闭包函数体内声明的，也可以是在外部函数声明的：
var g int go func(i int) { s := 0 for j := 0; j &amp;lt; i; j&#43;&#43; { s &#43;= j } g = s }(1000) // Passes argument 1000 to the function literal. 一个返回值为另一个函数的函数可以被称之为工厂函数，这在需要创建一系列相似的函数的时候非常有用：书写一个工厂函数而不是针对每种情况都书写一个函数。
可以返回其它函数的函数和接受其它函数作为参数的函数均被称之为高阶函数，是函数式语言的特点。
闭包只是在形式和表现上像函数，但实际上不是函数。函数是一些可执行的代码，这些代码在函数被定义后就确定了，不会在执行时发生变化，所以一个函数只有一个实例。
闭包在运行时可以有多个实例，不同的引用环境和相同的函数组合可以产生不同的实例。
所谓引用环境是指在程序执行中的某个点所有处于活跃状态的约束所组成的集合。其中的约束是指一个变量的名字和其所代表的对象之间的联系。
那么为什么要把引用环境与函数组合起来呢？这主要是因为在支持嵌套作用域的语言中，有时不能简单直接地确定函数的引用环境。这样的语言一般具有这样的特性：
  函数是一阶值（First-class value），即函数可以作为另一个函数的返回值或参数，还可以作为一个变量的值。
  函数可以嵌套定义，即在一个函数内部可以定义另一个函数。
   延迟调用 语句defer向当前函数注册稍后执行函数调用，这些调用被称为延迟调用，因为它们直到函数执行结束前才被执行「遇到return或者panic也会触发延迟调用」。延迟调用常用于资源的释放，解除锁定，以及错误处理等操作。
  延迟调用注册时，必须提供执行所需参数(哪怕为空),参数值在注册时被拷贝缓存起来。
  多个延迟注册按照FILO(后进先出)次序执行。
  编译器通过插入额外指令来实现延迟调用执行，而return和panic语句会终止当前函数流程，引发延迟调用。
  在Go中，return语句不是ret汇编指令，它会先更新返回值。即Go中函数的return value不是原子操作，而是在编译器中分解为两部分：返回值赋值 和 return。而defer刚好被插入到末尾的return前执行。
func TestDefer() (z int) { defer func() { fmt.Println(&amp;#34;defer&amp;#34;, z) //100 	z &#43;= 100 }() return 100 //先将100赋值给z，然后执行defer函数，最后返回200 } 相比于直接使用CALL指令调用函数，延迟调用则花费更大代价，包括注册、调用等操作，还有额外的缓存开销。
var m sync.Mutex func call() { m.Lock() m.Unlock() } func deferCall() { m.Lock() defer m.Unlock() } func BenchmarkCall(b *testing.B) { for i := 0; i &amp;lt; b.N; i&#43;&#43; { call() } } func BenchmarkDefer(b *testing.B) { for i := 0; i &amp;lt; b.N; i&#43;&#43; { deferCall() } }  error 标准库将 error定义为接口类型，以便实现自定义错误类型。
type error inferface{ Error() string //只要实现了该方法，就认为是自定义的接口类型  } 按照惯例error总是最后一个返回参数，标准库提供了相关创建函数，可方便地创建包含简单错误文本的error对象
var errDivByZero = errors.New(&amp;#34;division by zero&amp;#34;) func div(x,y int)(int, error){ if y ==0{ return 0,errDivByZero } return x/y,nil } func TestDiv(){ z,err:= div(5,0) if err == errDivByZero{ log.Fatalln(err) } fmt.Println(z) } 如果要自定义错误类型，则只要实现Error方法就可以type DivError struct { x,y int } func(DivError) Error() string{ return &amp;#34;division by zero&amp;#34; } func div1(x,y int)(int,error){ if y==0 { return 0,DivError{x,y} } return x/y,nil } 通常建议应该通过错误变量，而非错误文本内容来判定错误类型。
 panic和recover 与error相比，panic/recover在使用上更接近try/catch。它们是内置函数而非语句。panic会立即中断当前函数流程，执行延迟调用。而在延迟调用函数中，recover可捕获并返回panic提交的错误对象。
func panic(v interface{}) func recover() interface{} func TestPanic(){ defer func(){ if err:=recover();err !=nil{ log.Fatalln(err) } }() panic(&amp;#34;I am dead&amp;#34;) println(&amp;#34;exit&amp;#34;) //不会被执行 }   连续调用panic，仅最后一个panic会被recover捕获
  在延迟函数调用panic，不会影响后续延迟调用执行，而recover之后panic，可被再次捕获。
  recover必须在延迟调用函数中执行才能正常工作。
  除非是不可恢复性，导致系统无法正常工作错误，否则不建议使用panic。
  调试阶段，可使用runtime/debug.PrintStack函数输出完整调用堆栈信息。
   </content>
    </entry>
    
     <entry>
        <title>Go 表达式</title>
        <url>https://iihui.github.io/post/go-expression/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>Go</tag>
        </tags>
        <content type="html"> 运算符 在Go中，一元运算符优先级最高，二元则分为5个级别，二元运算符遵循相同优先级从左到右依次计算，二元运算符从高到低的5个等级为：
* / % &amp;lt;&amp;lt; &amp;gt;&amp;gt; &amp;amp; &amp;amp;^
&#43; - | ^
== != &amp;lt; &amp;lt;= &amp;gt; &amp;gt;=
&amp;amp;&amp;amp;
||
二元运算符中除了移位操作外，操作数类型必须相同。如果其中一个是无显式类型声明的常量（该常量声明时，没有给出类型），那么该常量操作数会自动转型。
在Go中，位移右操作数必须是无符号整数，或可以转换的无显式类型常量（用整数字面值来定义常量时，未指定常量的类型）。
b := 23 x := 1 &amp;lt;&amp;lt; b // 错误，b的类型是int，使用简短模式声明的是变量 自增与自减「只有后置&#43;&#43;与后置--」不再是运算符，只能作为独立语句，不能用于表达式,也就是不能作为if中的condition，这与其他语言有很大的区别。
a := 1 //&#43;&#43;a //错误，只有后置&#43;&#43;与--  if a&#43;&#43; &amp;gt; 1{ //❌，不能作为表达式 } p := &amp;amp;a *p&#43;&#43; //优先级一样等价于(*p)&#43;&#43;  指针类型 指针类型支持相等运算符，但不支持做加减运算和类型转换。
指针没有专门指向成员的-&amp;gt; 运算符，统一使用.来选择表达式，编译器会自动做转换。
零长度对象的地址是否相等和具体的实现版本有关，但是绝对不等于nil。
var a, b struct{} print(&amp;amp;a, &amp;amp;b) //xc420039f56 0xc420039f56 fmt.Println(&amp;amp;a == &amp;amp;b, &amp;amp;a == nil) //true false  复合类型初始化 对复合类型（数组、切片、字典、结构体）变量初始化时，要遵循如下原则
  初始化表达式必须包含类型标签。
  左花括号必须在类型尾部，不能另起一行。
  多个成员初始值以逗号分隔。
  允许多行，但每行须以逗号或者右花括号结束。
   流控制 Go语言中仅支持三种控制语句，分别是if、switch、for。不同于其他语言，这3种控制语句中均可以有预处理语句「大多数情况下是变量定义」。
if 语句 if条件表达式可以省略括号「推荐的做法」；并且条件表达式的值必须是布尔类型；其中左括号不能另起一行。x := 3 if x &amp;gt; 3 { fmt.Println(&amp;#34;A&amp;#34;) } else if x &amp;lt; 3 &amp;amp;&amp;amp; x &amp;gt; 0 { fmt.Println(&amp;#34;B&amp;#34;) } else { fmt.Println(&amp;#34;C&amp;#34;) } if中的条件判断语句之前：①允许声明一个变量；②执行函数调用。在预处理语句和条件语句间，它们使用分号分隔。如果是变量定义的话，这个变量的作用域只能在该条件逻辑块中，既包括if又包括else。
if a,b := x&#43;1,x&#43;10; a&amp;lt;b{ fmt.Println(a,b) }else { fmt.Println(&amp;#34;Test&amp;#34;) } if InitIF(); x &amp;lt; 10{ fmt.Println(&amp;#34;initif&amp;#34;) } func InitIF(){ fmt.Println(&amp;#34;Init&amp;#34;) }  switch语句 一个case中可以有多个匹配条件，此时只要匹配其中一个就可以了。对于case是常量的情况，不能有重复的情况：
a, b, c, x := 1, 2, 3, 2 switch x { case a, b: fmt.Println(&amp;#34;a|b&amp;#34;) case c: fmt.Println(&amp;#34;c&amp;#34;) case 4: fmt.Println(&amp;#34;d&amp;#34;) default: fmt.Println(&amp;#34;z&amp;#34;) } switch中的条件表达式支持非常量值，这比C和C&#43;&#43;更灵活
switch支持初始化语句，按从上往下匹配，只有全部匹配失败时才执行default块,不会因为default语句在前面就先匹配default块。考虑到default的作用相当于else，所以建议将其放到末尾。
switch y := 5; y { default: y &#43;= 100 fmt.Println(y) case 5: y &#43;= 50 fmt.Println(y) } //55 不能出现重复的case常量值；相邻的空case不构成多条件匹配「这个与C和C&#43;&#43;有明显的区别」
无需显式执行break语句，case执行完毕后自动中断。
如需贯通后续case （按照源码顺序) 必须执行fallthrough,但不再匹配后续条件表达式，而且fallthrough必须放在case块末尾，可使用break语句阻止。switch z := 20; z { default: fmt.Println(&amp;#34;default&amp;#34;) case 20: z &#43;= 10 fmt.Println(z) fallthrough //必须是case语句块的最后一条语句 case 21: z &#43;= 88 fmt.Println(z) } // 30 118  switch z := 20; z { case 20: z &#43;= 10 fmt.Println(z) fallthrough //必须是case语句块的最后一条语句 case 21: z &#43;= 88 fmt.Println(z) default: fmt.Println(&amp;#34;default&amp;#34;) } // 结果仍然是30 118 其中default语句不会执行 被省略条件表达式的switch，其表达式的默认值为true。这种情况，可以用来替换if语句
switch z1 := 5; { case z1 &amp;gt; 5: fmt.Println(&amp;#34;z1&amp;gt;5&amp;#34;) case z1 &amp;gt; 0 &amp;amp;&amp;amp; z1 &amp;lt;= 5: fmt.Println(&amp;#34;z1&amp;gt;0 &amp;amp;&amp;amp; z1&amp;lt;=5&amp;#34;) case z1 &amp;lt;= 0: fmt.Println(&amp;#34;z1&amp;lt;=&amp;#34;) default: fmt.Println(&amp;#34;Test&amp;#34;) } //z1&amp;gt;0 &amp;amp;&amp;amp; z1&amp;lt;=5  for语句 for语句，包括一般的for语句和 for range 语句。一般的for语句包括3种情况：①有初始化语句和条件判断语句的；②只有条件判断语句的；③既没有初始化语句也没有条件判断语句的。
for i := 1; i &amp;lt; 10; i&#43;&#43; { println(i) } x1 := []int{12, 34, 78, 9, 22, 7, 9} //切片  for i, n := range x1 { println(i, &amp;#34;:&amp;#34;, n) } for x &amp;lt; 5 { println(x) x&#43;&#43; } for { println(x) x-- if x == 0 { break } } 初始化表达式支持函数调用或定义局部变量，其中初始化语句仅被执行一次，条件表达式如果有函数调用，须确认是否会被重复执行，可能会被编译器优化掉，也可能动态结果须每次执行确认。
func TestFor() { for i, c := 0, count(); i &amp;lt; c; i&#43;&#43; { println(&amp;#34;a&amp;#34;, i) } c := 0 for c &amp;lt; count() { println(&amp;#34;b&amp;#34;, c) c&#43;&#43; } } func count() int { print(&amp;#34;count.&amp;#34;) return 3 } 可用for ...range 完成数据迭代，支持字符串、数组、数组指针、切片、字典、通道类型，返回索引、键值数据。 range目标表达式是函数调用，也仅被执行一次。
data := [3]string{&amp;#34;a&amp;#34;, &amp;#34;b&amp;#34;, &amp;#34;c&amp;#34;} for i, s := range data { println(i, s) } for i := range data { println(i, data[i]) } for _, s := range data { println(s) } for range data { //清空data } fmt.Println(data)  break与continue break用于switch，for，select语句终止整个语句块执行
continue仅用于for循环，终止后续逻辑，立即进入下一轮
配合标签，break和continue可在多层嵌套中指定目录层级
outer: for x := 0; x &amp;lt; 10; x&#43;&#43; { for y := 0; y &amp;lt; 10; y&#43;&#43; { if y &amp;gt; 2 { println() continue outer } if x &amp;gt; 2 { break outer } println(x, y) } }  </content>
    </entry>
    
     <entry>
        <title>Go 枚举</title>
        <url>https://iihui.github.io/post/go-iota/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>Go</tag>
        </tags>
        <content type="html">  Go中没有定义枚举变量，但是可以借助iota来生成一组自增常量值来实现枚举，iota是一个比较奇怪的存在，它只能用在const的声明中，是一个从0开始的行数索引器。
 注意 首先，iota是一个行数索引器,它是按行递增的。
const ( x1 = iota //x1=0 	x2 //x2=1 	x3 //x3=2 	x4 //x4=3 ) fmt.Println(x1, x2, x3, x4) //0,1,2,3  const ( _ = iota //iota 代表0 	KB = 1 &amp;lt;&amp;lt; (10 * iota) //iota 代表1 	MB //iota 代表2 	GB ) fmt.Println(KB, MB, GB) //1024 1048576 1073741824 如果中断iota自增，则必须显式恢复，且后续自增按行序递增，而不是C&#43;&#43;语言中的enum那样按上一个取值递增。
const ( a = iota b c = 100 //中断iota的计数 	d //100 	e = iota //4，显式恢复，因为是行增，所以得到是4 	f //5 ) fmt.Println(a, b, c, d, e, f) //0 1 100 100 4 5 可在多常量中定义中使用多个iota，他们是各自单独计数，只须确保组中每行常量的列数量相同即可。
const ( _, _ = iota, iota a, b c, d ) fmt.Println(a, b, c, d) // 1 1 2 2 const中的iota自增默认数据类型是int，但也可显式指定类型。
const ( x = iota y float32 = iota //指定类型 	z = iota ) fmt.Println(x, y, z) //0 1 2  </content>
    </entry>
    
     <entry>
        <title>Go 常量</title>
        <url>https://iihui.github.io/post/go-const/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>Go</tag>
        </tags>
        <content type="html">  常量是一种表达式，其可以保证在编译阶段计算出表达式的值，并不需要等到运行时，从而使编译器得以知晓其值。所有常量本质上都属于基本类型：布尔型，字符串或数字。
 特别说明 Go中常量可以是任意基本类型，也包括具名的基本类型(例如time.Duration)。但是许多常量并不从属某一具体类型。编译器将这些从属类型待定的常量表示成某些值，这些值比基本类型的数字精度更高，且算术精度高于原生的机器精度，可以认为它们的精度至少达到256位。从属类型待定的常量共有6种，分别是：①无类型布尔；②无类型整数；③无类型文字符号(例如&#39;a&#39;)；④无类型浮点数；⑤无类型复数；⑥无类型字符串。
借助推迟确定从属类型，无类型常量不仅能够暂时维持更高的精度，与类型已确定的常量相比，还能写进更多的表达式无需类型转换。
在Go中只有常量才可以是无类型的。如果将无类型的常量声明为变量或者在类型明确的变量赋值的右方出现无类型的常量，则常量会被隐式转换为该变量的类型：
var f float64=3&#43;0i //无类型复数-&amp;gt;float64 f=2 //无类型整数-&amp;gt;float64 f=1e123 //无类型浮点数-&amp;gt;float64 f=&amp;#39;a&amp;#39; //无类型文字符号-&amp;gt;float64 不论隐式转换还是显式转换，常量从一种类型转换为另一种类型，都要求目标类型能够表示原值，实数和复数允许舍入取整。
const ( x =0xdeadbeef //无类型整数，值为3735928559  a = uint32(x) //unit32,值为3735928559没有超出范围  b = float32(x)//float32,值为3735928559  c = int32(x) //编译错误，溢出  d = float64(1e309) //编译错误，溢出  f = uint(-1) //编译错误，溢出，unit无法容纳-1  ) 变量声明时（包括简短声明）中，假如没有显式指定类型，无类型常量会隐式转换为该变量的默认类型。对于bool型来说为false，对于整型、浮点、复数来说为0，字符串为“”，引用类型为nil，复合类型为其基础类型的零值。
i:=0 //无类型整数，隐式int(0） r:=&amp;#39;\000&amp;#39; //无类型文字常量，隐式rune(&amp;#39;\000&amp;#39;)，这个要记住 f:=0.0 //无类型浮点数，隐式float64(0.0) c:=0i //无类型整数，隐式complex128(0i)  注意事项 常量必须是编译期可确定的字符、字符串、数字或布尔值。可指定常量类型，或由编译器通过初始化值推导，不支持C/C&#43;&#43;的数字类型后缀。
定义常量的时候必须初始化，否则编译错误。不同于未使用的局部变量，不使用的常量不会引起编译错误。const x = 123 fmt.Println(x) const y = 1.23 { const x = &amp;#34;abc&amp;#34; fmt.Println(x) } 对于常量操作数，所有数学运算、逻辑运算和比较运算的结果依然是常量。常量的类型转换结果和某些内置函数的返回值，例如len,cap,real,imag,complex,unsafe.Sizeof同样是常量，因此可以将这些函数作用于常量用于常量的初始化。
在常量组中，如果不指定类型和初始化值，则与上一行非空常量右值（表达式文本）相同const ( x uint16 = 120 y s = &amp;#34;abc&amp;#34; z ) fmt.Println(x, y, s, z) //120,120,abc,abc 数字常量在预处理阶段直接展开，作为指令数据使用，不分配内存，因此无法获取地址package main const y = 0x200 func main() { println(y) //println(&amp;amp;y) // 错误，不能获取地址，这与C&#43;&#43;有很大的区别 } const t = y //同样无法获取t的地址 const x = 100 //x没有明确指定类型，也就是前面说的待定类型 const y byte = x //直接展开x，相当于const y byte = 100 如果显式指定类型，必须确定常量左右值类型一致，需要时可做显式转换，右值不能超出常量类型取值范围，否则会引起溢出错误。const ( t1, t2 int = 99, -999 t3 byte = byte(t1) //t1 指定为int型，需显式转换为byte类型，注意于上一个例子的区别 	//t4 = uint8(t2) // 常量-999,超出了unit8的范围，会报溢出错误 ) 常量值可以是某些编译器能计算出结果的表达式，如 unsafe.Sizeof、len、cap，不能是运行时才能计算出结果的表达式。因此len，cap等内置函数用于定义常量时，不能作用于变量。
const ( ptrSize = unsafe.Sizeof(uintptr(0)) //8 	strSize = len(&amp;#34;hello world!&amp;#34;) //12 	)  </content>
    </entry>
    
     <entry>
        <title>Go 变量定义</title>
        <url>https://iihui.github.io/post/go-var/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>Go</tag>
        </tags>
        <content type="html"> Go中每一个文件都以package声明开头，表明文件属于哪一个包。package声明后面是import声明，然后是不区分顺序的包级别的类型，变量、常量和函数的声明。包级别的实体名字不仅对于包含其声明的源文件可见，而且对于同一包里面的所有的源文件可见。
变量命名   以字母（这里指的是广义字母，只要能够被unicode编码即可）或下划线开始，由多个字母，数字下划线组合而成。
  在Go中变量的标识符是区分大小写。
  习惯上对变量标识符使用驼峰命名法。
  习惯上Go对专有名词通常会全部大写（这样一来这个专有名词就是可导出的了）。
  有一个名为_的特殊成员（称为空占位符），通常作为忽略占位符使用，可以用作表达式左值，但无法读取内容，即空标识符只写不读的。
  空标识符可用来临时规避编译器对未使用变量和导入包的错误检查，但是它是预置成员，不能重新定义。 导入包时使用空标识符的目的是为了使用包中初始化函数以进行初始化，而一般的变量定义中使用空标识符是为了舍弃错误的处理（一般是举例子的时候使用，不建议这么做，因为出现错误时我们应当处理）。
  符号名首字母大小写决定了其作用域，首字母大写的为导出成员，可被外部不同的包使用，而小写仅能在包内使用。
   变量声明 变量的声明方式有3种：①使用var关键字声明变量； ②使用简短模式； ③使用new函数来声明变量。
使用var定义变量 Go是一种静态类型语言，所以变量总是有数据类型，类型决定了变量的内存长度和存储格式。
var声明一个具体类型的变量，然后给它附加一个名字，设置它的初始值，每一个声明有一个通用的形式：
var name type=expression 这里的类型和表达式可以省略一个，但是不能全部省略。如果类型省略，那么变量的类型由表达式决定；如果表达式省略，则变量的初始值对应其类型零值。
类型零值：对于数字是0，对于布尔型是false，对于字符串是“”，对于接口和引用类型（slice，指针，map，通道，函数）是nil。而对于数组，结构体这样的复合类型，零值是其所有元素或成员的零值。
  使用var定义变量，类型放在变量名后面var x int。这样的好处是定义多个指针变量时，不必每次都声明是指针变量。
  使用var进行变量定义的时候，可以使用初始值。使用初始值时，可以省略类型，Go会自动进行类型推导，例如var x=12 此时x的类型被推导为int。
  同样可以一次可以定义多个变量，使用逗号隔开:  var x,y int。
  可以使用成组的方式定义个多个或多种变量，即使用一个var定义多个多种类型的变量：
var ( x,y int a,s=100,&amp;#34;abc&amp;#34; //这一句定义了两个变量，并且类型不相同 ) fmt.Println(x,y,a,s) ////0 0 100 abc   赋值操作必须确保左右值类型相同，（有3种情况例外，详见基本类型中的类型转换规则）如果等式两边的类型不同则会出现编译错误。
  编译器将未使用「重新赋值不算做使用」的局部变量当作错误处理。全局定义的变量如果未使用，编译器不会报错；局部定义的变量一定要使用，并且重新赋值不算是使用。
  编译器确保变量总是被初始化类型0值，在函数内部还可以使用简略形式来定义变量。
var s = &amp;#34;hello world&amp;#34; // 使用类型推导，编译器将s的类型推导为string y := make([]int, 0, 5) //函数内部省略 var 关键字，更简单的模式 fmt.Println(y) //y是切片类型 for i := 0; i &amp;lt; 10; i&#43;&#43; { y = append(y, i) //追加后重新赋值  } fmt.Println(y) //[0 1 2 3 4 5 6 7 8 9]   在Go中，var声明通常是为那些与初始化表达式类型不一致的局部变量保留的，或者用于后面才对变量赋值以及变量初始值不重要的情况。
   简短模式定义变量 还可以使用例如 x := 100这样的简短模式声明变量,但是简短模式具有以下限制：
  必须使用显式初始化。
  简短模式不能提供数据类型，Go会按照进行类型推导。
  只能在函数内部使用简短模式。
  简短模式并不总是变量定义，也可能是部分退化的赋值操作，退化赋值的前提是：至少有一个新变量被定义，且必须是同一作用域。
func test() { x1 := x &#43; 100 if x1 &amp;gt; 0 { println(&amp;#34;x&amp;#34;) } else { println(&amp;#34;-x&amp;#34;) } x1, y := 200, &amp;#34;abc&amp;#34; // x1 是重新赋值，y是变量定义 	fmt.Println(x1, y) } 多变量赋值操作时，总是首先计算出所有的右值，然后再依次完成赋值操作，即并行赋值。
x, y := 1, 2 x, y = y&#43;3, x&#43;2 //先计算出右值y&#43;3,x&#43;2,然后再依次完成赋值操作 fmt.Println(x, y)  使用new函数定义变量 new函数是Go中内置的函数，表达式new(T)创建一个未命名的T类型变量，初始化为T类型的零值，并返回其指针。
使用new创建的变量和取其地址的普通变量没有什么不同，只是不需要引入一个虚拟名字，因此new（T）只是在语法上的便利。下面两个newInt函数有同样的行为：
func newInt() *int { return new(int) } func newInt() *int { var dummy int return &amp;amp;dummy }  </content>
    </entry>
    
     <entry>
        <title>Go 基本类型</title>
        <url>https://iihui.github.io/post/go-type/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>Go</tag>
        </tags>
        <content type="html"> Go语言中定义了清晰完备的预定义基本类型（共21类），使得开发跨平台应用时无须过多考虑符号和长度差异，具体如下表：
![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-12-21 下午2.36.532.jpg)
 整型数据   十进制整数，使用0-9的数字表示且不以0开头。
  八进制整数，以0开头，0-7的数字表示。
  十六进制整数，以0X或者是0x开头0-9|A-F|a-f组成。
a,b,c:=100,0144,0x64 fmt.Println(a,b,c) //100 100 100 //打印的时候默认是10进制 fmt.Printf(&amp;#34;0b%b, %#o,%#x\n&amp;#34;,a,a,a) //0b1100100, 0144,0x64 //%#b可以打印二进制，但是为了区分在前面条件0b fmt.Printf(&amp;#34;0b%#b,0b%b&amp;#34;,a,a) fmt.Println(math.MinInt8,math.MaxInt8) //-128,127   标准库strconv可在不同进制（字符串）间转换。
x,_:=strconv.ParseInt(&amp;#34;1100100&amp;#34;,2,32) //解释给定字符，2表示字符串是的基数是2，即以2进制表示， //32表示给出的结果至少要适应32位，返回值的类型为int64 y,_:=strconv.ParseInt(&amp;#34;0144&amp;#34;,8,32) //字符串是8进制 z,_:=strconv.ParseInt(&amp;#34;64&amp;#34;,16,32) //字符串是16进制  fmt.Println(x,y,z) //100 100 100  fmt.Println(strconv.FormatInt(x,2)) //1100100,转换为2进制表示 fmt.Println(strconv.FormatInt(x,8)) //0144，转换为8进制表示 fmt.Println(strconv.FormatInt(x,16)) //64，转换为16进制表示   默认整数类型是int，不同类型之间的运算需要进行强制类型转换。
a : = 10 b ：= byte(100) //100的默认类型是int，如果要使得b的类型为byte，那么就要用强制类型转换 c := a &#43; int(b) //a 和 b是不同的数据类型，因此要转换成一致的数据类型    浮点型 浮点数由整数部分、小数点和小数部分组成，整数部分和小数部分可以隐藏其中一种。也可以使用科学计数法表示（把一个数表示成$a$（$1\le a \lt 10，n$为整数）与10的幂相乘的形式，这种记数法叫做科学记数法）。
     72.40 072.40 和 72.40一样，这里就不区分8进制与10进制，浮点数的数字就全部是10进制了 2.71823 6.67428e-11 1E6 //这个也是浮点数 .25 .12345E&#43;5  浮点数的默认类型是float64，使用时需要注意小数点的位置。float32保证7位有效数字「小数点后7位」，float64保证15位有效数字「小数点后15位」。具体细节参见IEEE-754标准。
var a float32 = 1.1234567899 //保证小数点后7位有效数字 var b float32 = 1.12345678 //保证小数点后7位有效数字 var c float32 = 1.123456781 //保证小数点后7位有效数字  fmt.Println(a, b, c) // 1.1234568 1.1234568 1.1234568 fmt.Println(a == b, b == c) //true true 因为保证7位有效数字—小数点后7位 fmt.Printf(&amp;#34;%v %v %v\n&amp;#34;, a, b, c) //1.1234568 1.1234568 1.1234568  复数类型 由一个整数或者是一个小数加上i表示，在Go中它的默认类型是complex128即64位实部分&#43;64位虚部，虚部如下所示：
 0i 011i //==11i 这里不是八进制了，和浮点数一样，数字均表示10进制 0.i 2.71825i 6.23423-11i 1E&#43;6i .25i .1234E&#43;5i   引用 特指slice，map，channel这三种预定义类型，引用类型具有更复杂的存储结构，除分配内存外，还必须初始化一系列属性，诸如指针、长度、甚至包括哈希分布，数据队列等。
内置函数new按指定类型长度分配零值内存，返回指针，并不关心类型内部构造和初始化方式。而引用类型必须使用make函数创建，编译器会将make转换为目标类型专用的创建函数（指令）以确保完成全部内存分配和相关属性初始化。
m := make(map[string]int) m[&amp;#34;a&amp;#34;] = 1 fmt.Println(m) //map[a:1] s := make([]int, 0, 10) s = append(s, 100) fmt.Println(s) //[100] new函数也可以为引用类型分配内存，但是不完整创建。 以字典为例，它仅分配了字典本身所需的内存，并没有分配键值存储内存，也没有初始化散列桶等内部属性，因此无法正常工作
p := new(map[string]int) t := *p //t[&amp;#34;a&amp;#34;] = 100 //fmt.Println(t) //panic: assignment to entry in nil map  别名 在官方文档中，专门提到了两个别名 byte alias for unit8以及rune alias for int32
  别名类型无需转换，可直接赋值。别名的作用是为了“见型知意”
  拥有相同底层结构的就不一定是别名，就算在64位平台上int和int64结构完全一致，但是这两个也分属不同类型，这两个类型参与运算时须显式转换。   未命名类型（8种） 在Go中 数组、切片、字典、通道类型与具体元素类型或长度属性相关，故被称为未命名类型。具有相同声明的未命名类型被称为同一类型。
  具有相同基类型的指针
  具有相同元素类型和长度的数组array
  具有相同元素类型的切片slice
  具有相同键值类型的字典map
  具有相同数据类型以及操作方向的通道channel
  具有相同字段序列（字段名、字段类型、标签以及字段顺序）的结构体struct
  具有相同签名的（参数和返回值列表，不包括参数名）的函数func，其中函数的参数顺序也属于签名的组成部分
  具有相同方法集（方法名，方法签名，不包括顺序）的接口
  容易被忽略的是结构体的标签struct tag 它属于类型组成的一部分，而不仅仅是元数据描述
var a struct { x int `x` s string `s` } var b struct { x int s string } b = a //这是错误的，因为一个有标签，另一个没有标签 fmt.Println(b)  指针 指针的默认值是nil，不支持加减操作和类型转换，只支持相等判断,这一点与C和C&#43;&#43;有很大区别
x := 100 p := &amp;amp;x //p&#43;&#43; //不能加 //p&#43;1 //不能加，只能比较是否相等 var p2 = p fmt.Println(p2 == p) //true 在指针的比较中，如果两个指针指向同一个地址，或都为nil则相等 接口 接口定义了一个函数集合，但是这些方法不包括实现——它们是抽象的，接口里也不能含变量。
 自定义类型 使用关键字type 定义用户自定义类型，包括基于现有基础类型创建，或者是结构体、函数类型。与const和 var类似，多个type定义可以合并为组，可在函数或者代码块内定义局部类型
type ( user struct { name string age uint8 } event func(string) bool ) 当自定义类型指定了基础类型时，也只表明他们具有相同的底层数据结构，两者间不存在任何关系，属于完全不同的两种类型，不能直接进行赋值操作。
除了操作符外，自定义类型不会继承基础类型的其他信息（包括方法），不能视作别名，不能隐式转换，不能直接用于比较表达式。
type X int var m X = 23 if m &amp;lt; 100 { //继承操作符 	fmt.Println(&amp;#34;Test&amp;#34;) }  类型转换 因为隐式转换带来的问题远大于它带来的好处，Go中严格按照类型进行操作。当两个变量的类型不一致的时候要做强制类型转换。
  除了常量、别名类型以及未命名类型外，Go强制要求使用显式类型转换
  Go中不支持操作符重载  如果转换的目标类型是指针、单向通道或没有返回值的函数类型，那么必须用括号，以避免造成语法分解错误
x := 100 p := (*int)(&amp;amp;x)    </content>
    </entry>
    
     <entry>
        <title>memcpy 的实现</title>
        <url>https://iihui.github.io/post/cpp-memcpy/</url>
        <categories>
          
        </categories>
        <tags>
          <tag>C&#43;&#43;</tag>
        </tags>
        <content type="html"> 地址重叠 void *memcpy(void *dst, const void *src, size_t n); //If copying takes place between objects that overlap, the behavior is undefined.   注意注释，对于地址重叠的情况，该函数的行为是未定义的。事实上所说的陷阱也在于此，自己动手实现memcpy时就需要考虑地址重叠的情况。
  另外，标准库也提供了地址重叠时的内存拷贝函数：memmove，那么为什么还要考虑重写memcpy函数呢?
  因为memmove函数的实现效率问题，该函数把源字符串拷贝到临时buffer里，然后再从临时buffer里写到目的地址，增加了一次不必要的开销。
   自实现版本 当可能会发生重叠时，应该从后往前拷贝，类似于vector的插入时当插入点的元素大于要插入的元素个数时。
#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt;#include &amp;lt;string.h&amp;gt; void *Memcpy(void *dst, const void *src, size_t size); int main(int argc, char *argv[]) { char buf[100] = &amp;#34;abcdefghijk&amp;#34;; // memcpy(buf&#43;2, buf, 5);  Memcpy(buf &#43; 2, buf, 5); printf(&amp;#34;%s\n&amp;#34;, buf &#43; 2); } void *Memcpy(void *dst, const void *src, size_t size) { char *psrc; char *pdst; if (NULL == dst || NULL == src) { return NULL; } if ((src &amp;lt; dst) &amp;amp;&amp;amp; (char *)src &#43; size &amp;gt; (char *)dst) // 自后向前拷贝  { psrc = (char *)src &#43; size - 1; pdst = (char *)dst &#43; size - 1; while (size--) { *pdst-- = *psrc--; } } else { psrc = (char *)src; pdst = (char *)dst; while (size--) { *pdst&#43;&#43; = *psrc&#43;&#43;; } } return dst; }  </content>
    </entry>
    
     <entry>
        <title>基本排序算法</title>
        <url>https://iihui.github.io/post/arith-sort/</url>
        <categories>
          <category>算法</category>
        </categories>
        <tags>
          <tag>算法</tag>
        </tags>
        <content type="html"> 基本概念   排序算法的稳定性：如果待排序的数据中，存在多个关键字相同的元素，经过排序后这些具有相同关键字的元素之间的相对次序保持不变，则称这种排序算法是稳定的，反之则为不稳定。
  内排序：排序过程中，整个表都是放在内存中处理，排序时不涉及数据的内、外交换。
  外排序：指能够处理极大量数据的排序算法，外排序处理的数据不能一次装入内存，只能放在读写较慢的外存储器(通常是硬盘)上，外排序通常采用的是一种 排序-归并 的策略。在排序阶段，先读入能放在内存中的数据量，将其排序结果输出到一个临时文件，依此进行，将待排序数据组织为多个有序的临时文件。然后在归并阶段将这些临时文件组合为一个大的有序文件，即排序结果。
   内排序算法 一般说来，内排序算法可以分为7类，分别为：
  插入排序
  交换排序
  选择排序
  归并排序
  基数排序
  桶排序
  计数排序
   插入类排序 直接插入排序 直接插入排序，是在有序的基础上对数据元素进行直接插入，代码如下所示：
template&amp;lt;typename T&amp;gt; void innerSort&amp;lt;T&amp;gt;::insertSort(T *data, int length) { assert(length &amp;gt;= 0); int curItem, j; for (int i = 1; i &amp;lt; length; &#43;&#43;i) { curItem = data[i]; for (j = i - 1; j &amp;gt;= 0; --j) { if (curItem &amp;lt; data[j]) { data[j &#43; 1] = data[j]; } else { break; } } data[j &#43; 1] = curItem; //j&#43;1是最终位置  } }   最好情况为待排序序列是正序的时候，比较次数为$(n-1)$次，移动次数$2(n-1)$次，时间复杂度：$O(n)$。
  最坏情况为待排序序列是逆序的时候，比较次数 $（1&#43;2&#43;3&#43;&amp;hellip;&#43;(n-1))=\frac{n(n-1)}{2}$，移动次数 $(1&#43;2&#43;&amp;hellip;&#43;(n&#43;1))=\frac{n(n&#43;1)}{2}$，时间复杂度：$O(n^2)$。
  平均时间复杂度：$O(n^2)$。
  空间复杂度：$O(1)$。
  直接插入排序不能保证一趟之后有一个元素在其最终的位置。
  直接插入是稳定的排序算法。
   折半插入排序 折半插入排序，在查找插入位置的时候使用二分查找，代码如下：
template&amp;lt;typename T&amp;gt; void innerSort&amp;lt;T&amp;gt;::binInsertSort(T *data, int length) { assert(length &amp;gt;= 0); int start, mid, end, curItem; for (int i = 1; i &amp;lt; length; &#43;&#43;i) { start = 0; end = i - 1; curItem = data[i]; while (start &amp;lt;= end) { mid = start &#43; (end - start) / 2; //尽可能地避免溢出  if (data[mid] == curItem) { end = mid; //end&#43;1便是插入位置  break; } else if (data[mid] &amp;lt; curItem) { start = mid &#43; 1; } else { end = mid - 1; } } //最终的插入位置为end&#43;1,因此需要将end&#43;1所在的元素移开  for (int j = i - 1; j &amp;gt;= end &#43; 1; --j) { data[j &#43; 1] = data[j]; } //放到最终的插入位置 end&#43;1  data[end &#43; 1] = curItem; } }   注意后面的第二个for循环中j &amp;gt;= end &#43; 1，因为最终位置是end&#43;1。
  从时间上看，折半插入排序只是减少了关键字间的比较次数，而元素的移动次数不变，因为找到位置之后还是要将元素全部移动，因此平均时间复杂度为$O(n^2)$。
  空间复杂度：$O(1)$，折半插入排序算法不稳定的的内排序算法，例如1，1，1，1进行折半插入排序时。
   Shell排序 Shell排序，又称为缩小增量排序方法。其基本思想是：把记录按下标的某个增量 $d$ 分组，对每组记录采用直接插入排序方法进行排序，随着增量逐渐缩小，所分成的组所包含的记录越来越多，到增量的值减少到$1$时，整个数据合成为一组，构成一组有序记录，则完成排序。
  先取一个正整数 $d_1(d_1 \lt n)$，把全部记录分成 $d_1$ 个组，所有距离为 $d_1$ 的倍数的记录看成一组，然后在各组内进行插入排序。
  然后取 $d_2(d_2 \lt d_1)$重复上述分组和排序操作；直到取 $d_i = 1(i \ge 1)$ 位置，即所有记录成为一个组，最后对这个组进行插入排序。一般选$d_1$约为$\frac{n}{2}$，$d_2$为$\frac{d_1}{2}$， $d_3$ 为 $\frac{d_2}{2}$ ，&amp;hellip;， $d_i = 1$。
  template&amp;lt;typename T&amp;gt; void innerSort&amp;lt;T&amp;gt;::shellSort(T *data, int length) { assert(length &amp;gt;= 0); for (int step = length / 2; step &amp;gt; 0; step /= 2) { assistShellSort(data, length, step); } } template&amp;lt;typename T&amp;gt; void innerSort&amp;lt;T&amp;gt;::assistShellSort(T *data, int length, int step) { assert(length &amp;gt;= 1 &amp;amp;&amp;amp; step &amp;gt;= 0); int j, curItem; for (int i = step; i &amp;lt; length; &#43;&#43;i) { curItem = data[i]; for (j = i - step; j &amp;gt;= 0; j -= step) { if (data[j] &amp;gt; curItem) { data[j &#43; step] = data[j]; } else { break; } } data[j &#43; step] = curItem; //j&#43;step是最终的位置  } }   Shell排序的每趟排序，都会使得整个序列变得更加有序，等整个序列基本有序了，再来一趟直接插入排序，这样会使排序效率更高。
  Shell排序不能保证一趟之后有一个元素在其最终的位置。
  Shell排序是不稳定的排序算法，例如2,2,1(d=2,1)。
  分析Shell排序是一个复杂的问题，它的时间复杂度是增量序列的函数，到现在为止还未得到数学上的解决。
   交换类排序 大数沉底冒泡 大数沉底的冒泡排序的基本流程如下：
  比较相邻的元素，如果第一个比第二个大，就交换他们两个。
  对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对，当交换到最后的时候，最后的一个元素将会是最大的数。
  除了已经找到的元素，针对所有剩下的元素重复以上的步骤。
  持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。
  //大数沉底的冒泡排序 template&amp;lt;typename T&amp;gt; void innerSort&amp;lt;T&amp;gt;::bubbleSort(T *data, int length) { assert(length &amp;gt;= 0); bool flag; //标识本趟是否有交换  for (int i = 1; i &amp;lt; length; &#43;&#43;i) { flag = false; //赋值为false表示还没有数据交换  for (int j = 0; j &amp;lt; length - i; &#43;&#43;j) { if (data[j] &amp;gt; data[j &#43; 1]) { swap(data[j], data[j &#43; 1]); flag = true; //本论循环中有数据元素进行交换  } } if (!flag) { break; //本次循环已经没有数据元素进行交换，说明已经排好序  } } }  小数沉底冒泡 如果要将原序列排序成逆序，则只要将小数沉底即可，即每次比较的时候当前元素比下一个元素小的时候将将其交换到后面。
void smallBubbleSort(int *data, int n) //小数下沉，最后得到逆序 { bool flag = false; for (int i = 1; i &amp;lt; n; &#43;&#43;i) { flag = false; for (int j = 0; j &amp;lt; n - i; &#43;&#43;j) { if (data[j] &amp;lt; data[j &#43; 1]) { std::swap(data[j], data[j &#43; 1]); flag = true; } } if (!flag) break; } }   最坏情况：待排序序列逆序，时间复杂度为$O(n^2)$。
  最好情况：待排序序列有序，时间复杂度为$O(n)$。
  平均时间复杂度为：$O(n^2)$。
  空间复杂度为$O(1)$。
  每次都能保证一个元素在最终位置。
  冒泡排序是稳定的排序算法。
   快速排序 快速排序: 它采用了一种分治的策略，将原问题分解为若干个规模更小但结构与原问题相似的子问题,然后递归地解这些子问题。最后将这些子问题的解组合为原问题的解。快速排序算法的步骤为：
  首先，在数据集之中，选择一个元素作为基准（pivot）, 基准的选择一般有3种
  随机选择数据元素作为基准元素
  选择中间的那个数据元素作为基准元素
  选择待排序序列的第一个元素作为基准元素
    其次，所有小于基准的元素，都移到基准的左边；所有大于基准的元素，都移到基准的右边。
  最后，基准左边和右边的两个子集，不断重复第一步和第二步，直到所有子集只剩下一个元素为止。
  假设数据集为{85, 24, 63, 45, 17, 31, 96, 50}，怎么对其进行排序呢？下面采用每次选择中间的那个元素作为基准元素：
  第一步，选择中间的元素45作为基准pivot。
  第二步，按照顺序将每个元素和pivot进行比较，形成两个子集，一个小于pivot，一个大于pivot：{24，17，31}，45，{85，63，96，50}。
  第三步，对两个子集不断重复第一步和第二步，直到所有子集只剩下一个元素。17，{24，31}，45，{50}，63，{85，96}。17，24，{31}，45，50，63，85，{96}。最后得到：17，24，31，45，50，63，85，96。
  第二种方式是每次选择第一个元素作为基准的算法：
void quickHelp(int *data, int start, int end) { if (start &amp;lt; end) { auto pivot = adjustByFirst(data, start, end); quickHelp(data, start, pivot - 1); quickHelp(data, pivot &#43; 1, end); } } int adjustByFirst(int *data, int start, int end) { int cur = data[start]; int i = start, j = end; while (i &amp;lt; j) { while (i &amp;lt; j &amp;amp;&amp;amp; data[j] &amp;gt;= cur) j--; if (i &amp;lt; j) { data[i] = data[j]; i&#43;&#43;: } while (i &amp;lt; j &amp;amp;&amp;amp; data[j] &amp;lt; cur) j--; if (i &amp;lt; j) { data[j] = data[i]; j--: } } data[i] = cur; return i; } 借助于栈，可以将上面的递归算法改为非递归算法：
struct Region { int start; int high; }; void noncurQuickSort(int *data, int length) { Region cur, left, right; Region stack[MAXSIZE]; int index; int top = -1; cur.start = 0; cur.high = length - 1; stack[top&#43;&#43;] = cur; while (top != -1) { cur = stack[top--]; index = partition(data, length, cur.start, cur.high); //调用随机选择基准的函数  if (index &amp;gt; cur.start) { left.start = cur.start; left.high = index - 1; stack[&#43;&#43;top] = left; } if (index &amp;lt; cur.high) { right.start = index &#43; 1; right.high = cur.high; stack[&#43;&#43;top] = right; } } } 第三个种方式是随机选择一个元素作为基准进行调整算法：
template&amp;lt;typename T&amp;gt; void innerSort&amp;lt;T&amp;gt;::quickSort(T *data, int length) { quickSort(data, 0, length - 1); } template&amp;lt;typename T&amp;gt; void innerSort&amp;lt;T&amp;gt;::quickSort(T *data, int start, int end) { if (start &amp;gt;= 0 &amp;amp;&amp;amp; start &amp;lt; end) { int pivot = getPivot(data, start, end); if (pivot &amp;gt; start) { quickSort(data, start, pivot - 1); } if (end &amp;gt; pivot) { quickSort(data, pivot &#43; 1, end); } } } template&amp;lt;typename T&amp;gt; int innerSort&amp;lt;T&amp;gt;::getPivot(T *data, int start, int end) { assert(start &amp;gt;= 0 &amp;amp;&amp;amp; start &amp;lt; end); int index = random(start, end); int small = start - 1; swap(data[index], data[end]); for (int i = start; i &amp;lt; end; &#43;&#43;i) { if (data[i] &amp;lt; data[end]) { &#43;&#43;small; if (small != i) { swap(data[small], data[i]); } } } &#43;&#43;small; swap(data[small], data[end]); return small; } //http://notes.maxwi.com/2016/04/10/cpp-random/ //https://www.cnblogs.com/byhj/p/4149467.html template&amp;lt;typename T&amp;gt; int innerSort&amp;lt;T&amp;gt;::random(int start, int end) { // static std::default_random_engine e; // static std::uniform_int_distribution&amp;lt;unsigned&amp;gt; u(start, end); // int result = u(e);  srand(time(0)); int result = std::rand() % (end - start &#43; 1) &#43; start; return result; } 上面这种方法应该注意后面是small&#43;&#43;之后再交换，想象一下全部有序就能理解了😂。
  快速排序最好情况下的时间复杂度为$O(nlog_2n)$。
  最坏情况下的时间复杂度为$O(n^2)$。
  平均时间复杂度为$O(nlog_2n)$,就平均而言快速排序是所有排序算法中效果最好的,这是快排的名字的由来。
  待排序序列越接近无序，算法效率越高，个人理解应该是无序的时候基点两边平衡的比较好，所以效率比较高,这是针对于以第一个元素为pivot的情况。
  待排序序列越接近有序，算法效率越低（快速排序反而蜕化为冒泡排序？）。
  快速排序的趟数和初始序列相关。
  是不稳定的排序算法2，2，1 。
  空间复杂度为$O(log_2n)$。
   选择类排序 简单选择排序 简单选择排序：每一趟在$n-i(i=1,2,&amp;hellip;,n-1)$个数据元素中$R[i],R[i&#43;1],&amp;hellip;,R[n-1]$中选择最小的数据元素作为有序序列中第$i$个数据元素。
template&amp;lt;typename T&amp;gt; void innerSort&amp;lt;T&amp;gt;::selectSort(T *data, int length) { assert(length &amp;gt;= 0); int index; //从0开始便于index的取值，因为数组下标是从0开始的  for (int i = 0; i &amp;lt; length - 1; &#43;&#43;i) { index = i; for (int j = i &#43; 1; j &amp;lt; length; &#43;&#43;j) { if (data[index] &amp;gt; data[j]) { index = j; } } if (index != i) { std::swap(data[index], data[i]); } } }   是不稳定的排序算法，例如2，2，1。
  时间复杂度为$O(n^2)$。
  空间复杂度为$O(1)$。
   堆排序 可以把堆看成一棵完全二叉树，满足：任何一个非叶子节点的值都不大于(或不小于）其左右孩子节点的值，若父亲大孩子小，则这样的堆叫做大顶堆，若父亲小孩子大，则这样的堆叫做小顶堆。
根据堆的定义，代表堆的这棵完全二叉树的根节点的值是最大的或者最小的，因此将一个无序的序列调整为一个堆，就可以找出这个序列的最大（最小）值，然后将找出的这个值交换到序列的最后（或最前），这样有序序列元素增加1个，无序序列中元素减少1个，对新的无序序列重复这样的操作就可以实现排序。
template&amp;lt;typename T&amp;gt; void innerSort&amp;lt;T&amp;gt;::heapSort(T *data, int length) { assert(length &amp;gt;= 0); //首先从(length-2)/2开始调整，让他成为大顶堆  //当数组下标是从0开始的时候i的初始值就为(length-2)/2，下标为1开始时为(length-1)/2  for (int i = (length - 2) / 2; i &amp;gt;= 0; --i) { assistHeapSort(data, i, length - 1); } for (int j = length - 1; j &amp;gt;= 1; --j) { std::swap(data[0], data[j]); assistHeapSort(data, 0, j - 1); } } //构建大顶堆,堆顶元素data[start] template&amp;lt;typename T&amp;gt; void innerSort&amp;lt;T&amp;gt;::assistHeapSort(T *data, int start, int end) { assert(start &amp;lt;= end &amp;amp;&amp;amp; start &amp;gt;= 0); int parent = start, child = 2 * start &#43; 1; while (child &amp;lt;= end) { //注意控制条件是child &amp;lt; end，不越界  if (child &amp;lt; end &amp;amp;&amp;amp; data[child] &amp;lt; data[child &#43; 1]) { child&#43;&#43;; } if (data[parent] &amp;lt; data[child]) { std::swap(data[parent], data[child]); } parent = child; child = 2 * parent &#43; 1; } }   平均时间复杂度为$O(nlog_2(n))$。
  最坏情况下的时间复杂度也为$O(nlog_2(n))$。
  其空间复杂度为$O(1)$,空间复杂度是指占用内存大小，每次调用完调整堆的的函数后，所占用的那一个空间都会被释放，不想快速排序那样未排完之前是不会释放辅助空间的。
  适用于记录数较多的情况。
  是不稳定排序方法，例如使用2,2,1构造小顶堆时。
   归并排序 二路归并排序：将两个有序的子序列合并成一个新的有序子序列。归并的思想：将序列看成是$n$个有序子序列，每个序列的长度为$1$,然后两两归并，得到$⌈\frac{n}{2}⌉$个长度为$2$,的有序子序列，然后两两归并&amp;hellip;，如此重复，直到得到一个长度为 $n$ 的有序子序列。
void mergeSort(int *data, int length) { assert(length &amp;gt;= 0 || data != nullptr); auto *copy = new int[length]; /* for (int i = 0; i &amp;lt; length; &#43;&#43;i) { copy[i] = data[i]; }*/ mergeSort(data, copy, 0, length - 1); delete[] copy; } void mergeSort(int *data, int *copy, int start, int end) { if (start == end) { copy[start] = data[start]; return; } int length = (end - start) / 2; mergeSort(data, copy, start, start &#43; length); mergeSort(data, copy, start &#43; length &#43; 1, end); int i = start, j = start &#43; length &#43; 1, k = start; while (i &amp;lt;= start &#43; length &amp;amp;&amp;amp; j &amp;lt;= end) { if (data[i] &amp;lt; data[j]) copy[k&#43;&#43;] = data[i&#43;&#43;]; else copy[k&#43;&#43;] = data[j&#43;&#43;]; } while (i &amp;lt;= start &#43; length) copy[k&#43;&#43;] = data[i&#43;&#43;]; while (j &amp;lt;= end) copy[k&#43;&#43;] = data[j&#43;&#43;]; for (i = start; i &amp;lt;= end; &#43;&#43;i) { data[i] = copy[i]; } } template&amp;lt;typename T&amp;gt; void innerSort&amp;lt;T&amp;gt;::mergeSort(T *data, int length) { assert(length &amp;gt;= 0); int *assist = new int[length]; memcpy(assist, data, length * sizeof(int)); assistMergeSort(data, assist, 0, length - 1); delete[] assist; } template&amp;lt;typename T&amp;gt; void innerSort&amp;lt;T&amp;gt;::assistMergeSort(T *data, T *assist, int start, int end) { if (start &amp;lt; end) { int mid = start &#43; (end - start) / 2; assistMergeSort(data, assist, start, mid); assistMergeSort(data, assist, mid &#43; 1, end); int i = start, j = mid &#43; 1, k = start; while (i &amp;lt;= mid &amp;amp;&amp;amp; j &amp;lt;= end) { if (data[i] &amp;lt;= data[j]) { assist[k&#43;&#43;] = data[i&#43;&#43;]; } else { assist[k&#43;&#43;] = data[j&#43;&#43;]; } } while (i &amp;lt;= mid) { assist[k&#43;&#43;] = data[i&#43;&#43;]; } while (j &amp;lt;= end) { assist[k&#43;&#43;] = data[j&#43;&#43;]; } for (int l = start; l &amp;lt;= end; &#43;&#43;l) { data[l] = assist[l]; } } }   排序时间代价不依赖于待排序数组的初始情况。
  在最好，最坏，平均时间复杂度都为$O(nlog_2n)$ 。
  空间复杂度为$O(n)
  稳定的排序方法。
  在平均情况下还是快速排序最快（常数因子更小）。
   比较排序的最优下界 比较排序算法小结 计数排序 计数排序是一种稳定的线性时间排序算法。计数排序使用一个额外的数组count，其中第i个元素是待排序数组A中值等于i的元素的个数。
然后根据数组count来将A中的元素排到正确的位置。当输入的元素是n个0到k之间的整数时，它的运行时间是$Θ(n &#43; k)$。
计数排序不是比较排序，排序的速度快于任何比较排序算法。由于用来计数的数组count的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上1），这使得计数排序对于数据范围很大的数组，需要大量内存。
template&amp;lt;typename T&amp;gt; void innerSort&amp;lt;T&amp;gt;::countSort(T *data, int length) { assert(length &amp;gt;= 0); int min = data[0], max = data[0]; int *assistArr = new int[length]{0}; int inc = 0; //先找出最大值和最小值  for (int i = 0; i &amp;lt; length; &#43;&#43;i) { assert(data[i] &amp;gt;= 0); if (data[i] &amp;gt; max) { max = data[i]; } if (data[i] &amp;lt; min) { min = data[i]; } } if (min &amp;lt; 0) { inc = abs(min); } for (int i = 0; i &amp;lt; length; &#43;&#43;i) { data[i] &#43;= inc; } int countLength = (max &#43; inc &#43; 1); int *countArr = new int[countLength]{0}; for (int i = 0; i &amp;lt; length; &#43;&#43;i) { countArr[data[i]]&#43;&#43;; } //注意是计数数组的上界限  for (int j = 1; j &amp;lt; countLength; &#43;&#43;j) { countArr[j] &#43;= countArr[j - 1]; } for (int k = length - 1; k &amp;gt;= 0; --k) { assistArr[--countArr[data[k]]] = data[k]; } for (int i = 0; i &amp;lt; length; &#43;&#43;i) { data[i] = assistArr[i] - inc; } delete[] assistArr; delete[] countArr; } 桶排序 桶排序(Bucket Sort)的基本思路是：
  将待排序元素划分到不同的桶。先扫描一遍序列求出最大值$max$和最小值$min$，设桶的个数为$k$，则把区间$[min, max]$均匀划分成$k$个区间，每个区间就是一个桶。将序列中的元素分配到各自的桶。
  对每个桶内的元素进行排序。可以选择任意一种排序算法。
  将各个桶中的元素合并成一个大的有序序列。
  复杂度分析：
  假设数据是均匀分布的，则每个桶的元素平均个数为$\frac{n}{k}$。
  假设选择用快速排序对每个桶内的元素进行排序，那么每次排序的时间复杂度为$O(\frac{n}{k}log(\frac{n}{k}))$。
  $O(n)&#43;O(m)O(\frac{n}{k}log(\frac{n}{k}))=O(n&#43;nlog(\frac{n}{k}))=O(n&#43;nlogn-nlogk)$为总的时间复杂度。当$k$接近于 $n$时，桶排序的时间复杂度就可以近似认为是$O(n)$, 此时近似为计数排序。即桶越多，时间效率就越高，而桶越多，空间就越大。
   基数排序 将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。
基数排序法会使用到桶，先进先出的队列，通过将要比较的位（个位、十位、百位…），将要排序的元素分配至$0 \to 9$ 个桶中，借以达到排序的作用，在某些时候，基数排序法的效率高于其它的比较性排序算法。
void radixSort(int *data, int length) { int max = getMax(data, length); //找出待排序数组中最大的那个数  int radix = 10; for (int exp = 1; exp &amp;lt;= max; exp *= 10) { bucketSort(data, length, exp, radix); } } void bucketSort(int *data, int length, int exp, int radix) { auto *count = new int[radix]{0}; auto *result = new int[length]; for (int i = 0; i &amp;lt; length; &#43;&#43;i) { count[(data[i] / exp) % radix]&#43;&#43;; //(data[i] / exp) 获取当前位的数值  } for (int j = 1; j &amp;lt; radix; &#43;&#43;j) { count[j] &#43;= count[j - 1]; } for (int i = length - 1; i &amp;gt;= 0; --i) { result[--count[(data[i] / exp) % radix]] = data[i]; } for (int i = 0; i &amp;lt; length; &#43;&#43;i) { data[i] = result[i]; } delete[] result; delete[] count; }   是稳定的排序方法。
  时间复杂度：设数组长度为$n$,基数为$r$,关键字位数为$d$,则每趟分配的时间为$O(n)$，每趟收集的时间复杂度为$O(n)$，工序$d$趟分配与收集，所以时间复杂度为$O(d(2n))$,即$O(d \times n)$。
  空间复杂度为$O(rn)$。
   外排序算法 所谓外排序，顾名思义，即排序涉及到内存外面的排序。因为当要处理的数据量很大，而不能一次装入内存时，此时只能放在读写较慢的外存储器（通常是硬盘）上。外排序通常采用的是一种排序-归并的策略。  在排序阶段，先读入能放在内存中的数据量，将其排序输出到一个临时文件，依此进行，将待排序数据组织为多个有序的临时文件；
  在归并阶段将这些临时文件组合为一个大的有序文件，即排序结果。
  例子1 假定现在有20个数据的文件A：{5，11， 0， 18， 4， 14， 9， 7 6， 8， 12， 17 ，16 ，13 ，19 ，10， 2， 1， 3， 15}，但内存一次只能装4个数据，所以，可以每趟先选择4个数据进行排序，然后将排好序的5路数据进行归并，具体步骤如下：
  首先把大文件$A$，按顺序分割为$a_1，a_2，a_3，a_4，a_5$等5个小文件，每个小文件4个数据。
  $a_1$文件为：5,11, 0,18。
  $a_2$文件为：4,14,9,7。
  $a_3$文件为：6, 8, 12, 17。
  $a_4$文件为：16,13, 19,10。
  $a_5$文件为：2,1,3,15然后依次对5个小文件分别进行排序。
  $a_1$文件完成排序后：0,5,11,18。
  $a_2$文件完成排序后：4,7,9,14。
  $a_3$文件完成排序后：6,8,12,17。
  $a_4$文件完成排序后：10,13,16,19。
  $a_5$文件完成排序后：1,2,3,15。
  最后进行5路归并，完成排序：0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19。
   例子2 要对900MB的数据进行排序，但机器上只有100MB的可用内存时，外部归并排序按如下方法操作：
  读入100MB的数据至内存中，用某种常规排序（如：快速排序、堆排序、归并排序等）在内存中完成排序。
  将排序完成的数据写入磁盘（临时文件）。
  重复步骤1和步骤2直到所有的数据都存入了不同的100MB的块（临时文件）中。本例中，900MB数据，100MB内存，故产生了9个临时文件。
  读入每个临时文件（顺串）的前10MB($10=\frac{100}{9&#43;1}$)，在进行多路归并的时候，这里有9路，然后输出缓冲算一个，所以要将内存资源分给10个部分)的数据放入内存中的输入缓冲区（总计90MB），最后的10MB作为输出缓冲区。（实践中，将输入缓冲适当调小，而适当增大输出缓冲区能获得比较好的效果）
  执行9路归并算法，将结果输出到输出缓冲区。一旦输出缓冲区满，将缓冲区中的数据写到目标文件，清空缓冲区。一旦9个输入缓冲区的一个变空，就从这个缓冲区关联的文件中读入下一个10MB数据，除非这个文件已读完。这是外部归并排序能在主存外完成排序的关键步骤。因为归并算法对每一个大块只是顺序地做一轮访问，每个大块不用完全载入主存。
   置换选择 为了增加每一个有序的临时文件的长度，可以采用置换选择排序——它可以产生大于内存有序序列。具体方法是在内存中使用一个最小堆进行排序，设这个最小堆的大小为M，算法描述如下：
  初始时将输入文件读入内存，建立最小堆。
  将堆顶元素输出至输出缓冲区，然后读入下一个记录。
    2.1 若该元素的关键码值不小于刚输出的关键码值，将其作为堆顶元素并调整堆，使之满足堆的性质。
  2.2 若该元素的关键码值小于刚输出的关键码值，将新元素放入堆底位置，将堆的大小减1。
   重复第2步，直至堆大小变为0。
  此时一个有序序列已经产生，此时将输入缓冲区中剩下的所有元素建立最小堆，开始生成下一个有序序列。
   </content>
    </entry>
    
</search>