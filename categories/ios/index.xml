<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>iOS on Keep It Simple</title>
    <link>https://iihui.github.io/categories/ios/</link>
    <description>Recent content in iOS on Keep It Simple</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Mon, 17 Aug 2020 08:00:07 +0000</lastBuildDate>
    
	<atom:link href="https://iihui.github.io/categories/ios/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Swift中as</title>
      <link>https://iihui.github.io/post/ios-as/</link>
      <pubDate>Mon, 17 Aug 2020 08:00:07 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/ios-as/</guid>
      <description>as是在编译期间执行的，as?和as!是在运行时执行的。 print(4 as Double) // print 4.0 print(4 as! Double) // crash 上面第二行代码会崩溃是因为as?和as!是在运行时执行，运行时4已经赋值为Int类型。 UITableView中需要reload数据的解决方案 增加内存缓存 在prep</description>
    </item>
    
    <item>
      <title>Swift中as</title>
      <link>https://iihui.github.io/post/post/ios-as/</link>
      <pubDate>Mon, 17 Aug 2020 08:00:07 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/post/ios-as/</guid>
      <description>as是在编译期间执行的，as?和as!是在运行时执行的。 print(4 as Double) // print 4.0 print(4 as! Double) // crash 上面第二行代码会崩溃是因为as?和as!是在运行时执行，运行时4已经赋值为Int类型。 UITableView中需要reload数据的解决方案 增加内存缓存 在prep</description>
    </item>
    
    <item>
      <title>image</title>
      <link>https://iihui.github.io/post/ios-image-nsconflict-halo-mac10.15.6/</link>
      <pubDate>Wed, 05 Aug 2020 11:46:48 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/ios-image-nsconflict-halo-mac10.15.6/</guid>
      <description>/// 将图片裁剪为带外围⭕️的圆形图 /// - Parameters: /// - rail: 外围圆的宽度 /// - color: 外围圆的颜色 /// - Returns: 生成新的图片 func circleImageWidthRail(rail: CGFloat, color: UIColor) -&amp;gt; UIImage? { let size = CGSize(width: self.size.width + 2 * rail, height: self.size.height + 2 * rail) UIGraphicsBeginImageContextWithOptions(size, false, 0) let path = UIBezierPath(ovalIn: CGRect(x: 0, y: 0, width: size.width, height: size.height)) color.set() path.fill() let imgPath = UIBezierPath(ovalIn: CGRect(x: rail, y: rail, width: self.size.width, height: self.size.height)) imgPath.addClip() self.draw(at: CGPoint(x: rail, y: rail)) let newImg = UIGraphicsGetImageFromCurrentImageContext() UIGraphicsEndImageContext() return newImg } /// 将图片裁剪为圆</description>
    </item>
    
    <item>
      <title>image</title>
      <link>https://iihui.github.io/post/post/ios-image/</link>
      <pubDate>Wed, 05 Aug 2020 11:46:48 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/post/ios-image/</guid>
      <description>/// 将图片裁剪为带外围⭕️的圆形图 /// - Parameters: /// - rail: 外围圆的宽度 /// - color: 外围圆的颜色 /// - Returns: 生成新的图片 func circleImageWidthRail(rail: CGFloat, color: UIColor) -&amp;gt; UIImage? { let size = CGSize(width: self.size.width + 2 * rail, height: self.size.height + 2 * rail) UIGraphicsBeginImageContextWithOptions(size, false, 0) let path = UIBezierPath(ovalIn: CGRect(x: 0, y: 0, width: size.width, height: size.height)) color.set() path.fill() let imgPath = UIBezierPath(ovalIn: CGRect(x: rail, y: rail, width: self.size.width, height: self.size.height)) imgPath.addClip() self.draw(at: CGPoint(x: rail, y: rail)) let newImg = UIGraphicsGetImageFromCurrentImageContext() UIGraphicsEndImageContext() return newImg } /// 将图片裁剪为圆</description>
    </item>
    
    <item>
      <title>image 处理</title>
      <link>https://iihui.github.io/post/ios-image/</link>
      <pubDate>Wed, 05 Aug 2020 11:46:48 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/ios-image/</guid>
      <description>添加外圆 /// 将图片裁剪为带外围⭕️的圆形图 /// - Parameters: /// - rail: 外围圆的宽度 /// - color: 外围圆的颜色 /// - Returns: 生成新的图片 func circleImageWidthRail(rail: CGFloat, color: UIColor) -&amp;gt; UIImage? { let size = CGSize(width: self.size.width + 2 * rail, height: self.size.height + 2 * rail) UIGraphicsBeginImageContextWithOptions(size, false, 0) let path = UIBezierPath(ovalIn: CGRect(x: 0, y: 0, width: size.width, height: size.height)) color.set() path.fill() let imgPath = UIBezierPath(ovalIn: CGRect(x: rail, y: rail, width: self.size.width, height: self.size.height)) imgPath.addClip() self.draw(at: CGPoint(x: rail, y: rail)) let newImg = UIGraphicsGetImageFromCurrentImageContext() UIGraphicsEndImageContext() return newImg } 裁剪为圆</description>
    </item>
    
    <item>
      <title>UITabBar</title>
      <link>https://iihui.github.io/post/ios-uitabbar-nsconflict-halo-mac10.15.6/</link>
      <pubDate>Sun, 02 Aug 2020 21:04:47 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/ios-uitabbar-nsconflict-halo-mac10.15.6/</guid>
      <description>双击检测 private let intervalThreshold: Double = 0.8 private var dkLastClickedDate: Date? = nil private var ePaperLastClickedDate: Date? = nil func tabBarController(_ tabBarController: UITabBarController, shouldSelect viewController: UIViewController) -&amp;gt; Bool { if tabBarController.selectedIndex == 1,let nav = tabBarController.selectedViewController as? UINavigationController,let vc:NewsViewController = nav.visibleViewController let date = Date() switch vc.segmentedView.selectedIndex { case 0: if let lastDate = self.ePaperLastClickedDate, (date.timeIntervalSince1970 - lastDate.timeIntervalSince1970) &amp;lt; intervalThreshold { NotificationCenter.default.post(name: .ePaperScrollToTopNotification, object: nil) } self.ePaperLastClickedDate = date case 1: if let lastDate = self.dkLastClickedDate, (date.timeIntervalSince1970 - lastDate.timeIntervalSince1970) &amp;lt; intervalThreshold { NotificationCenter.default.post(name: .dkScrollToTopNotification, object: nil) } self.dkLastClickedDate = date default: break } } return true }</description>
    </item>
    
    <item>
      <title>UITabBar</title>
      <link>https://iihui.github.io/post/post/ios-uitabbar/</link>
      <pubDate>Sun, 02 Aug 2020 21:04:47 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/post/ios-uitabbar/</guid>
      <description>双击检测 private let intervalThreshold: Double = 0.8 private var dkLastClickedDate: Date? = nil private var ePaperLastClickedDate: Date? = nil func tabBarController(_ tabBarController: UITabBarController, shouldSelect viewController: UIViewController) -&amp;gt; Bool { if tabBarController.selectedIndex == 1,let nav = tabBarController.selectedViewController as? UINavigationController,let vc:NewsViewController = nav.visibleViewController let date = Date() switch vc.segmentedView.selectedIndex { case 0: if let lastDate = self.ePaperLastClickedDate, (date.timeIntervalSince1970 - lastDate.timeIntervalSince1970) &amp;lt; intervalThreshold { NotificationCenter.default.post(name: .ePaperScrollToTopNotification, object: nil) } self.ePaperLastClickedDate = date case 1: if let lastDate = self.dkLastClickedDate, (date.timeIntervalSince1970 - lastDate.timeIntervalSince1970) &amp;lt; intervalThreshold { NotificationCenter.default.post(name: .dkScrollToTopNotification, object: nil) } self.dkLastClickedDate = date default: break } } return true }</description>
    </item>
    
    <item>
      <title>UITabBar 相关</title>
      <link>https://iihui.github.io/post/ios-uitabbar/</link>
      <pubDate>Sun, 02 Aug 2020 21:04:47 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/ios-uitabbar/</guid>
      <description>双击检测 private let intervalThreshold: Double = 0.8 private var dkLastClickedDate: Date? = nil private var ePaperLastClickedDate: Date? = nil func tabBarController(_ tabBarController: UITabBarController, shouldSelect viewController: UIViewController) -&amp;gt; Bool { if tabBarController.selectedIndex == 1,let nav = tabBarController.selectedViewController as? UINavigationController,let vc:NewsViewController = nav.visibleViewController let date = Date() switch vc.segmentedView.selectedIndex { case 0: if let lastDate = self.ePaperLastClickedDate, (date.timeIntervalSince1970 - lastDate.timeIntervalSince1970) &amp;lt; intervalThreshold { NotificationCenter.default.post(name: .ePaperScrollToTopNotification, object: nil) } self.ePaperLastClickedDate = date case 1: if let lastDate = self.dkLastClickedDate, (date.timeIntervalSince1970 - lastDate.timeIntervalSince1970) &amp;lt; intervalThreshold { NotificationCenter.default.post(name: .dkScrollToTopNotification, object: nil) } self.dkLastClickedDate = date default: break } } return true }</description>
    </item>
    
    <item>
      <title>snapkit 使用</title>
      <link>https://iihui.github.io/post/ios-snapkit/</link>
      <pubDate>Fri, 31 Jul 2020 10:10:07 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/ios-snapkit/</guid>
      <description>inset和offset 在描述view与superview关系时，应该使用inset，而描述view与同一层级的其它view时，应该使用offset。 使用offset来设置距离子控件相对于父控件边距时，对于右边和下方的约束都需要加-号。这和</description>
    </item>
    
    <item>
      <title>snapkit 使用</title>
      <link>https://iihui.github.io/post/post/ios-snapkit/</link>
      <pubDate>Fri, 31 Jul 2020 10:10:07 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/post/ios-snapkit/</guid>
      <description>inset和offset 在描述view与superview关系时，应该使用inset，而描述view与同一层级的其它view时，应该使用offset。 使用offset来设置距离子控件相对于父控件边距时，对于右边和下方的约束都需要加-号。这和</description>
    </item>
    
    <item>
      <title>字典</title>
      <link>https://iihui.github.io/post/ios-dict/</link>
      <pubDate>Thu, 30 Jul 2020 08:18:10 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/ios-dict/</guid>
      <description>字典合并 第一个字典先提供一些默认值，对于相同的key如果第二个字典中存在相应的value，则第一个字典的value被第二个字典覆盖掉。 // 默认字段 var defaultInfo: [String: Any] = [ &amp;#34;sys_id&amp;#34;: sysID, &amp;#34;type&amp;#34;: action.rawValue, &amp;#34;ystId&amp;#34;: activeUser.pid, &amp;#34;deviceId&amp;#34;: deviceID, &amp;#34;platform&amp;#34;: platform, &amp;#34;pubVer&amp;#34;: pubVersion, &amp;#34;buildVer&amp;#34;: buildVersion, &amp;#34;deviceModel&amp;#34;: deviceModel, &amp;#34;serverTime&amp;#34;: logTime, &amp;#34;deviceTime&amp;#34;: deviceTimeStr, &amp;#34;startTime&amp;#34;: logTime, &amp;#34;endTime&amp;#34;: logTime, &amp;#34;networkType&amp;#34;: networkInfo._networkType, &amp;#34;networkName&amp;#34;: networkInfo._networkName, &amp;#34;ip&amp;#34;: networkInfo.ip, &amp;#34;inuseId&amp;#34;: inuseID, &amp;#34;gpsLng&amp;#34;: gps.lng, &amp;#34;gpsLat&amp;#34;: gps.lat, ] if let _args = args</description>
    </item>
    
    <item>
      <title>字典</title>
      <link>https://iihui.github.io/post/post/ios-dict/</link>
      <pubDate>Thu, 30 Jul 2020 08:18:10 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/post/ios-dict/</guid>
      <description>字典合并 第一个字典先提供一些默认值，对于相同的key如果第二个字典中存在相应的value，则第一个字典的value被第二个字典覆盖掉。 // 默认字段 var defaultInfo: [String: Any] = [ &amp;#34;sys_id&amp;#34;: sysID, &amp;#34;type&amp;#34;: action.rawValue, &amp;#34;ystId&amp;#34;: activeUser.pid, &amp;#34;deviceId&amp;#34;: deviceID, &amp;#34;platform&amp;#34;: platform, &amp;#34;pubVer&amp;#34;: pubVersion, &amp;#34;buildVer&amp;#34;: buildVersion, &amp;#34;deviceModel&amp;#34;: deviceModel, &amp;#34;serverTime&amp;#34;: logTime, &amp;#34;deviceTime&amp;#34;: deviceTimeStr, &amp;#34;startTime&amp;#34;: logTime, &amp;#34;endTime&amp;#34;: logTime, &amp;#34;networkType&amp;#34;: networkInfo._networkType, &amp;#34;networkName&amp;#34;: networkInfo._networkName, &amp;#34;ip&amp;#34;: networkInfo.ip, &amp;#34;inuseId&amp;#34;: inuseID, &amp;#34;gpsLng&amp;#34;: gps.lng, &amp;#34;gpsLat&amp;#34;: gps.lat, ] if let _args = args</description>
    </item>
    
    <item>
      <title>时间相关</title>
      <link>https://iihui.github.io/post/ios-date-nsconflict-halo-mac10.15.6/</link>
      <pubDate>Wed, 29 Jul 2020 19:21:23 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/ios-date-nsconflict-halo-mac10.15.6/</guid>
      <description>毫秒级时间戳距当前时间 /// 将毫秒级别的时间戳转换为约定的格式，0～60秒显示几秒前，1～60分显示xx分钟前，1～24小时显示xx小时前，1～10天显示xx天前，否则显示yyyy-MM-dd /// - Parameter timeStamp: 毫秒级别时间戳字符串 /// - Returns: 转换后的字符串 private func</description>
    </item>
    
    <item>
      <title>时间相关</title>
      <link>https://iihui.github.io/post/post/ios-date/</link>
      <pubDate>Wed, 29 Jul 2020 19:21:23 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/post/ios-date/</guid>
      <description>毫秒级时间戳距当前时间 /// 将毫秒级别的时间戳转换为约定的格式，0～60秒显示几秒前，1～60分显示xx分钟前，1～24小时显示xx小时前，1～10天显示xx天前，否则显示yyyy-MM-dd /// - Parameter timeStamp: 毫秒级别时间戳字符串 /// - Returns: 转换后的字符串 private func</description>
    </item>
    
    <item>
      <title>时间相关处理</title>
      <link>https://iihui.github.io/post/ios-date/</link>
      <pubDate>Wed, 29 Jul 2020 19:21:23 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/ios-date/</guid>
      <description>毫秒级时间戳距当前时间 /// 将毫秒级别的时间戳转换为约定的格式，0～60秒显示几秒前，1～60分显示xx分钟前，1～24小时显示xx小时前，1～10天显示xx天前，否则显示yyyy-MM-dd /// - Parameter timeStamp: 毫秒级别时间戳字符串 /// - Returns: 转换后的字符串 private func</description>
    </item>
    
    <item>
      <title>富文本</title>
      <link>https://iihui.github.io/post/ios-richtext/</link>
      <pubDate>Wed, 29 Jul 2020 18:59:27 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/ios-richtext/</guid>
      <description>在文字后面添加红点 /// 使用富文本的方式在UILabel文本后面添加红点 /// - Parameter add: isNeedAdd 为true表示要加红点，否则不需要 /// - Returns: 处理后的富文本 func addRedDot(isNeedAdd: Bool) -&amp;gt; NSMutableAttributedString { var text: String = (self.text ?? &amp;#34;&amp;#34;) if isNeedAdd { text += &amp;#34; &amp;#34; let contentText = NSMutableAttributedString(string: text) let attach = NSTextAttachment() let dotImg = UIImage(named: &amp;#34;reddot&amp;#34;) let width: CGFloat = 10 attach.bounds = CGRect(x: 0, y: 0.5, width: width, height: width) attach.image = dotImg let attrText</description>
    </item>
    
    <item>
      <title>富文本</title>
      <link>https://iihui.github.io/post/post/ios-richtext/</link>
      <pubDate>Wed, 29 Jul 2020 18:59:27 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/post/ios-richtext/</guid>
      <description>在文字后面添加红点 /// 使用富文本的方式在UILabel文本后面添加红点 /// - Parameter add: isNeedAdd 为true表示要加红点，否则不需要 /// - Returns: 处理后的富文本 func addRedDot(isNeedAdd: Bool) -&amp;gt; NSMutableAttributedString { var text: String = (self.text ?? &amp;#34;&amp;#34;) if isNeedAdd { text += &amp;#34; &amp;#34; let contentText = NSMutableAttributedString(string: text) let attach = NSTextAttachment() let dotImg = UIImage(named: &amp;#34;reddot&amp;#34;) let width: CGFloat = 10 attach.bounds = CGRect(x: 0, y: 0.5, width: width, height: width) attach.image = dotImg let attrText</description>
    </item>
    
    <item>
      <title>导航栏</title>
      <link>https://iihui.github.io/post/ios-navigation/</link>
      <pubDate>Wed, 29 Jul 2020 17:13:19 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/ios-navigation/</guid>
      <description>仿导航栏添加阴影 // 设置阴影颜色 navBGView.layer.shadowColor = UIColor.lightGray.cgColor // 设置阴影偏移范围 navBGView.layer.shadowOffset = CGSize(width: 0, height: 1.8) // 设置阴影颜色的透明度 navBGView.layer.shadowOpacity = 0.2 // 设置阴影的半径 navBGView.layer.shadowRadius = 2.5 // 设置阴影路径 navBGView.layer.shadowPath = UIBezierPath.init(rect: navBGView.bounds).cgPath 通过设置1.2.3步仿导航栏的阴影就可以出现,如果对阴影有特别的需要,可再设置4.5这两个步骤。 参考资</description>
    </item>
    
    <item>
      <title>导航栏</title>
      <link>https://iihui.github.io/post/post/ios-navigation/</link>
      <pubDate>Wed, 29 Jul 2020 17:13:19 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/post/ios-navigation/</guid>
      <description>仿导航栏添加阴影 // 设置阴影颜色 navBGView.layer.shadowColor = UIColor.lightGray.cgColor // 设置阴影偏移范围 navBGView.layer.shadowOffset = CGSize(width: 0, height: 1.8) // 设置阴影颜色的透明度 navBGView.layer.shadowOpacity = 0.2 // 设置阴影的半径 navBGView.layer.shadowRadius = 2.5 // 设置阴影路径 navBGView.layer.shadowPath = UIBezierPath.init(rect: navBGView.bounds).cgPath 通过设置1.2.3步仿导航栏的阴影就可以出现,如果对阴影有特别的需要,可再设置4.5这两个步骤。 参考资</description>
    </item>
    
    <item>
      <title></title>
      <link>https://iihui.github.io/post/ios-customizeuiview/</link>
      <pubDate>Fri, 03 Jul 2020 16:54:07 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/ios-customizeuiview/</guid>
      <description>class RecommendView: UIView { @IBOutlet weak var imageView: UIImageView! @IBOutlet weak var subTitleLbl: UILabel! @IBOutlet weak var titleLbl: UILabel! @IBOutlet var contentView: UIView! override init(frame: CGRect) { //每一步都必须实现父初始化 super.init(frame: frame) contentView = loadViewFromNib() contentView.frame = bounds addSubview(contentView) } //可视化IB初始化调用 required init?(coder aDecoder: NSCoder) { super.init(coder: aDecoder) contentView = loadViewFromNib() contentView.frame = bounds addSubview(contentView) } //MARK：自定义方法 func loadViewFromNib() -&amp;gt; UIView { let nib = UINib(nibName: String(describing: RecommendView.self), bundle: Bundle(for: RecommendView.self)) let view = nib.instantiate(withOwner: self, options: nil)[0] as! UIView return view } } 参考资</description>
    </item>
    
    <item>
      <title></title>
      <link>https://iihui.github.io/post/post/ios-customizeuiview/</link>
      <pubDate>Fri, 03 Jul 2020 16:54:07 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/post/ios-customizeuiview/</guid>
      <description>class RecommendView: UIView { @IBOutlet weak var imageView: UIImageView! @IBOutlet weak var subTitleLbl: UILabel! @IBOutlet weak var titleLbl: UILabel! @IBOutlet var contentView: UIView! override init(frame: CGRect) { //每一步都必须实现父初始化 super.init(frame: frame) contentView = loadViewFromNib() contentView.frame = bounds addSubview(contentView) } //可视化IB初始化调用 required init?(coder aDecoder: NSCoder) { super.init(coder: aDecoder) contentView = loadViewFromNib() contentView.frame = bounds addSubview(contentView) } //MARK：自定义方法 func loadViewFromNib() -&amp;gt; UIView { let nib = UINib(nibName: String(describing: RecommendView.self), bundle: Bundle(for: RecommendView.self)) let view = nib.instantiate(withOwner: self, options: nil)[0] as! UIView return view } } 参考资</description>
    </item>
    
    <item>
      <title>启动页修改</title>
      <link>https://iihui.github.io/post/ios-lanuch/</link>
      <pubDate>Wed, 01 Jul 2020 19:22:27 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/ios-lanuch/</guid>
      <description>最近App改版，启动页也要随之修改，但是修改lanuchScreen.storyboard里的图片和样式之后并未立即生效。解决这个问题，主要分为三个步骤 图片不放xcassets中 启动页用到的图片资源，不要放入到*.xcassets中，应该直</description>
    </item>
    
    <item>
      <title>启动页修改</title>
      <link>https://iihui.github.io/post/post/ios-lanuch/</link>
      <pubDate>Wed, 01 Jul 2020 19:22:27 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/post/ios-lanuch/</guid>
      <description>最近App改版，启动页也要随之修改，但是修改lanuchScreen.storyboard里的图片和样式之后并未立即生效。解决这个问题，主要分为三个步骤 图片不放xcassets中 启动页用到的图片资源，不要放入到*.xcassets中，应该直</description>
    </item>
    
    <item>
      <title>Swift 范型</title>
      <link>https://iihui.github.io/post/post/swift-generirs/</link>
      <pubDate>Tue, 30 Jun 2020 08:58:17 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/post/swift-generirs/</guid>
      <description>范型类型 Swift允许自定义的范型类型包括类、结构体、枚举类型。 struct Stack { var items = [Int]() mutating func push(_ item:Int){ items.append(item) } mutating func pop(_ item:Int) -&amp;gt; Int { return items.removeLast() } } //调用 var stack_int = Stack() stack_int.push(7) stack_int.push(3) stack_int.push(2) print(stack_int)//Stack(items: [7, 3, 2]) 类型约束 范型函数和范型类型虽然可以和任何类型一起使用，但有时需要限制使用的类型，此时就需要使用类型</description>
    </item>
    
    <item>
      <title>Swift 范型</title>
      <link>https://iihui.github.io/post/swift-generirs/</link>
      <pubDate>Tue, 30 Jun 2020 08:58:17 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/swift-generirs/</guid>
      <description>范型类型 Swift允许自定义的范型类型包括类、结构体、枚举类型。 struct Stack { var items = [Int]() mutating func push(_ item:Int){ items.append(item) } mutating func pop(_ item:Int) -&amp;gt; Int { return items.removeLast() } } //调用 var stack_int = Stack() stack_int.push(7) stack_int.push(3) stack_int.push(2) print(stack_int)//Stack(items: [7, 3, 2]) 类型约束 范型函数和范型类型虽然可以和任何类型一起使用，但有时需要限制使用的类型，此时就需要使用类型</description>
    </item>
    
    <item>
      <title>Swift中defer</title>
      <link>https://iihui.github.io/post/post/swift-defer/</link>
      <pubDate>Sun, 28 Jun 2020 09:25:49 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/post/swift-defer/</guid>
      <description>从语言设计上来说，defer是为了进行资源清理和返回前避免重复执行相关的代码，而不是用来取巧的实现某些功能，这样做只会让代码的可读性降低。 典型用法 Swift中defer声明的block会在当前代码执行退出后调用，这种延迟调用特性，一般用来进</description>
    </item>
    
    <item>
      <title>Swift中defer</title>
      <link>https://iihui.github.io/post/swift-defer/</link>
      <pubDate>Sun, 28 Jun 2020 09:25:49 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/swift-defer/</guid>
      <description>从语言设计上来说，defer是为了进行资源清理和返回前避免重复执行相关的代码，而不是用来取巧的实现某些功能，这样做只会让代码的可读性降低。 典型用法 Swift中defer声明的block会在当前代码执行退出后调用，这种延迟调用特性，一般用来进</description>
    </item>
    
    <item>
      <title>Swift5.3 新特性</title>
      <link>https://iihui.github.io/post/post/swift-5.3/</link>
      <pubDate>Sun, 28 Jun 2020 08:52:46 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/post/swift-5.3/</guid>
      <description>Swift 5.3引入了很多新特性，包括多尾闭包，多模式catch以及Swift Package Manager的一些重要改变。 多尾闭包 在Swift5.3以前尾闭包提供了精简写法，但仅限于函数的最后一个参数为函数时。而当函数y有多个函数类型的参数时，如果该函数类型参</description>
    </item>
    
    <item>
      <title>Swift5.3 新特性</title>
      <link>https://iihui.github.io/post/swift-5.3/</link>
      <pubDate>Sun, 28 Jun 2020 08:52:46 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/swift-5.3/</guid>
      <description>Swift 5.3引入了很多新特性，包括多尾闭包，多模式catch以及Swift Package Manager的一些重要改变。 多尾闭包 在Swift5.3以前尾闭包提供了精简写法，但仅限于函数的最后一个参数为函数时。而当函数y有多个函数类型的参数时，如果该函数类型参</description>
    </item>
    
    <item>
      <title>Xcode编译报错问题</title>
      <link>https://iihui.github.io/post/ios-compiler/</link>
      <pubDate>Wed, 17 Jun 2020 10:06:46 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/ios-compiler/</guid>
      <description>XXX-Swift.h未找到</description>
    </item>
    
    <item>
      <title>Xcode编译报错问题</title>
      <link>https://iihui.github.io/post/post/ios-compiler/</link>
      <pubDate>Wed, 17 Jun 2020 10:06:46 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/post/ios-compiler/</guid>
      <description>XXX-Swift.h未找到</description>
    </item>
    
    <item>
      <title>屏幕旋转</title>
      <link>https://iihui.github.io/post/ios-rotate/</link>
      <pubDate>Mon, 08 Jun 2020 20:07:26 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/ios-rotate/</guid>
      <description>iOS开发时经常会遇到要将某些界面强制竖屏或者横屏。要做到某个页面能强制横竖屏的前提是允许屏幕旋转，然后再在具体的界面强制横竖屏。但是要区分这个具体的界面时push还是present呈现的。 全局允许横竖屏 第一种方式，是在Target中的Ge</description>
    </item>
    
    <item>
      <title>屏幕旋转</title>
      <link>https://iihui.github.io/post/post/ios-rotate/</link>
      <pubDate>Mon, 08 Jun 2020 20:07:26 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/post/ios-rotate/</guid>
      <description>iOS开发时经常会遇到要将某些界面强制竖屏或者横屏。要做到某个页面能强制横竖屏的前提是允许屏幕旋转，然后再在具体的界面强制横竖屏。但是要区分这个具体的界面时push还是present呈现的。 全局允许横竖屏 第一种方式，是在Target中的Ge</description>
    </item>
    
    <item>
      <title>WCDB</title>
      <link>https://iihui.github.io/post/ios-wcdb/</link>
      <pubDate>Mon, 25 May 2020 23:18:53 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/ios-wcdb/</guid>
      <description>自定义类型入库 自定义类型要遵循ColumnCodable才能入库： enum UserOrgType: String, ColumnCodable { case CMB = &amp;#34;CMB&amp;#34; case ODC = &amp;#34;3&amp;#34; static var columnType: ColumnType = .text init(with value: FundamentalValue) { self = UserOrgType(rawValue: value.stringValue) ?? UserOrgType.CMB } func archivedValue() -&amp;gt; FundamentalValue { return FundamentalValue(self.rawValue) } } /// 查看用户表是否为空 func isEmpty() -&amp;gt; Bool { do { let count = try DBManager_V2.shared.userDb.getValue(on: UserInfoModel_V2.CodingKeys.openId.count(), fromTable: tableName).int64Value return count == 0 } catch let error { printError(msg: error.localizedDescription, type: .db) return true } }</description>
    </item>
    
    <item>
      <title>WCDB</title>
      <link>https://iihui.github.io/post/post/ios-wcdb/</link>
      <pubDate>Mon, 25 May 2020 23:18:53 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/post/ios-wcdb/</guid>
      <description>自定义类型入库 自定义类型要遵循ColumnCodable才能入库： enum UserOrgType: String, ColumnCodable { case CMB = &amp;#34;CMB&amp;#34; case ODC = &amp;#34;3&amp;#34; static var columnType: ColumnType = .text init(with value: FundamentalValue) { self = UserOrgType(rawValue: value.stringValue) ?? UserOrgType.CMB } func archivedValue() -&amp;gt; FundamentalValue { return FundamentalValue(self.rawValue) } } /// 查看用户表是否为空 func isEmpty() -&amp;gt; Bool { do { let count = try DBManager_V2.shared.userDb.getValue(on: UserInfoModel_V2.CodingKeys.openId.count(), fromTable: tableName).int64Value return count == 0 } catch let error { printError(msg: error.localizedDescription, type: .db) return true } }</description>
    </item>
    
    <item>
      <title>CABasicAnimation</title>
      <link>https://iihui.github.io/post/ios-animation-1/</link>
      <pubDate>Sun, 17 May 2020 22:58:46 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/ios-animation-1/</guid>
      <description>使用CABasicAnimation做旋转动画时，发现切到后台之后，再切回到前台时，动画停止了。查阅相关资料，发现切到后台之后，CABasicAnimation被移除了，为此，需要将isRemovedOnCompletion属性置为fals</description>
    </item>
    
    <item>
      <title>CABasicAnimation</title>
      <link>https://iihui.github.io/post/post/ios-animation-1/</link>
      <pubDate>Sun, 17 May 2020 22:58:46 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/post/ios-animation-1/</guid>
      <description>使用CABasicAnimation做旋转动画时，发现切到后台之后，再切回到前台时，动画停止了。查阅相关资料，发现切到后台之后，CABasicAnimation被移除了，为此，需要将isRemovedOnCompletion属性置为fals</description>
    </item>
    
    <item>
      <title>UIAlertViewController</title>
      <link>https://iihui.github.io/post/ios-alertviewcontroller/</link>
      <pubDate>Mon, 20 Apr 2020 22:58:33 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/ios-alertviewcontroller/</guid>
      <description>最近使用UIAlertViewController时，需要定制其背景颜色，在网上找到一个解决方案，基本思路是为UIAlertViewController设置一个计算属性，这个属性改变时即将UIAlertViewController的背景色修</description>
    </item>
    
    <item>
      <title>UIAlertViewController</title>
      <link>https://iihui.github.io/post/post/ios-alertviewcontroller/</link>
      <pubDate>Mon, 20 Apr 2020 22:58:33 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/post/ios-alertviewcontroller/</guid>
      <description>最近使用UIAlertViewController时，需要定制其背景颜色，在网上找到一个解决方案，基本思路是为UIAlertViewController设置一个计算属性，这个属性改变时即将UIAlertViewController的背景色修</description>
    </item>
    
    <item>
      <title>Mach-O 文件</title>
      <link>https://iihui.github.io/post/ios-macho/</link>
      <pubDate>Wed, 01 Apr 2020 08:09:20 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/ios-macho/</guid>
      <description>Mach-O为Mach Object文件格式的缩写，它是一种用于可执行文件、目标代码、动态库的文件格式。 文件类型 常见的MachO文件有下面这些，可以通过file+文件路径来查看文件的类型信息： 目标文件.o 库文件.a | .dylib | xxx.framework/xxx 可执行文件 符号表文件</description>
    </item>
    
    <item>
      <title>Mach-O 文件</title>
      <link>https://iihui.github.io/post/post/ios-macho/</link>
      <pubDate>Wed, 01 Apr 2020 08:09:20 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/post/ios-macho/</guid>
      <description>Mach-O为Mach Object文件格式的缩写，它是一种用于可执行文件、目标代码、动态库的文件格式。 文件类型 常见的MachO文件有下面这些，可以通过file+文件路径来查看文件的类型信息： 目标文件.o 库文件.a | .dylib | xxx.framework/xxx 可执行文件 符号表文件</description>
    </item>
    
    <item>
      <title>创建私有库</title>
      <link>https://iihui.github.io/post/ios-private-pods/</link>
      <pubDate>Tue, 31 Mar 2020 19:52:58 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/ios-private-pods/</guid>
      <description>使用cocoapods可以创建远程私有库，供项目使用。首先需要在github上创建一个远程索引库，然后使用cocopods在本地创建文件夹，并与远程私有库进行关联。再在github上创建远程组件库，接着使用pod创建本地工程，然后修改组件库</description>
    </item>
    
    <item>
      <title>创建私有库</title>
      <link>https://iihui.github.io/post/post/ios-private-pods/</link>
      <pubDate>Tue, 31 Mar 2020 19:52:58 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/post/ios-private-pods/</guid>
      <description>使用cocoapods可以创建远程私有库，供项目使用。首先需要在github上创建一个远程索引库，然后使用cocopods在本地创建文件夹，并与远程私有库进行关联。再在github上创建远程组件库，接着使用pod创建本地工程，然后修改组件库</description>
    </item>
    
    <item>
      <title>指定Podfile中source</title>
      <link>https://iihui.github.io/post/ios-pods-question/</link>
      <pubDate>Tue, 31 Mar 2020 08:08:00 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/ios-pods-question/</guid>
      <description>在笔记本上安装好Cocoapods之后，执行pod install后报trunk repo update failed，解决方案是在Podfile中指定另一个源仓库。 报错信息 解决方案 解决方案是在Podfile中指定source，如下所示： platform :ios, &amp;#39;8.0&amp;#39; source &amp;#39;https://github.com/CocoaPods/Specs.git&amp;#39; use_frameworks! target &amp;#39;NewWCDB&amp;#39; do pod &amp;#39;WCDB.swift&amp;#39; end 如</description>
    </item>
    
    <item>
      <title>指定Podfile中source</title>
      <link>https://iihui.github.io/post/post/ios-pods-question/</link>
      <pubDate>Tue, 31 Mar 2020 08:08:00 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/post/ios-pods-question/</guid>
      <description>在笔记本上安装好Cocoapods之后，执行pod install后报trunk repo update failed，解决方案是在Podfile中指定另一个源仓库。 报错信息 解决方案 解决方案是在Podfile中指定source，如下所示： platform :ios, &amp;#39;8.0&amp;#39; source &amp;#39;https://github.com/CocoaPods/Specs.git&amp;#39; use_frameworks! target &amp;#39;NewWCDB&amp;#39; do pod &amp;#39;WCDB.swift&amp;#39; end 如</description>
    </item>
    
    <item>
      <title>验证码绑定界面</title>
      <link>https://iihui.github.io/post/ios-login/</link>
      <pubDate>Sat, 28 Mar 2020 15:43:49 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/ios-login/</guid>
      <description>验证码绑定，包括个人账户，和虚拟账户。之前写的验证码绑定界面扩展性太差，这次决定尝试使用tableView实现验证码绑定界面，主要是为了增加可扩展性，便于当需要增加新的验证信息时，可以不大动原界面。这篇文章是对应的ViewControlle</description>
    </item>
    
    <item>
      <title>验证码绑定界面</title>
      <link>https://iihui.github.io/post/post/ios-login/</link>
      <pubDate>Sat, 28 Mar 2020 15:43:49 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/post/ios-login/</guid>
      <description>验证码绑定，包括个人账户，和虚拟账户。之前写的验证码绑定界面扩展性太差，这次决定尝试使用tableView实现验证码绑定界面，主要是为了增加可扩展性，便于当需要增加新的验证信息时，可以不大动原界面。这篇文章是对应的ViewControlle</description>
    </item>
    
    <item>
      <title>AutoLayout</title>
      <link>https://iihui.github.io/post/ios-autolayout/</link>
      <pubDate>Wed, 25 Mar 2020 11:52:16 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/ios-autolayout/</guid>
      <description>苹果公司推出的AutoLayout是一个基于约束，动态计算视图大小和位置的库。它以布局引擎系统Layout Engine为核心，采用了Cassowary布局算法，在简化布局思路的同时，还保证了布局的高效性。布局算法Cassowary能够有效解</description>
    </item>
    
    <item>
      <title>AutoLayout</title>
      <link>https://iihui.github.io/post/post/ios-autolayout/</link>
      <pubDate>Wed, 25 Mar 2020 11:52:16 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/post/ios-autolayout/</guid>
      <description>苹果公司推出的AutoLayout是一个基于约束，动态计算视图大小和位置的库。它以布局引擎系统Layout Engine为核心，采用了Cassowary布局算法，在简化布局思路的同时，还保证了布局的高效性。布局算法Cassowary能够有效解</description>
    </item>
    
    <item>
      <title>不常见的关键字</title>
      <link>https://iihui.github.io/post/ios-keywords/</link>
      <pubDate>Wed, 25 Mar 2020 10:22:29 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/ios-keywords/</guid>
      <description>使用Swift写代码时，经常会遇到一些不常见的关键词或者常用关键词的特殊使用场景，因为比较少使用，通常这些不常见的关键词或者特殊场景很容易忘记，这篇文章用于记录这些情况。 便利构造函数 convenience用于构造函数中，称之为便利构造函数。</description>
    </item>
    
    <item>
      <title>不常见的关键字</title>
      <link>https://iihui.github.io/post/post/ios-keywords/</link>
      <pubDate>Wed, 25 Mar 2020 10:22:29 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/post/ios-keywords/</guid>
      <description>使用Swift写代码时，经常会遇到一些不常见的关键词或者常用关键词的特殊使用场景，因为比较少使用，通常这些不常见的关键词或者特殊场景很容易忘记，这篇文章用于记录这些情况。 便利构造函数 convenience用于构造函数中，称之为便利构造函数。</description>
    </item>
    
    <item>
      <title>pcm No such file or directory</title>
      <link>https://iihui.github.io/post/ios-pcm-warnning/</link>
      <pubDate>Mon, 23 Mar 2020 15:15:31 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/ios-pcm-warnning/</guid>
      <description>在封装静态framework时，在本机上没有报任何警告，在其他机器上却报warning: ***/Library/Developer/Xcode/DerivedData/ModuleCache.noindex/2MSIKR0H4Y5WQ/Foundation-A3SOD99KJ0S9.pcm: No such file or directory警告。这篇文章就是解决这个警告问题，主要是改变工程的build setting有三个地方需要修改，暂且归为三步。 第一步 首先在B</description>
    </item>
    
    <item>
      <title>pcm No such file or directory</title>
      <link>https://iihui.github.io/post/post/ios-pcm-warnning/</link>
      <pubDate>Mon, 23 Mar 2020 15:15:31 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/post/ios-pcm-warnning/</guid>
      <description>在封装静态framework时，在本机上没有报任何警告，在其他机器上却报warning: ***/Library/Developer/Xcode/DerivedData/ModuleCache.noindex/2MSIKR0H4Y5WQ/Foundation-A3SOD99KJ0S9.pcm: No such file or directory警告。这篇文章就是解决这个警告问题，主要是改变工程的build setting有三个地方需要修改，暂且归为三步。 第一步 首先在B</description>
    </item>
    
    <item>
      <title>强制浅色模式</title>
      <link>https://iihui.github.io/post/ios-light-style/</link>
      <pubDate>Sun, 22 Mar 2020 06:18:48 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/ios-light-style/</guid>
      <description>iOS 13之后，一旦使用了系统的组件，如果用户开启了深色模式，则这些组件的颜色会随着发生变化，而此时某些使用了自定义颜色的组件对应的颜色不会改变，如此将会非常难看。一个简单的方式是强制App为浅色模式，使得系统开启了深色模式后，App还是之前的</description>
    </item>
    
    <item>
      <title>强制浅色模式</title>
      <link>https://iihui.github.io/post/post/ios-light-style/</link>
      <pubDate>Sun, 22 Mar 2020 06:18:48 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/post/ios-light-style/</guid>
      <description>iOS 13之后，一旦使用了系统的组件，如果用户开启了深色模式，则这些组件的颜色会随着发生变化，而此时某些使用了自定义颜色的组件对应的颜色不会改变，如此将会非常难看。一个简单的方式是强制App为浅色模式，使得系统开启了深色模式后，App还是之前的</description>
    </item>
    
    <item>
      <title>iOS tips</title>
      <link>https://iihui.github.io/post/ios-tips/</link>
      <pubDate>Thu, 19 Mar 2020 21:27:43 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/ios-tips/</guid>
      <description>类与结构体 共同点 定义属性用于存储值 定义方法用于提供方法 定义下标操作使得可以通过下标语法来访问实例所包含的值 定义构造器用于生成初始值 通过扩展协议来增加默认实现的功能 实现协议来提供某种标准功能 类多一点 允许一个类继承另一个类的特镇 类型转换允许在运</description>
    </item>
    
    <item>
      <title>iOS tips</title>
      <link>https://iihui.github.io/post/post/ios-tips/</link>
      <pubDate>Thu, 19 Mar 2020 21:27:43 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/post/ios-tips/</guid>
      <description>类与结构体 共同点 定义属性用于存储值 定义方法用于提供方法 定义下标操作使得可以通过下标语法来访问实例所包含的值 定义构造器用于生成初始值 通过扩展协议来增加默认实现的功能 实现协议来提供某种标准功能 类多一点 允许一个类继承另一个类的特镇 类型转换允许在运</description>
    </item>
    
    <item>
      <title>AES 实现</title>
      <link>https://iihui.github.io/post/ios-aes/</link>
      <pubDate>Tue, 17 Mar 2020 17:24:04 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/ios-aes/</guid>
      <description>高级加密标准(AES,Advanced Encryption Standard)，是美国联邦政府采用的一种区块加密标准。这个标准用来替代原先的DES，已经被多方分析且广为全世界所使用是最常见的对称加密算法，它是一种对称加密算法（对称加密是指加密和解密使用相同的密</description>
    </item>
    
    <item>
      <title>AES 实现</title>
      <link>https://iihui.github.io/post/post/ios-aes/</link>
      <pubDate>Tue, 17 Mar 2020 17:24:04 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/post/ios-aes/</guid>
      <description>高级加密标准(AES,Advanced Encryption Standard)，是美国联邦政府采用的一种区块加密标准。这个标准用来替代原先的DES，已经被多方分析且广为全世界所使用是最常见的对称加密算法，它是一种对称加密算法（对称加密是指加密和解密使用相同的密</description>
    </item>
    
    <item>
      <title>iOS开发使用Safari调试WebView</title>
      <link>https://iihui.github.io/post/ios-debug-safari/</link>
      <pubDate>Thu, 27 Feb 2020 06:14:27 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/ios-debug-safari/</guid>
      <description>在Mac上调试iOS WebView既需要在Mac上的Safari浏览器上开启开发者选项，也需要在iOS设备上开启Web检查功能。 开启Mac的开发者菜单 首先需要开启Mac上Safari浏览器的显示开发者菜单选项。即先进入到Safari浏览器中</description>
    </item>
    
    <item>
      <title>iOS开发使用Safari调试WebView</title>
      <link>https://iihui.github.io/post/post/ios-debug-safari/</link>
      <pubDate>Thu, 27 Feb 2020 06:14:27 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/post/ios-debug-safari/</guid>
      <description>在Mac上调试iOS WebView既需要在Mac上的Safari浏览器上开启开发者选项，也需要在iOS设备上开启Web检查功能。 开启Mac的开发者菜单 首先需要开启Mac上Safari浏览器的显示开发者菜单选项。即先进入到Safari浏览器中</description>
    </item>
    
    <item>
      <title>where 关键字</title>
      <link>https://iihui.github.io/post/ios-where/</link>
      <pubDate>Sat, 22 Feb 2020 20:49:20 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/ios-where/</guid>
      <description>Swift中的where关键字主要用于限定条件，既可在switch语句中使用，也可以在for in中使用，还可以用在扩展中用于限定应该遵循某种协议。 switch中使用 在switch语句中使用，where一般是配合if let来用于限定某些条件，</description>
    </item>
    
    <item>
      <title>where 关键字</title>
      <link>https://iihui.github.io/post/post/ios-where/</link>
      <pubDate>Sat, 22 Feb 2020 20:49:20 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/post/ios-where/</guid>
      <description>Swift中的where关键字主要用于限定条件，既可在switch语句中使用，也可以在for in中使用，还可以用在扩展中用于限定应该遵循某种协议。 switch中使用 在switch语句中使用，where一般是配合if let来用于限定某些条件，</description>
    </item>
    
    <item>
      <title>Swift 方法交换中的addMethod</title>
      <link>https://iihui.github.io/post/ios-addmethod/</link>
      <pubDate>Fri, 21 Feb 2020 10:18:17 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/ios-addmethod/</guid>
      <description>Swizzle是OC的黑魔法之一，可以在运行时对两个方法的实现进行交换，也就是用户可以用自己的方法替换原来的方法实现，做一些其它事情。Swift也可以使用运行时的方法交换，如果要了解Swift的方法交换，首先应该了解class_addMet</description>
    </item>
    
    <item>
      <title>Swift 方法交换中的addMethod</title>
      <link>https://iihui.github.io/post/post/ios-addmethod/</link>
      <pubDate>Fri, 21 Feb 2020 10:18:17 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/post/ios-addmethod/</guid>
      <description>Swizzle是OC的黑魔法之一，可以在运行时对两个方法的实现进行交换，也就是用户可以用自己的方法替换原来的方法实现，做一些其它事情。Swift也可以使用运行时的方法交换，如果要了解Swift的方法交换，首先应该了解class_addMet</description>
    </item>
    
    <item>
      <title>UIControl</title>
      <link>https://iihui.github.io/post/ios-uicontrol/</link>
      <pubDate>Fri, 14 Feb 2020 20:53:50 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/ios-uicontrol/</guid>
      <description>UIControl是UIView的子类，也是UIResponder的子类。是UIButton，UISwitch，UITextField等控件的父类。它本身定义了一些属性和方法，但是不能直接使用。 方法交换 extension UIControl { class func swizzleMethod() { struct Static { static var token = NSUUID().uuidString } // 确保</description>
    </item>
    
    <item>
      <title>UIControl</title>
      <link>https://iihui.github.io/post/post/ios-uicontrol/</link>
      <pubDate>Fri, 14 Feb 2020 20:53:50 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/post/ios-uicontrol/</guid>
      <description>UIControl是UIView的子类，也是UIResponder的子类。是UIButton，UISwitch，UITextField等控件的父类。它本身定义了一些属性和方法，但是不能直接使用。 方法交换 extension UIControl { class func swizzleMethod() { struct Static { static var token = NSUUID().uuidString } // 确保</description>
    </item>
    
    <item>
      <title>Swift 中的反射</title>
      <link>https://iihui.github.io/post/ios-reflection/</link>
      <pubDate>Fri, 14 Feb 2020 17:19:38 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/ios-reflection/</guid>
      <description>在计算机学中，reflection(反射)是指计算机程序在runtime时可以访问、检测和修改它本身状态或行为的一种能力。比较形象的说法就是，反射是程序在运行的时候能够观察并且修改自己的行为。 @objc Swift是一门静态语言，和OC不同，不能在运</description>
    </item>
    
    <item>
      <title>Swift 中的反射</title>
      <link>https://iihui.github.io/post/post/ios-reflection/</link>
      <pubDate>Fri, 14 Feb 2020 17:19:38 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/post/ios-reflection/</guid>
      <description>在计算机学中，reflection(反射)是指计算机程序在runtime时可以访问、检测和修改它本身状态或行为的一种能力。比较形象的说法就是，反射是程序在运行的时候能够观察并且修改自己的行为。 @objc Swift是一门静态语言，和OC不同，不能在运</description>
    </item>
    
    <item>
      <title>飞书特色功能</title>
      <link>https://iihui.github.io/post/ios-feishu/</link>
      <pubDate>Tue, 11 Feb 2020 07:12:18 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/ios-feishu/</guid>
      <description>飞书把更多的需求优化倾向于团队成员，而不是管理者。所以它以「即时沟通」为中心，将在线文档、云盘、日历等功能全部整合在一起。 例如，可以在IM（即时通讯）界面直接创建文档，共同编辑，也可以在文档中进一步讨论细节问题；或是发起一个日程，在日程中直</description>
    </item>
    
    <item>
      <title>飞书特色功能</title>
      <link>https://iihui.github.io/post/post/ios-feishu/</link>
      <pubDate>Tue, 11 Feb 2020 07:12:18 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/post/ios-feishu/</guid>
      <description>飞书把更多的需求优化倾向于团队成员，而不是管理者。所以它以「即时沟通」为中心，将在线文档、云盘、日历等功能全部整合在一起。 例如，可以在IM（即时通讯）界面直接创建文档，共同编辑，也可以在文档中进一步讨论细节问题；或是发起一个日程，在日程中直</description>
    </item>
    
    <item>
      <title>iOS 可视化埋点</title>
      <link>https://iihui.github.io/post/ios-log-point/</link>
      <pubDate>Sun, 09 Feb 2020 16:54:52 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/ios-log-point/</guid>
      <description>埋点方案大体上可以归为3类：代码埋点，可视化埋点，无埋点。代码埋点，由开发人员在触发事件的具体方法里，植入多行代码把需要上传的数据发送至服务端。可视化埋点，根据标识来识别每一个事件，针对指定的事件进行取参埋点。而事件的标识与参数信息都写在配</description>
    </item>
    
    <item>
      <title>iOS 可视化埋点</title>
      <link>https://iihui.github.io/post/post/ios-log-point/</link>
      <pubDate>Sun, 09 Feb 2020 16:54:52 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/post/ios-log-point/</guid>
      <description>埋点方案大体上可以归为3类：代码埋点，可视化埋点，无埋点。代码埋点，由开发人员在触发事件的具体方法里，植入多行代码把需要上传的数据发送至服务端。可视化埋点，根据标识来识别每一个事件，针对指定的事件进行取参埋点。而事件的标识与参数信息都写在配</description>
    </item>
    
  </channel>
</rss>