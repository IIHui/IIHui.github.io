<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>code on Keep It Simple</title>
    <link>https://IIHui.github.io/categories/code/</link>
    <description>Recent content in code on Keep It Simple</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Tue, 04 Feb 2020 13:15:10 +0000</lastBuildDate>
    
	<atom:link href="https://IIHui.github.io/categories/code/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Objective-C Runtime</title>
      <link>https://IIHui.github.io/post/oc-runtime/</link>
      <pubDate>Tue, 04 Feb 2020 13:15:10 +0000</pubDate>
      
      <guid>https://IIHui.github.io/post/oc-runtime/</guid>
      <description>Runtime中的概念解析 所有的Objective-C方法调用[receiver selector]在编译时都会转化为对应的C函数objc_msgSend(receiver，selector)的调用。Object对象 在objc/runtime.h中，Object被定义为指向objc_object结构体的指针，objc_object结构体的定义如下： //runtime对objc_object结构体的定</description>
    </item>
    
    <item>
      <title>GCD</title>
      <link>https://IIHui.github.io/post/ios-dispatchqueue/</link>
      <pubDate>Thu, 07 Mar 2019 09:28:12 +0000</pubDate>
      
      <guid>https://IIHui.github.io/post/ios-dispatchqueue/</guid>
      <description>参考资料 参考资料1 参考资料2</description>
    </item>
    
    <item>
      <title>第三方库放到Cocoapods中</title>
      <link>https://IIHui.github.io/post/ios-cocoapods-storage/</link>
      <pubDate>Fri, 01 Mar 2019 09:34:41 +0000</pubDate>
      
      <guid>https://IIHui.github.io/post/ios-cocoapods-storage/</guid>
      <description>因项目需要引用百度语音合成SDK，但这个第三方库的.a文件过于庞大，按规定不能直接放到项目中，需要放到项目依赖的Cocoapods仓库中。因为已有相应的模板，所以只要按照要求修改对应的文件，然后执行相应的命令即可，现将这一过程总结为5步。 第一步 第一步为修改.podspec文件，为了修改podspec文件，首先必须创建第三方库目录。下图为第三方库存放的目录结构，如需新建一个第三方库目录，则选中任意一</description>
    </item>
    
    <item>
      <title>引入百度语音合成</title>
      <link>https://IIHui.github.io/post/ios-baidusynthesizer/</link>
      <pubDate>Thu, 28 Feb 2019 11:08:15 +0000</pubDate>
      
      <guid>https://IIHui.github.io/post/ios-baidusynthesizer/</guid>
      <description>因项目中需要用到百度语音合成SDK，因此自己先建了一个工程作为引入测试，总结下来为准备&amp;ndash;&amp;gt;导入&amp;ndash;&amp;gt;创建应用&amp;ndash;&amp;gt;测试。 准备工作 首先从百度官网下载百度语音合成的SDK,如下图所示首先在左边选择语音合成，然后在右边选择iOS版的离在线融合SDDK: 导入 有两部分需要导入，第一部分是导入百度语音合成所需的文件，第二部分是导入百度语音合成依赖的框架，下面分</description>
    </item>
    
    <item>
      <title>H5视频播放</title>
      <link>https://IIHui.github.io/post/ios-html-player/</link>
      <pubDate>Mon, 25 Feb 2019 08:52:09 +0000</pubDate>
      
      <guid>https://IIHui.github.io/post/ios-html-player/</guid>
      <description>最近APP出现了在iPhone上拍的视频，同步到Android手机后播放不了的问题，第一感觉应该是iPhone上录制视频所使用的编码不兼容Android。经过沟通，了解到播放视频是用H5嵌入的，因为手边没有视频播放源码和可测试的Android设备，为了验证我的猜测，尝试着先改变iPhone录制视频时的编码方式，然后写一段播放视频的H5，用Chrome浏览器进行测试能够正常播放。 确认编码 首先找到视频</description>
    </item>
    
    <item>
      <title>半透明的悬浮提示窗</title>
      <link>https://IIHui.github.io/post/ios-alert-window/</link>
      <pubDate>Sun, 24 Feb 2019 19:50:43 +0000</pubDate>
      
      <guid>https://IIHui.github.io/post/ios-alert-window/</guid>
      <description>因项目中需要一个悬浮提示窗，从网上找到一篇以OC为示例的文章，因为公司项目是Swift写的，因此需要将OC转为Swift。 OC代码 .h文件 //CustomAlertWindow.h #import &amp;lt;UIKit/UIKit.h&amp;gt;typedef NS_ENUM(NSInteger, AlertWindowPositionOption) { AlertWindowPositionTopMiddle = 0, AlertWindowPositionCenter, AlertWindowPositionBottomMiddle }; @interface CustomAlertWindow : UIWindow + (instancetype)aletWindowWithPositionOption:(AlertWindowPositionOption)positionType andInfoText:(NSString *)text; //显示 - (void)show; // 消失 - (void)dismiss; @end .m文件 //CustomAlertWindow.m #import &amp;#34;CustomAlertWindow.h&amp;#34; #define LABEL_MARGIN 10 //Label的外边距 #define CENTER_Y_TO_EDGE 80 //悬浮窗中心点距边缘的纵坐标值 @implementation CustomAlertWindow + (instancetype)aletWindowWithPositionOption:(AlertWindowPositionOption)positionType andInfoText:(NSString *)text { return [[CustomAlertWindow alloc] initWithPositionOption:positionType andInfoText:text]; } - (instancetype)initWithPositionOption:(AlertWindowPositionOption)positionType andInfoText:(NSString *)text { self = [super init]; if (self) { UILabel *infoLabel = [[UILabel alloc] initWithFrame:CGRectMake(0, 0, 40, 15)]; infoLabel.text = text; infoLabel.textAlignment = NSTextAlignmentCenter; infoLabel.font = [UIFont systemFontOfSize:13]; infoLabel.textColor = [UIColor whiteColor]; //label尺寸适应</description>
    </item>
    
    <item>
      <title>UIWebview 加载含特殊字符网页</title>
      <link>https://IIHui.github.io/post/ios-webview-html/</link>
      <pubDate>Sun, 24 Feb 2019 18:57:05 +0000</pubDate>
      
      <guid>https://IIHui.github.io/post/ios-webview-html/</guid>
      <description>UIWebview中加载的html文件中如果含有\n,&#39;等特殊字符时，显示为一片空白，通过查阅资料得知需要将这些特殊字符进行预处理。 预处理 class HTMLUtils{ static func escapsedHTML(html: String)-&amp;gt;String{ var result = html if !result.isEmpty{ result = result.replacingOccurrences(of: &amp;#34;\\&amp;#34;, with: &amp;#34;\\\\&amp;#34;) result = result.replacingOccurrences(of: &amp;#34;\&amp;#34;&amp;#34;, with: &amp;#34;\\\&amp;#34;&amp;#34;) result = result.replacingOccurrences(of: &amp;#34;&amp;#39;&amp;#34;, with: &amp;#34;\\&amp;#39;&amp;#34;) result = result.replacingOccurrences(of: &amp;#34;\r&amp;#34;, with: &amp;#34;\\r&amp;#34;) result = result.replacingOccurrences(of: &amp;#34;\n&amp;#34;, with: &amp;#34;\\n&amp;#34;) } return result } }</description>
    </item>
    
    <item>
      <title>JS事件捕获</title>
      <link>https://IIHui.github.io/post/js-event/</link>
      <pubDate>Fri, 25 Jan 2019 11:13:43 +0000</pubDate>
      
      <guid>https://IIHui.github.io/post/js-event/</guid>
      <description>DOM事件从发生到开始经历了三个阶段，分别为捕获阶段、命中阶段以及冒泡阶段。捕获阶段表示从最上层开始，直到最下层(点击的那个target元素)，路过的所有节点都可以捕获到该事件。命中阶段:如果某个事件到达了target，它就会进行处理。冒泡阶段:事件从最下层向上传递，依次触发父元素的该事件处理。</description>
    </item>
    
    <item>
      <title>Unicode简介</title>
      <link>https://IIHui.github.io/post/cs-unicode/</link>
      <pubDate>Thu, 24 Jan 2019 08:54:16 +0000</pubDate>
      
      <guid>https://IIHui.github.io/post/cs-unicode/</guid>
      <description>计算机只认识0101...这样的串，但是人眼看0101这样的串比较麻烦，为了方便人们阅读，我们通常使用十进制、八进制、十六进制来标识一个数字。除了数之外，我们还要文字和图片需要标识，那么为了能够使计算机认识这些 参考资料 参考资料</description>
    </item>
    
    <item>
      <title>HTTP 网络请求</title>
      <link>https://IIHui.github.io/post/ios-network-tcp/</link>
      <pubDate>Fri, 18 Jan 2019 09:37:41 +0000</pubDate>
      
      <guid>https://IIHui.github.io/post/ios-network-tcp/</guid>
      <description>参考资料 参考资料</description>
    </item>
    
    <item>
      <title>创建新的Target</title>
      <link>https://IIHui.github.io/post/ios-new-target/</link>
      <pubDate>Thu, 10 Jan 2019 11:18:46 +0000</pubDate>
      
      <guid>https://IIHui.github.io/post/ios-new-target/</guid>
      <description>因项目需要新建一条众测流水线，因此首先需要基于DEV环境新建一个Target，然后将新建的Target对配置到新建的流水线上。 Duplicate 新Target的创建一般以已有的Target为模板，如下图所示，首先选中模板Target，然后右键点击选中Duplicate就能创建新的Target: 修改Target名字 首先点击新的Target然后按回车键修改名字，此时修改的名字 修改plist 一旦点击Duplicate就</description>
    </item>
    
    <item>
      <title>Range的保存与恢复</title>
      <link>https://IIHui.github.io/post/js-focus-save/</link>
      <pubDate>Wed, 09 Jan 2019 16:58:44 +0000</pubDate>
      
      <guid>https://IIHui.github.io/post/js-focus-save/</guid>
      <description>在iOS 11.3以下的UIWebview中插入图片时，因图片选择器的弹出导致UIWebview失去焦点，故在插入图片前需先保存图片将要插入的位置。 保存range区域 图片选择器打开前，利用一个全局的Range对象保存插入前光标所在的位置的Range对象： //插入图片和超链接的时候因为webview会失去焦点，因此需要保存range区域 let currentSelection; function backupRange() { let selection = window.getSelection(); if (selection.rangeCount) { let range = selection.getRangeAt(0); this.currentSelection = { &amp;#34;startContainer&amp;#34;: range.startContainer, &amp;#34;startOffset&amp;#34;: range.startOffset, &amp;#34;endContainer&amp;#34;: range.endContainer, &amp;#34;endOffset&amp;#34;: range.endOffset } } } 恢复R</description>
    </item>
    
    <item>
      <title>Swift访问权限</title>
      <link>https://IIHui.github.io/post/ios-access-control/</link>
      <pubDate>Wed, 09 Jan 2019 09:18:25 +0000</pubDate>
      
      <guid>https://IIHui.github.io/post/ios-access-control/</guid>
      <description>访问权限用于限制部分代码被其它源文件或者模块访问，目的是隐藏某些代码的实现细节。在Swift中可以设置类型(类、结构和枚举)的访问权限，也可以设置属性和方法的访问权限。Swift提供了5个访问级别，这些访问级别以模块和源文件为区分粒度。 模块和源文件 模块 模块是指独立的代码单元，在iOS中框架或应用程序就是一个独立模块。在一个模块中可以用import关键字导入另一个模块。 源文件 源文件即Swift中的源</description>
    </item>
    
    <item>
      <title>img添加和取消点击监听</title>
      <link>https://IIHui.github.io/post/js-image-addclicklistener/</link>
      <pubDate>Tue, 08 Jan 2019 19:46:39 +0000</pubDate>
      
      <guid>https://IIHui.github.io/post/js-image-addclicklistener/</guid>
      <description>一篇图文笔记可能有多张图片，目前的需求为单击图片后开始预览图片。想到的解决思路有两种，第一种是为每张图片添加点击事件的监听，这种方式的麻烦在于要监听是否有新图片插入，一旦有新图片插入时则要对其加入点击事件的监听；第二种则是全局监听点击事件，用户一旦点击，则判断该点击事件是否在img标签上，如果是则进入图片预览，否则什么也不做。 第一种方式 每次进入图文笔记的浏览模式时为所有img添加点击事件的监听。因</description>
    </item>
    
    <item>
      <title>img点击监听</title>
      <link>https://IIHui.github.io/post/js-image-clickedlistener/</link>
      <pubDate>Tue, 08 Jan 2019 19:46:39 +0000</pubDate>
      
      <guid>https://IIHui.github.io/post/js-image-clickedlistener/</guid>
      <description>一篇图文笔记可能有多张图片，目前的需求为单击图片后开始预览图片。想到的解决思路有两种，第一种是为每张图片添加点击事件的监听，这种方式的麻烦在于要监听是否有新图片插入，一旦有新图片插入时则要对其加入点击事件的监听；第二种则是全局监听点击事件，用户一旦点击，则判断该点击事件是否在img标签上，如果是则进入图片预览，否则什么也不做。 第一种方式 每次进入图文笔记的浏览模式时为所有img添加点击事件的监听。因</description>
    </item>
    
    <item>
      <title>单例模式</title>
      <link>https://IIHui.github.io/post/ios-swift-singleton/</link>
      <pubDate>Mon, 07 Jan 2019 23:29:33 +0000</pubDate>
      
      <guid>https://IIHui.github.io/post/ios-swift-singleton/</guid>
      <description>单例模式(Singleton Pattern)属于创建型模式，该模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有一个单例对象被创建。 第一种方式 利用Swift中全局变量的懒加载和全局变量初始化时默认使用dispatch_once以保证全局变量的构造器只会被调用一次: let sharedManager = MyManager(string: someString) //定义全局变量 class MyManager { let string: String //初始化器 init(string: String) { self.string = string } } 第二种方式 利用static和private两个关键字,sta</description>
    </item>
    
    <item>
      <title>基于PageController的图片预览</title>
      <link>https://IIHui.github.io/post/ios-image-preview/</link>
      <pubDate>Sat, 05 Jan 2019 11:49:11 +0000</pubDate>
      
      <guid>https://IIHui.github.io/post/ios-image-preview/</guid>
      <description>参考资料 参考资料 参考资料 参考资料</description>
    </item>
    
    <item>
      <title>LLDB 调试</title>
      <link>https://IIHui.github.io/post/ios-debug/</link>
      <pubDate>Fri, 04 Jan 2019 14:15:45 +0000</pubDate>
      
      <guid>https://IIHui.github.io/post/ios-debug/</guid>
      <description>LLDB是一个庞大的工具,内置了许多有用的命令。 命令语法结构 &amp;lt;command&amp;gt; [&amp;lt;subcommand&amp;gt; [&amp;lt;subcommand&amp;gt;...]] &amp;lt;action&amp;gt; [-options [option-value]] [argument [argument...]] 其中： command和subcommand为LLDB调试命令的名称，命令和子命令按照层级结构来排列：一个命令对象为跟随其的子命令对象创建一个上下文，子命令又为其子命令创建一个上下文，依此类推。 action 上面的这些元素之间通过空格来分割，如果某一元素自身含有空格，则可以使用双引用。而如果元素中又包含双引号，则可以使用反斜杠；或者元素</description>
    </item>
    
    <item>
      <title>多图片选择</title>
      <link>https://IIHui.github.io/post/ios-image-selector/</link>
      <pubDate>Fri, 04 Jan 2019 09:51:58 +0000</pubDate>
      
      <guid>https://IIHui.github.io/post/ios-image-selector/</guid>
      <description>第一步 JSAPI中有个文件选择器，而文件选择器中有选择多个图片的功能。首先在WebviewController.swift中找到: case UrlSchema.fileSelectorSchema.rawValue: //文件选择器 fileSelectorService.presentFileSelector(self.webConfig, params: paramDic) 第二步 首先查看fileSelectorService的创建: fileprivate lazy var fileSelectorService: FileSelectorService = FileSelectorService(callbackDelegate: self) 而FileSelectorService继承自BaseCallbackService: class FileSelectorService: BaseCallbackService { } func presentFileSelector(_ webConfig: WebConfig, params: NSDictionary) { self.urlParams = params var webFileType:WebFileType? if let type = params[&amp;#34;type&amp;#34;] as? String ,type != &amp;#34;&amp;#34;{ switch type { case &amp;#34;video&amp;#34;: webFileType = .video break case &amp;#34;photo&amp;#34;: webFileType = .image break</description>
    </item>
    
    <item>
      <title>Swift中for-in的各种姿势</title>
      <link>https://IIHui.github.io/post/swift-for-in/</link>
      <pubDate>Fri, 04 Jan 2019 08:16:45 +0000</pubDate>
      
      <guid>https://IIHui.github.io/post/swift-for-in/</guid>
      <description>Swift中只有一种形式的for循环，即for-in。但是for-in有多种形式，包括常规用法和区间循环。 常规用法 常规用法一般用于直接访问数组中的元素，分为直接访问和按索引访问： let arr = [34,78,789,-12] for item in arr{ print(item) } 在OC中是通过索引i来访问数组中的元素，在Swift中需要借助枚举enumerate来实现 for item in arr.enumerated(){ print(item.offset,item.element) } for (i,num) in arr.enumerated(){ print(i,num) } 区间循环 在Swift中...表示闭区间，例如0...10表示0，1，2，...，10；而</description>
    </item>
    
    <item>
      <title>iOS允许HTTP请求</title>
      <link>https://IIHui.github.io/post/ios-http/</link>
      <pubDate>Sat, 29 Dec 2018 11:05:00 +0000</pubDate>
      
      <guid>https://IIHui.github.io/post/ios-http/</guid>
      <description>在iOS 9之后，苹果默认要求App访问的url必须为https的安全链接，为了能在项目中请求Http链接，需要在项目中自动生成的Info.plist文件里，将App Transport Security Settings下的Allow Arbitrary Loads设置为YES「如果没有则先添加这两项」:</description>
    </item>
    
    <item>
      <title>AFNetworking 使用</title>
      <link>https://IIHui.github.io/post/ios-anfnetworking/</link>
      <pubDate>Fri, 28 Dec 2018 21:08:45 +0000</pubDate>
      
      <guid>https://IIHui.github.io/post/ios-anfnetworking/</guid>
      <description>AFNetworking是为OS X和iOS设计的一套网络框架，对NSURLConnection和NSURLSession做了封装，提供了丰富的API以及完善的错误解决方案。 func testAF(){ let url = URL(string: &amp;#34;https://www.waitsun.com/&amp;#34;) let manager = AFHTTPSessionManager(baseURL: url) manager.responseSerializer = AFHTTPResponseSerializer() //响应数据格式二进制的 let str = &amp;#34;fastscripts.html&amp;#34; manager.get(str, parameters: nil, progress:{(progress) in print(progress) }, success: { (task,result) in print(&amp;#34;success!&amp;#34;) if let data = result{ print(data) } }, failure: { (task,error) in print(&amp;#34;failed!&amp;#34;) print(error.localizedDescription) }) AFN常见问题 错误一 AFN支持接收application/json、text/json、text/javascr</description>
    </item>
    
    <item>
      <title>笔记剥离</title>
      <link>https://IIHui.github.io/post/ios-note-peel/</link>
      <pubDate>Wed, 26 Dec 2018 11:28:32 +0000</pubDate>
      
      <guid>https://IIHui.github.io/post/ios-note-peel/</guid>
      <description>需要处理的 集成百度语音到Framework，应当集成到基础模块 集成百度地图到Framework中，应该以接口的形式抽取出来 数据库剥离 用户数据同步 用户信息获取的剥离 已经遇到的问题 NoteLogInfo.swift 需要集成百度地图 需要配置ConfigNoteIP NoteSpeechViewController self.redCircle?.frame.y 中的y已经重命名为minY CGRect没有成员bottom NoteSpeechPresenter.swift 需要集成百度语音SDK 注意事项 不要将百度语音的SDK集成到FrameWork里，否则后续会发生冲突。 首先抽取一</description>
    </item>
    
    <item>
      <title>Framework</title>
      <link>https://IIHui.github.io/post/ios-framework/</link>
      <pubDate>Tue, 25 Dec 2018 11:45:01 +0000</pubDate>
      
      <guid>https://IIHui.github.io/post/ios-framework/</guid>
      <description>链接库 库是一种共享程序代码的方式，分为静态库和动态库。静态库链接时被完整地拷贝到可执行文件，多次使用时就会有多个副本。 而动态库在链接时不复制，程序运行时由系统动态加载到内存，供程序调用。动态库只加载一次到内存，然后供多个程序共用，以节省内存。 静态库的形式 在iOS中静态库分为.a和.framework。.a是一个纯二进制文件，.framework中除了二进制文件之外，还有资源文件。.a文件不能直接使</description>
    </item>
    
    <item>
      <title>桥接文件</title>
      <link>https://IIHui.github.io/post/ios-bridge/</link>
      <pubDate>Mon, 24 Dec 2018 23:41:52 +0000</pubDate>
      
      <guid>https://IIHui.github.io/post/ios-bridge/</guid>
      <description>因为历史原因，在使用Swift编程时，常常需要用到OC类中的方法，此时就需要使用桥接文件来引入OC中的头文件，以告诉Swift。 手动创建桥接文件 第一步 首先使用快捷键Command+N来新建一个文件： 第二步 选择Header File: 第三步 给Header File命名： 第四步 点击工程配置，添加关联： 第五步 设置桥接文件的路径： 第六步 将要引入的OC头文件，加入到桥接文件中，例如： //透云QR解码 #import &amp;#34;TYQRViewController.h&amp;#34; //显示GIF的</description>
    </item>
    
    <item>
      <title>WKWebView</title>
      <link>https://IIHui.github.io/post/ios-wkwebview/</link>
      <pubDate>Mon, 24 Dec 2018 08:47:19 +0000</pubDate>
      
      <guid>https://IIHui.github.io/post/ios-wkwebview/</guid>
      <description>使用 self.webView.scrollView.addObserver(self, forKeyPath: &amp;#34;contentSize&amp;#34;, options: .new, context: nil) } override func observeValue(forKeyPath keyPath: String?, of object: Any?, change: [NSKeyValueChangeKey : Any]?, context: UnsafeMutableRawPointer?) { if let key = keyPath, key == &amp;#34;contentSize&amp;#34;{ let fittingSize = self.webView.sizeThatFits(CGSize.zero) self.webView.frame = CGRect(x: 0, y: noteTitleTextField.frame.height, width: fittingSize.width, height: fittingSize.height) } }</description>
    </item>
    
    <item>
      <title>JS的prototype</title>
      <link>https://IIHui.github.io/post/js-prototype/</link>
      <pubDate>Thu, 20 Dec 2018 19:43:47 +0000</pubDate>
      
      <guid>https://IIHui.github.io/post/js-prototype/</guid>
      <description>在JS中，每当定义一个对象(函数也是对象)时，对象中都会包含一些预定义的属性；每个对象都有一个prototype对象，这个属性指向函数的原型对象。 原型对象 缘由 Brendan Eich在设计JS时，将所有的数据类型都设计为对象，因此需要有一种机制将这些对象都联系起来。但他只想设计一种简易的脚本语言，所以没有引入类的概念，因为一旦有了类的概念，JS就是一种完整的面向对象的编程语言。 借鉴了Java和C++使用new来</description>
    </item>
    
    <item>
      <title>iOS 版本检查</title>
      <link>https://IIHui.github.io/post/ios-new-version/</link>
      <pubDate>Thu, 20 Dec 2018 11:53:15 +0000</pubDate>
      
      <guid>https://IIHui.github.io/post/ios-new-version/</guid>
      <description>首先由AboutViewController中的presenter调用其requestLastestVersion方法，而presenter是 AboutPresenter类的实例： lazy var presenter:AboutPresenter = AboutPresenter(delegate:self) presenter.requestLatestVersion() AboutPresenter类 而AboutPresenter类的实现如下所示: import Foundation protocol AboutPresenterDelegate:class { func updateUIForLatestVersion(shouldUpdate:Bool,updateMessage:String,updateUrl:String,minOSVersion: String?) } class AboutPresenter:NSObject,WelcomeHttpProtocol { lazy var webConfigs:[WebConfig?] = [self.webConfigService.versionDescriptionWebConfig,self.webConfigService.teamWebConfig,self.webConfigService.statisticWebConfig] let publishVersion:String = UpdateService().publishVersion let appDelegate = UIApplication.shared.delegate as! AppDelegate let deviceID:String = EnvironmentService.shared.deviceID fileprivate lazy var welcomHttpController: WelcomeHttpController = WelcomeHttpController(delegate: self) fileprivate lazy var webConfigService = WebConfigService() fileprivate weak var delegate:AboutPresenterDelegate? init(delegate:AboutPresenterDelegate?) { self.delegate = delegate } func requestLatestVersion() { welcomHttpController.requestLatestVersion(false) } func didReceiveLatestVersion(_ jsonData: JSON) {</description>
    </item>
    
    <item>
      <title>javascript 中this指针</title>
      <link>https://IIHui.github.io/post/js-this/</link>
      <pubDate>Wed, 19 Dec 2018 15:59:17 +0000</pubDate>
      
      <guid>https://IIHui.github.io/post/js-this/</guid>
      <description>在JavaScript中，this是动态绑定，或称为运行期绑定的，这导致JavaScript中的this关键字具有多重含义。它可以是全局对象、当前对象或者任意对象，这完全取决于函数的调用方式。 作为对象方法调用 在JS中，函数也是对象，因此函数可以作为一个对象的属性，此时该函数被称为该对象的方法，在使用这种调用方式时，this被自然地绑定到该对象。 var point = { x : 0, y : 0, moveTo : function(x, y) { this.x = this.x + x; this.y = this.y + y; } };</description>
    </item>
    
    <item>
      <title>html 元素分类</title>
      <link>https://IIHui.github.io/post/html-element-category/</link>
      <pubDate>Wed, 19 Dec 2018 10:48:17 +0000</pubDate>
      
      <guid>https://IIHui.github.io/post/html-element-category/</guid>
      <description>元素分类 HTML元素，指的是从开始标签(start tag)到结束标签(end tag)的所有代码。 HTML元素包括顶级元素，块级元素，内联元素。 顶级元素 html body frameset 块级元素 以块显示的元素，高度宽度都是可以设置的。块级元素默认状态下每次都占据一整行，后面的内容也必须再新起一行显示。 块级元素能够独立存在，块级元素是构成HTML的主要元素，任意一个块级元素均可以用盒模型来解释说明，常用的块级元素有: div常用来</description>
    </item>
    
    <item>
      <title>盒子模型</title>
      <link>https://IIHui.github.io/post/html-box-model/</link>
      <pubDate>Tue, 18 Dec 2018 10:39:23 +0000</pubDate>
      
      <guid>https://IIHui.github.io/post/html-box-model/</guid>
      <description>W3C组织建议把网页上所有的对象都放在一个盒(box)中，设计师可以在对象创建时控制这个盒子的属性，这些对象包括段落、列表、标题、图片以及层。盒模型主要定义四个区域：内容(content)、内边距(padding)、边框(border)和外边距(margin)。 模型图示 在CSS中margin是指从自身边框到另一个容器边框之间的距离，就是容器外距离。padding是指自身边框(border)到自身内</description>
    </item>
    
    <item>
      <title>selection 对象</title>
      <link>https://IIHui.github.io/post/js-selection/</link>
      <pubDate>Mon, 17 Dec 2018 16:46:24 +0000</pubDate>
      
      <guid>https://IIHui.github.io/post/js-selection/</guid>
      <description>在富文本编辑器中，需要控制光标的各种状态信息，位置信息。浏览器提供了selection对象和range对象来操作光标。 selection Selection对象表示用户选择的文本范围或插入符号的当前位置。它代表页面中的文本选区，可能横跨多个元素(element)，文本选区由用户拖拽鼠标而产生。 let selection = window.getSelection(); 通常需要操作selection对象所对应的用户选择区(range)(俗称拖蓝)，获取方式为: if (selection.rangeCount &amp;gt; 0) { let range = selection.getRangeAt(0); } //</description>
    </item>
    
    <item>
      <title>KVO 简介</title>
      <link>https://IIHui.github.io/post/ios-kvo/</link>
      <pubDate>Mon, 17 Dec 2018 15:09:08 +0000</pubDate>
      
      <guid>https://IIHui.github.io/post/ios-kvo/</guid>
      <description>在OC中KVO(key-value observing)是一种通知机制，定义了一种对象之间监控对方状态，并做出相应动作的机制。当指定的被观察者对象的属性被修改时，KVO都会自动去通知相应的观察者。 使用步骤 注册观察者，实时监听。 //第一个参数 observer：观察者 （这里观察self.myKVO对象的属性变化） //第二个参数 keyPath： 被观察的属性名称(这里观察 self.myKVO 中 num 属性值的改变) //第三个参数 o</description>
    </item>
    
    <item>
      <title>UITableView</title>
      <link>https://IIHui.github.io/post/ios-uitableview/</link>
      <pubDate>Mon, 17 Dec 2018 14:08:45 +0000</pubDate>
      
      <guid>https://IIHui.github.io/post/ios-uitableview/</guid>
      <description>UITableView可以显示多行多组数据,创建表格视图有两种风格，一种为Plain，另一种为Grouped。 点击不变色 func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&amp;gt; UITableViewCell { let cellId = &amp;#34;noteDetailInfoCell&amp;#34; let cell = tableView.dequeueReusableCell(withIdentifier: cellId, for: indexPath) as! NoteDetailInfoCell cell.titleLabel.text = info[indexPath.row+1].0 cell.titleLabel.textColor = &amp;#34;878997&amp;#34;.extHexStringToUIColor() cell.infoLabel.text = info[indexPath.row+1].1 cell.infoLabel.textColor = &amp;#34;4b5169&amp;#34;.extHexStringToUIColor() self.notetitleLabel.text = info[0].1 cell.selectionStyle = .none //点击某行不变色 return cell } 链接 range</description>
    </item>
    
    <item>
      <title>给图片添加点击监听</title>
      <link>https://IIHui.github.io/post/js-img/</link>
      <pubDate>Mon, 17 Dec 2018 08:34:15 +0000</pubDate>
      
      <guid>https://IIHui.github.io/post/js-img/</guid>
      <description>给所有图片添加监听 function setImagesClick(){ $(&amp;#39;body&amp;#39;).on(&amp;#39;click&amp;#39;,&amp;#39;img&amp;#39;,function(){ let position = this.offsetTop; //当前元素距离顶部的距离 //window.scrollTo(0,position) let result = {}; result.position = position.toString() let jsonString = JSON.stringify(result); let escapedJsonString = encodeURI(jsonString); //重新编码 let scheme = &amp;#34;position://&amp;#34;; document.location.href = scheme + &amp;#34;#&amp;#34; + escapedJsonString; //向ios发送 }); } 参考资料</description>
    </item>
    
    <item>
      <title>AVPlayer播放</title>
      <link>https://IIHui.github.io/post/ios-avplayer/</link>
      <pubDate>Fri, 14 Dec 2018 10:54:44 +0000</pubDate>
      
      <guid>https://IIHui.github.io/post/ios-avplayer/</guid>
      <description>监听AVPlayer播放结束 NotificationCenter.default.addObserver(self, selector: #selector(handlerPlayerFinish), name: NSNotification.Name.AVPlayerItemDidPlayToEndTime, object: self.playerItem) self.playerItem = AVPlayerItem(url: outputFileURL) self.avPlayer = AVPlayer(playerItem: self.playerItem)</description>
    </item>
    
    <item>
      <title>RunLoop</title>
      <link>https://IIHui.github.io/post/ios-runloop/</link>
      <pubDate>Fri, 14 Dec 2018 08:21:26 +0000</pubDate>
      
      <guid>https://IIHui.github.io/post/ios-runloop/</guid>
      <description>概念 一般来讲，一个线程一次只能执行一个任务，执行完成后，线程就会退出。若我们需要一个机制，让线程能随时处理事件但并不退出，通常的代码逻辑是下面这样的： function loop() { initialize(); do { var message = get_next_message(); process_message(message); } while (message != quit); } 这种模型被称为Event Loop,实现这种模型的关键点在于： 如何管理事件/消息 如何让线程在没有处理消息时休眠以避免资源占用，在有消息到来时立刻被唤醒。 因此，RunLoop实质上是一个对象，这个对象管理了其需要处理的事</description>
    </item>
    
    <item>
      <title>权限检查</title>
      <link>https://IIHui.github.io/post/ios-authority/</link>
      <pubDate>Thu, 13 Dec 2018 20:25:33 +0000</pubDate>
      
      <guid>https://IIHui.github.io/post/ios-authority/</guid>
      <description>相机权限检查 相机和音频的权限分为4种，分别是.denied,restricted,.authorized,.notDetermined,.authorized四种: .denied 未授权，用户曾经选择过拒绝授权。 .authorized 已经授权。 .restricted 未授权，例如家长控制。 .notDetermined 没有询问过用户是否授权，所以是未确定状态。 //MARK:检查相机访问权限 func cameraPermissionCheck(){ let authStatus = AVCaptureDevice.authorizationStatus(forMediaType: AVMediaTypeVideo) switch authStatus { case .denied, .restricted: let alert = UIAlertController(title: &amp;#34;提示&amp;#34;.localized, message: CameraAccessMsg, preferredStyle: .alert) let settingAction</description>
    </item>
    
    <item>
      <title>透明度渐变动画</title>
      <link>https://IIHui.github.io/post/ios-animation/</link>
      <pubDate>Thu, 13 Dec 2018 10:50:31 +0000</pubDate>
      
      <guid>https://IIHui.github.io/post/ios-animation/</guid>
      <description>CABasicAnimation关键帧动画 所谓关键帧动画，就是将Layer的属性作为KeyPath来注册，只要指定动画的起始帧和结束帧，然后自动计算和实现中间的过度的一种动画方式。 func recordingButtonAnimation(){ let animation = CABasicAnimation(keyPath: &amp;#34;opacity&amp;#34;) animation.fromValue = 1.0 animation.toValue = 0.3 animation.fillMode = kCAFillModeForwards animation.isRemovedOnCompletion = false animation.duration = self.animationDuration self.recordButton.layer.add(animation, forKey: nil) } //添加定时器 if recordingAnimationTimer == nil{ recordingAnimationTimer = Timer.scheduledTimer(timeInterval: self.animationDuration, target: self, selector: #selector(recordingButtonAnimation), userInfo: nil, repeats: true) } //销毁定时器 self.recordingAnimationTimer?.invalidate() //移除动画层 self.recordButton.layer.removeAllAnimations() 属性说明： duration动画时长，默认为0,不设置的话会快速执行完动画 speed 执行速度，默认</description>
    </item>
    
    <item>
      <title>透明度渐变动画</title>
      <link>https://IIHui.github.io/post/ios-opicity-animation/</link>
      <pubDate>Thu, 13 Dec 2018 10:50:31 +0000</pubDate>
      
      <guid>https://IIHui.github.io/post/ios-opicity-animation/</guid>
      <description>CABasicAnimation关键帧动画 所谓关键帧动画，就是将Layer的属性作为KeyPath来注册，只要指定动画的起始帧和结束帧，然后自动计算和实现中间的过度的一种动画方式。 func recordingButtonAnimation(){ let animation = CABasicAnimation(keyPath: &amp;#34;opacity&amp;#34;) animation.fromValue = 1.0 animation.toValue = 0.3 animation.fillMode = kCAFillModeForwards animation.isRemovedOnCompletion = false animation.duration = self.animationDuration self.recordButton.layer.add(animation, forKey: nil) } //添加定时器 if recordingAnimationTimer == nil{ recordingAnimationTimer = Timer.scheduledTimer(timeInterval: self.animationDuration, target: self, selector: #selector(recordingButtonAnimation), userInfo: nil, repeats: true) } //销毁定时器 self.recordingAnimationTimer?.invalidate() //移除动画层 self.recordButton.layer.removeAllAnimations() 属性说明： duration动画时长，默认为0,不设置的话会快速执行完动画 speed 执行速度，默认</description>
    </item>
    
    <item>
      <title>Gif的播放与暂停</title>
      <link>https://IIHui.github.io/post/ios-gif/</link>
      <pubDate>Thu, 13 Dec 2018 08:25:45 +0000</pubDate>
      
      <guid>https://IIHui.github.io/post/ios-gif/</guid>
      <description>Gif的播放有两种方式，一种是通过UIWebview；一种是通过UIImageView的方式。使用UIWebview的缺点是不可以暂停。 UIWebView import UIKit class ViewController: UIViewController { override func viewDidLoad() { super.viewDidLoad() guard let path = Bundle.main.path(forResource: &amp;#34;demo&amp;#34;, ofType:&amp;#34;gif&amp;#34;) else{ return } let url = URL(fileURLWithPath: path) do{ let gifData = try Data(contentsOf: url) let webView = UIWebView() webView.frame = CGRect(x: 0, y: 100, width: self.view.frame.width, height: 600) webView.scalesPageToFit = true webView.load(gifData, mimeType: &amp;#34;image/gif&amp;#34;, textEncodingName: String(), baseURL: NSURL() as URL) self.view.addSubview(webView) }catch{} } } UIImageView 使用UIImageView播放GIF有两个要点：一是从gif文件中获取图片数组，二是获取gif文件的播放时长。 import UIKit class ViewController: UIViewController { override func viewDidLoad() { super.viewDidLoad() let</description>
    </item>
    
    <item>
      <title>iOS视频开发入门</title>
      <link>https://IIHui.github.io/post/ios-video/</link>
      <pubDate>Wed, 12 Dec 2018 10:55:40 +0000</pubDate>
      
      <guid>https://IIHui.github.io/post/ios-video/</guid>
      <description>视频实质 纯粹的视频（不包括音频）实质上就是一组帧图片，经过视频编码成为视频(video)文件再把音频（audio）文件以及字幕文件组装在一起成为视频（movie）文件。 1秒内出现的图片数就是帧率，图片间隔越小画面就越流畅，所以帧率越高效果就越好，需要的存储空间也就越多。 录制视频的3种实现方式 UIImagePickerViewController：只能设置一些简单的参数来实现基本的视频录制的效果，自</description>
    </item>
    
    <item>
      <title>HTML入门</title>
      <link>https://IIHui.github.io/post/htm-primer/</link>
      <pubDate>Thu, 06 Dec 2018 19:22:27 +0000</pubDate>
      
      <guid>https://IIHui.github.io/post/htm-primer/</guid>
      <description>简介 HTML指的是超文本标记语言 (Hyper Text Markup Language)，它不是一种编程语言，而是一种标志语言，标记语言是一套标记标签，使用标记标签来描述网页。 .htm or .html 当保存HTML文件时，可以使用.htm,也可以使用.html文件后缀。使用.htm,这只是长久以来形成的习惯，因为过去的很多软件只允许三个字母的文件后缀。对于新的软件，使用.html完全没有问题。 HTML标签 HTML标签是由尖括号包围的关键词，比如&amp;</description>
    </item>
    
    <item>
      <title>CSS入门</title>
      <link>https://IIHui.github.io/post/css-primer/</link>
      <pubDate>Thu, 06 Dec 2018 10:43:48 +0000</pubDate>
      
      <guid>https://IIHui.github.io/post/css-primer/</guid>
      <description>关注点分离 关注点分离的意思是：各种技术只负责自己的领域，不要混合在一起，形成耦合。对于网页开发来说，主要是三种技术分离。 HTML:负责网页的结构，称为语义层。 CSS:负责网页的样式，称为视觉层。 JavaScript:负责网页的逻辑和交互，称为逻辑层或者交互层。 也就是说不要写行内样式和行内脚本，例如下面的代码就很糟糕： &amp;lt;h1 style=&amp;#34;color:red;font-size:46px;&amp;#34; onclick=&amp;#34;alert(&amp;#39;Hi&amp;#39;)&amp;#34;&amp;gt; Hello World &amp;lt;/h1&amp;gt; 关注点混合 而React出现之后，这个原则就不适用了，因为React是组</description>
    </item>
    
    <item>
      <title>XCode快捷键</title>
      <link>https://IIHui.github.io/post/xcode-quick/</link>
      <pubDate>Tue, 27 Nov 2018 15:20:06 +0000</pubDate>
      
      <guid>https://IIHui.github.io/post/xcode-quick/</guid>
      <description>MAC键盘图标 ⌘——Command () ⌃ ——Control ⌥——Option (alt) ⇧——Shift ⇪——Caps Lock 快捷键 Command+R 运行 Command+B 编译 Command+. 停止 Command + Shift + K 清除工程 Command + K 清除控制台信息 Command + N 新建文件 Command + Shift + N 创建新工程 导航栏 Command+0~9 工程导航 Command + 0 快速打开实用面板 Command + 1 查看工程文件 Command + 2 版本控制导航 Command + 3 符号导航(类) Command + 4 警告和错误导航 Command + 5 测试导航 Command + 6 调试导航 Command + 7 断点导航 Command + 9 报告导航 Command + Option + 0 打开右侧导航</description>
    </item>
    
    <item>
      <title>OC 入门</title>
      <link>https://IIHui.github.io/post/oc-tour/</link>
      <pubDate>Wed, 19 Sep 2018 14:29:51 +0000</pubDate>
      
      <guid>https://IIHui.github.io/post/oc-tour/</guid>
      <description>Objective-C 是C语言的严格超集——任何C语言程序不经过修改都可以直接通过Objective-C的编译器，在Objective-C中使用C语言代码也是完全合法的。Objective-C被描述为覆盖在C语言上的一层，因为Objective-C的原意就是在C语言的主体上加入面向对象的特性。 文件扩展名 文件扩展名 类型和作用 .h 头文件，包含类，类型，函数和常数声明 .m 源代码文件，典型的源代码文件扩展名，可以包含OC和C代码</description>
    </item>
    
    <item>
      <title>swift中的方法</title>
      <link>https://IIHui.github.io/post/swift-method/</link>
      <pubDate>Fri, 14 Sep 2018 09:31:40 +0000</pubDate>
      
      <guid>https://IIHui.github.io/post/swift-method/</guid>
      <description>方法是关联了特定类型的函数。类，结构体，枚举类型都能定义实例方法，方法封装了给定类型特定的任务和功能。 实例方法 实例方法是属于特定实例（类实例、结构体实例或者枚举实例）的函数。实例方法只能在类型的具体实例里被调用，不能独立于实例而被调用。 class Counter { var count = 0 func increment() { count += 1 } func increment(by amount: Int) { count += amount } func reset() { count = 0 } } 异变方法 在Swift中结构体和枚举是值类型。默认情况下，值类型属性不能被自身的实例方法修改。如果需要改</description>
    </item>
    
    <item>
      <title>JavaScript 数据类型</title>
      <link>https://IIHui.github.io/post/js-data-struct/</link>
      <pubDate>Mon, 20 Aug 2018 21:57:31 +0000</pubDate>
      
      <guid>https://IIHui.github.io/post/js-data-struct/</guid>
      <description>JavaScript不需要进行类型声明，因此它是一种弱类型的语言，这意味着可以在任何阶段改变变量的数据类型。 字符串 字符串是由零个或者多个字符组成，必须包含在引号中，单引号和双引号都可以。 数值 如果想给一个变量赋一个数值，不必限定它必须是一个整数。JavaScript允许使用带小数点的数值，并且允许任意位的小数。 数组 字符串、数值、布尔值都被称为标量（如果某个变量称为标量，那么在任何时候它就只能有一个值</description>
    </item>
    
    <item>
      <title>git使用</title>
      <link>https://IIHui.github.io/post/tool-git-usage/</link>
      <pubDate>Mon, 25 Jun 2018 09:36:27 +0000</pubDate>
      
      <guid>https://IIHui.github.io/post/tool-git-usage/</guid>
      <description>本地.git文件太大 本地.git文件太大可以使用git gc命令压缩：</description>
    </item>
    
    <item>
      <title>Go 实现各种内排序算法</title>
      <link>https://IIHui.github.io/post/go-sort/</link>
      <pubDate>Mon, 28 May 2018 12:13:06 +0000</pubDate>
      
      <guid>https://IIHui.github.io/post/go-sort/</guid>
      <description>内排序是指在排序过程中，数据都能够放在内存中处理，排序时不涉及数据的内、外交换。 插入类排序 直接插入排序 func InsertSort(data []int) { var i, j, cur int length := len(data) //获得切片对应数组的长度 for i = 1; i &amp;lt; length; i++ { cur = data[i] for j = i - 1; j &amp;gt;= 0; j-- { if data[j] &amp;gt; cur { data[j+1] = data[j] } else { break } } data[j+1] = cur } } 二分直接插入排序 func BinInsertSort(data []int) { var cur, start, mid, end int length := len(data) for i := 1; i &amp;lt; length; i++ { cur = data[i] start = 0 end = i - 1 for start &amp;lt;= end { mid = start + (end-start)/2 if data[mid] == cur { end = mid break } else if data[mid] &amp;gt; cur { end = mid - 1 } else { start = mid + 1 } }</description>
    </item>
    
    <item>
      <title>C&#43;&#43; 常见知识点</title>
      <link>https://IIHui.github.io/post/cpp-base/</link>
      <pubDate>Sat, 05 May 2018 17:24:44 +0000</pubDate>
      
      <guid>https://IIHui.github.io/post/cpp-base/</guid>
      <description>static的作用 对普通函数和全局变量而言static具有隐藏作用：将其修饰的全局变量和函数的作用域限定在本文件中。不加static修饰的函数和全局变量具有全局可见性。 普通局部变量而言 未初始化的static普通局部变量，编译器会将其初始化为0，因为BSS段(未初始化数据段）中所有的字节都默认为0x00。 使用static修饰的普通局部变量的生存期为整个源程序，即初始化一次便具有记忆性。但是，作用域只</description>
    </item>
    
    <item>
      <title>Go 标签</title>
      <link>https://IIHui.github.io/post/go-label/</link>
      <pubDate>Mon, 06 Nov 2017 16:11:37 +0000</pubDate>
      
      <guid>https://IIHui.github.io/post/go-label/</guid>
      <description>在for,switch或者select中都可以配合标签形式的标识符使用——某一行第一个以冒号结尾的单词（因为gofmt会自动将后续代码移动至下一行）。 一个实例 package main import &amp;#34;fmt&amp;#34; func main() { LABEL1: for i := 0; i &amp;lt;= 5; i++ { for j := 0; j &amp;lt;= 5; j++ { if j == 4 { continue LABEL1 } fmt.Printf(&amp;#34;i is: %d, and j is: %d\n&amp;#34;, i, j) } } 注意事项 标签的名称是大小写敏感的，为了提升可读性，一般建议标签全部使用大写。 使用逆向的go to语句容易产生意大利苗条似的代码，所以应该避免。逆向是指先使</description>
    </item>
    
    <item>
      <title>Go 中if语句</title>
      <link>https://IIHui.github.io/post/go-if/</link>
      <pubDate>Thu, 02 Nov 2017 19:53:47 +0000</pubDate>
      
      <guid>https://IIHui.github.io/post/go-if/</guid>
      <description>if是用于测试某个条件（布尔型，又被称为逻辑型）的语句，如果该条件成立，则会执行if后由大括号括起来的代码块，否则就忽略该代码块继续执行后续的代码。Go中if语句总共有三种形式，分别是： 不带else的if； 带一个else的if语句； 带else if的if语句； 包含初始化的if语句 不带else的if 测试条件是布尔型的语句，如果该条件成立，则执行大括号中的内容。 if condition { //{ 与condition 须在同一行 //do something</description>
    </item>
    
    <item>
      <title>C&#43;&#43;智能指针</title>
      <link>https://IIHui.github.io/post/cpp-smart-pointer/</link>
      <pubDate>Sun, 13 Aug 2017 16:01:53 +0000</pubDate>
      
      <guid>https://IIHui.github.io/post/cpp-smart-pointer/</guid>
      <description>智能指针是一个类，它对普通指针进行封装，使智能指针类对象具有普通指针类型一样的操作。具体而言，复制对象时，副本和原对象都指向同一存储区域，如果通过一个副本改变其所指的值，则通过另一对象访问的值也会改变。与普通指针所不同的是，智能指针能够对内存进行进行自动管理，避免出现悬垂指针等情况。 普通指针 对于普通指针，当有多个指针指向同一个基础对象时，如果某个指针delete了该基础对象，对这个指针来说已经明确</description>
    </item>
    
    <item>
      <title>Go 中映射(字典）</title>
      <link>https://IIHui.github.io/post/go-map/</link>
      <pubDate>Sat, 05 Aug 2017 19:25:17 +0000</pubDate>
      
      <guid>https://IIHui.github.io/post/go-map/</guid>
      <description>映射(或称为字典)是一种数据结构，用于存储一系列无序的键值对，它是基于键来存储值。映射的键可以是任何值，只要这个值可以使用==运算符做比较即可。切片、函数以及包含切片的结构类型这些类型由于具有引用语义， 不能作为映射的键。 创建和初始化 使用make函数 //创建一个映射，键的类型是 string，值的类型是 int dict1 := make(map[string]int) dict2 := make(map[string]int,5) //长度为5 使用字面量 // 创建一个映射，键和值的类型都是 string，使用两个键值对初始</description>
    </item>
    
    <item>
      <title>Go 切片</title>
      <link>https://IIHui.github.io/post/go-slice/</link>
      <pubDate>Fri, 04 Aug 2017 15:37:58 +0000</pubDate>
      
      <guid>https://IIHui.github.io/post/go-slice/</guid>
      <description>定义 切片是围绕动态数组的概念来构建的，但是本身并非动态数组或数组指针，它通过内部指针引用底层数组，设定相关属性，将数据读写操作限定到指定区域。切片这个名字来自于——创建一个新的切片就是把底层数组切出一部分。 type slice struct{ array unsafe.Pointer // slice中指向底层数组指定位置的的指针 len int // slice 的长度 cap int //slice 容量，即最大长度，就是slice开始位置到数组的最后位置的长度 } ![c600](http://oqe76o492.bkt.</description>
    </item>
    
    <item>
      <title>Go 数组</title>
      <link>https://IIHui.github.io/post/go-array/</link>
      <pubDate>Thu, 03 Aug 2017 15:11:37 +0000</pubDate>
      
      <guid>https://IIHui.github.io/post/go-array/</guid>
      <description>定义 在Go语言里，数组是一个长度固定的数据类型，用于连续存储多个具有相同的类型的元素。数组存储的类型可以是内置类型，如整型或者字符串，也可以是某种结构类型。 ![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-08-03 下午3.13.38.png) 声明和初始化 声明 声明数组时需要指定内部存储的数据的类型，以及需要存储的元素的数量，这个数量也称为数组的长度。数组长度必须是一</description>
    </item>
    
    <item>
      <title>Go 未命名类型</title>
      <link>https://IIHui.github.io/post/go-undef-type/</link>
      <pubDate>Thu, 03 Aug 2017 11:04:39 +0000</pubDate>
      
      <guid>https://IIHui.github.io/post/go-undef-type/</guid>
      <description>未命名类型 在Go中数组、切片、字典、通道类型与具体元素类型或长度属性相关，故被称为未命名类型。具有相同声明的未命名类型被称为同一类型，在 Go 中未命名类型共有8类。 具有相同基础类型的指针 具有相同元素类型和长度的数组array 具有相同元素类型的切片slice 具有相同键和值类型的字典map 具有相同数据类型以及操作方向的通道channel 具有相同字段序列（字段名、字段类型、标签以及字段顺序）的结构体stru</description>
    </item>
    
    <item>
      <title>Go 接口</title>
      <link>https://IIHui.github.io/post/go-interface/</link>
      <pubDate>Wed, 02 Aug 2017 09:13:45 +0000</pubDate>
      
      <guid>https://IIHui.github.io/post/go-interface/</guid>
      <description>接口定义 接口代表一种调用契约，是多个方法声明的集合。在某些动态语言中接口(interface)也被称为协议(protocol)。准备交互的双方，共同遵守事先的约定规则，使得在无须知道对方身份的情况下进行协作。接口关心的是做什么，而不关心怎么做，谁来做。接口解除了类型依赖，有助于减少用户可视方法，屏蔽内部结构和实现细节。但这并不意味着可以滥用接口，因为实现接口会有运行时开销。接口最常见的使用场景是对</description>
    </item>
    
    <item>
      <title>Go 定义类型</title>
      <link>https://IIHui.github.io/post/go-struct/</link>
      <pubDate>Tue, 01 Aug 2017 09:43:30 +0000</pubDate>
      
      <guid>https://IIHui.github.io/post/go-struct/</guid>
      <description>值的类型给编译器提供两部分信息：①需要分配多少内存给这个值；②这段内存表示什么。Go语言允许用户定义类型，当用户声明一个新类型时，这个声明就给编译器提供一个框架，告知必要的内存大小和表示信息。 结构体 Go语言中声明用户定义的类型有两种方法，①最常用的方法是使用关键字struct，它可以让用户创建一个结构类型；②另一种是使用根据已有类型来定义新的类型。 结构体的定义 结构体类型通过组合一系列固定且唯一的字</description>
    </item>
    
    <item>
      <title>Go 延迟调用</title>
      <link>https://IIHui.github.io/post/go-defer/</link>
      <pubDate>Mon, 31 Jul 2017 08:55:09 +0000</pubDate>
      
      <guid>https://IIHui.github.io/post/go-defer/</guid>
      <description>关键字defer允许我们推迟到函数返回前一刻(或任意位置执行return语句之后)才执行某个语句或函数。 为什么要在返回之后才执行这些语句？因为return语句同样可以包含一些操作，而不是单纯地返回某个值，实际上此时return语句要做三件事：①如果有命名参数，将返回值赋给命名返回值;②执行defer语句或函数;③结束函数的执行。 语句defer向当前函数注册稍后执行的函数调用，这些函数被称为延迟调用</description>
    </item>
    
    <item>
      <title>Go 方法</title>
      <link>https://IIHui.github.io/post/go-method/</link>
      <pubDate>Sun, 30 Jul 2017 21:06:07 +0000</pubDate>
      
      <guid>https://IIHui.github.io/post/go-method/</guid>
      <description>方法 在Go中结构体就像是类的一种简化形式，方法就像类中的方法。方法是与对象实例绑定的特殊函数，方法和函数定义语法区别在于:方法有前置实例接收参数receiver，编译器以此确定方法所属类型。 接收者类型几乎可以是任何类型，不仅仅是结构体类型，甚至可以是函数类型。但是，有两种类型不可以有方法： 接收者不能是一个接口类型， 因为接口是一个抽象定义，但是方法需要具体实现。 接收者的类型不能是本身类型是指针的类型</description>
    </item>
    
    <item>
      <title>Go 包</title>
      <link>https://IIHui.github.io/post/go-package/</link>
      <pubDate>Sat, 29 Jul 2017 10:02:56 +0000</pubDate>
      
      <guid>https://IIHui.github.io/post/go-package/</guid>
      <description>包是结构化的一种方式,所有Go语言的程序都会组织成若干组文件，每组文件被称为一个包。每个文件都属于且仅属于一个包，一个包中可以包含许多以.go为扩展名的源文件。 包中源文件 源文件都使用UTF-8编码，每个源文件都属于包的一部分，在文件头部用package声明所属包。 每一个可独立运行的Go语言程序必定包含一个main包，在这个main包中必定包含一个入口函数main，这个函数没有参数也没有返回值。 入口</description>
    </item>
    
    <item>
      <title>Go 数据</title>
      <link>https://IIHui.github.io/post/go-data/</link>
      <pubDate>Fri, 28 Jul 2017 10:32:19 +0000</pubDate>
      
      <guid>https://IIHui.github.io/post/go-data/</guid>
      <description>数据类型 Go 中数据分为基本类型，数组，引用，字典（映射)，通道，函数，结构体，接口等等。 切片slice可实现类似动态数组的功能y := make([]int, 0, 5); append(y,7)。 将字典map类型内置，可以直接从运行层面获得性能优化。 所谓ok-idiom模式，就是在返回值中用一个名为ok的布尔值来标识操作是否成功，因为很多操作默认返回零值，所以需要额外说明。 m := make(map[string]int) m[&amp;#34;a&amp;#34;]=1 z,ok:=m[&amp;#34;b&amp;#34;] fmt.Println(z,ok) 可以为任意类型定义方法 type X int func (x * X) inc() { *x++ } 字符串</description>
    </item>
    
    <item>
      <title>Go 函数</title>
      <link>https://IIHui.github.io/post/go-func/</link>
      <pubDate>Thu, 27 Jul 2017 21:58:12 +0000</pubDate>
      
      <guid>https://IIHui.github.io/post/go-func/</guid>
      <description>Go中有3种类型的函数，第一种是普通带名字的函数，第二种是匿名函数(或者被称为lambda函数)，第三种是方法（含有接收者的特殊函数）。 特点 在Go中关键字func用于定义函数，相比于其他语言，Go中函数有以下的特点： 函数是一等公民，即可作为参数或者返回值，可以存入变量，与变量的地位是等同的。 函数可定义多个返回值，也可以对返回值命名。 Go 中函数无需前置说明，即可以先使用后定义。 Go中函数不支持同名重载</description>
    </item>
    
    <item>
      <title>Go 表达式</title>
      <link>https://IIHui.github.io/post/go-expression/</link>
      <pubDate>Wed, 26 Jul 2017 20:14:46 +0000</pubDate>
      
      <guid>https://IIHui.github.io/post/go-expression/</guid>
      <description>运算符 在Go中，一元运算符优先级最高，二元则分为5个级别，二元运算符遵循相同优先级从左到右依次计算，二元运算符从高到低的5个等级为： * / % &amp;lt;&amp;lt; &amp;gt;&amp;gt; &amp;amp; &amp;amp;^ + - | ^ == != &amp;lt; &amp;lt;= &amp;gt; &amp;gt;= &amp;amp;&amp;amp; || 二元运算符中除了移位操作外，操作数类型必须相同。如果其中一个是无显式类型声明的常量（该常量声明时，没有给出类型），那么该常量操作数会自动转型。 在Go中，位移右操作数必须是无符号整数，或可以转换的无显式类型常量（用整数字面值来定义常</description>
    </item>
    
    <item>
      <title>Go 枚举</title>
      <link>https://IIHui.github.io/post/go-iota/</link>
      <pubDate>Tue, 25 Jul 2017 09:50:43 +0000</pubDate>
      
      <guid>https://IIHui.github.io/post/go-iota/</guid>
      <description>Go中没有定义枚举变量，但是可以借助iota来生成一组自增常量值来实现枚举，iota是一个比较奇怪的存在，它只能用在const的声明中，是一个从0开始的行数索引器。 注意 首先，iota是一个行数索引器,它是按行递增的。 const ( x1 = iota //x1=0 x2 //x2=1 x3 //x3=2 x4 //x4=3 ) fmt.Println(x1, x2, x3, x4) //0,1,2,3 const ( _ = iota //iota 代表0 KB = 1 &amp;lt;&amp;lt; (10 * iota) //iota 代表1 MB //iota 代表2 GB ) fmt.Println(KB, MB, GB) //1024 1048576 1073741824 如果中断iota自增，则必须显式恢复，且后续自增按行序递增，而不是C++语言中的e</description>
    </item>
    
    <item>
      <title>Go 常量</title>
      <link>https://IIHui.github.io/post/go-const/</link>
      <pubDate>Tue, 25 Jul 2017 09:45:49 +0000</pubDate>
      
      <guid>https://IIHui.github.io/post/go-const/</guid>
      <description>常量是一种表达式，其可以保证在编译阶段计算出表达式的值，并不需要等到运行时，从而使编译器得以知晓其值。所有常量本质上都属于基本类型：布尔型，字符串或数字。 特别说明 Go中常量可以是任意基本类型，也包括具名的基本类型(例如time.Duration)。但是许多常量并不从属某一具体类型。编译器将这些从属类型待定的常量表示成某些值，这些值比基本类型的数字精度更高，且算术精度高于原生的机器精度，可以认为它们</description>
    </item>
    
    <item>
      <title>Go 变量定义</title>
      <link>https://IIHui.github.io/post/go-var/</link>
      <pubDate>Mon, 24 Jul 2017 14:11:26 +0000</pubDate>
      
      <guid>https://IIHui.github.io/post/go-var/</guid>
      <description>Go中每一个文件都以package声明开头，表明文件属于哪一个包。package声明后面是import声明，然后是不区分顺序的包级别的类型，变量、常量和函数的声明。包级别的实体名字不仅对于包含其声明的源文件可见，而且对于同一包里面的所有的源文件可见。 变量命名 以字母（这里指的是广义字母，只要能够被unicode编码即可）或下划线开始，由多个字母，数字下划线组合而成。 在Go中变量的标识符是区分大小写。</description>
    </item>
    
    <item>
      <title>Go 基本类型</title>
      <link>https://IIHui.github.io/post/go-type/</link>
      <pubDate>Mon, 24 Jul 2017 10:34:44 +0000</pubDate>
      
      <guid>https://IIHui.github.io/post/go-type/</guid>
      <description>Go语言中定义了清晰完备的预定义基本类型（共21类），使得开发跨平台应用时无须过多考虑符号和长度差异，具体如下表： ![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-12-21 下午2.36.532.jpg) 整型数据 十进制整数，使用0-9的数字表示且不以0开头。 八进制整数，以0开头，0-7的数字表示。 十六进制整数，以0X或者是0x开头0-9|A-F|a-f组成。 a,b,c:=100,0144,0x64 fmt.Println(a,b,c) //100 100</description>
    </item>
    
  </channel>
</rss>